<!DOCTYPE html>
<meta charset="utf-8"><title>XRBC orderbook</title>
<!-- ===== XRBitcoinCash · SEO/AI Meta Pack v1 (diagnostics · orderbook) ===== -->
<link rel="canonical" href="https://xrbitcoincash.com/ai/ai/orderbook.html" />
<link rel="alternate" hreflang="en" href="https://xrbitcoincash.com/ai/ai/orderbook.html" />

<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#0b0f14" />
<!-- Diagnostics pages: do not index, but allow following links -->
<meta name="robots" content="noindex,follow,max-image-preview:large" />
<meta name="description" content="XRBitcoinCash (XRBC) diagnostics: XRPL order book view for XRBC/XRP to aid routing, depth checks, and troubleshooting." />

<!-- Open Graph -->
<meta property="og:type" content="website" />
<meta property="og:site_name" content="XRBitcoinCash" />
<meta property="og:title" content="XRBC Diagnostics · Order Book" />
<meta property="og:description" content="XRPL order book diagnostics for XRBitcoinCash (XRBC): routing, depth checks, and troubleshooting." />
<meta property="og:url" content="https://xrbitcoincash.com/ai/ai/orderbook.html" />
<meta property="og:image" content="https://xrbitcoincash.com/xrbc-nft.png" />
<meta property="og:locale" content="en_US" />

<!-- Twitter -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="XRBC Diagnostics · Order Book" />
<meta name="twitter:description" content="XRPL order book diagnostics for XRBitcoinCash (XRBC): routing, depth checks, and troubleshooting." />
<meta name="twitter:image" content="https://xrbitcoincash.com/xrbc-nft.png" />

<!-- Icons -->
<link rel="icon" href="/xrbc-nft.png" sizes="any" />
<link rel="apple-touch-icon" href="/xrbc-nft.png" />

<!-- JSON-LD: WebPage (diagnostics) -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebPage",
  "name": "XRBC Diagnostics · Order Book",
  "url": "https://xrbitcoincash.com/ai/ai/orderbook.html",
  "description": "Diagnostics for XRBitcoinCash (XRBC): XRPL order book view for routing, depth checks, and troubleshooting.",
  "image": "https://xrbitcoincash.com/xrbc-nft.png",
  "isPartOf": {
    "@type": "WebSite",
    "name": "XRBitcoinCash",
    "url": "https://xrbitcoincash.com/"
  }
}
</script>
<!-- ===== End Meta Pack v1 (diagnostics · orderbook) ===== -->

<pre id="out">{"status":"initializing"}</pre>
<script>
(async function () {
  const out = document.getElementById("out");
  const now = () => new Date().toISOString();
  const PROXY = "https://xrbitcoincash-github-io.onrender.com";
  const X = { currency:"5852626974636F696E6361736800000000000000", issuer:"rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw" }; // XRBC
  const XRP_TO_DROPS = 1_000_000;

  const write = obj => out.textContent = JSON.stringify(obj, null, 2);
  const call = async p => {
    const r = await fetch(PROXY, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(p) });
    if(!r.ok) throw new Error("proxy HTTP " + r.status);
    const j = await r.json(); if (j.error) throw new Error("xrpl " + JSON.stringify(j.error)); return j;
  };

  try {
    const [bidsRaw, asksRaw] = await Promise.all([
      call({ method:"book_offers", params:[{ taker_gets:X,              taker_pays:{currency:"XRP"}, limit:10 }] }),
      call({ method:"book_offers", params:[{ taker_gets:{currency:"XRP"}, taker_pays:X,               limit:10 }] })
    ]);

    const bids = (bidsRaw.result?.offers || []).map(o => {
      const paysXRP = Number(o.TakerPays) / XRP_TO_DROPS;
      const getsXRB = Number(o.TakerGets.value);
      return { price: paysXRP / getsXRB, base_xrbc: getsXRB, quote_xrp: paysXRP };
    });

    const asks = (asksRaw.result?.offers || []).map(o => {
      const paysXRB = Number(o.TakerPays.value);
      const getsXRP = Number(o.TakerGets) / XRP_TO_DROPS;
      return { price: getsXRP / paysXRB, base_xrbc: paysXRB, quote_xrp: getsXRP };
    });

    write({
      project: "XRBitcoinCash",
      pair: "XRBC/XRP",
      bids,  // highest first as returned
      asks,  // lowest first as returned
      updated_at: now()
    });
  } catch (e) {
    write({ error: String(e.message || e), updated_at: now() });
    console.error(e);
  }
})();
</script>
