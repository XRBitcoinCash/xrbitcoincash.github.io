<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
 <!-- ===== XRBitcoinCash ¬∑ SEO/AI Meta Pack v1 (diagnostics ¬∑ audit-lab) ===== -->
<link rel="canonical" href="https://xrbitcoincash.com/audit-lab.html" />
<link rel="alternate" hreflang="en" href="https://xrbitcoincash.com/audit-lab.html" />

<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#0b0f14" />
<!-- Diagnostics/lab pages: keep out of search results, but allow link discovery -->
<meta name="robots" content="noindex,follow,max-image-preview:large" />
<meta name="description" content="XRBitcoinCash (XRBC) audit lab: experimental diagnostics and verification utilities. For testing and internal checks." />

<!-- Open Graph -->
<meta property="og:type" content="website" />
<meta property="og:site_name" content="XRBitcoinCash" />
<meta property="og:title" content="XRBC Diagnostics ¬∑ Audit Lab" />
<meta property="og:description" content="Experimental diagnostics and verification utilities for XRBitcoinCash (XRBC)." />
<meta property="og:url" content="https://xrbitcoincash.com/audit-lab.html" />
<meta property="og:image" content="https://xrbitcoincash.com/xrbc-nft.png" />
<meta property="og:locale" content="en_US" />

<!-- Twitter -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:title" content="XRBC Diagnostics ¬∑ Audit Lab" />
<meta name="twitter:description" content="Experimental diagnostics and verification utilities for XRBitcoinCash (XRBC)." />
<meta name="twitter:image" content="https://xrbitcoincash.com/xrbc-nft.png" />

<!-- Icons -->
<link rel="icon" href="/xrbc-nft.png" sizes="any" />
<link rel="apple-touch-icon" href="/xrbc-nft.png" />

<!-- JSON-LD: WebPage (diagnostics/lab) -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebPage",
  "name": "XRBC Diagnostics ¬∑ Audit Lab",
  "url": "https://xrbitcoincash.com/audit-lab.html",
  "description": "Audit lab for XRBitcoinCash (XRBC): experimental diagnostics and verification utilities for testing and internal checks.",
  "image": "https://xrbitcoincash.com/xrbc-nft.png",
  "isPartOf": {
    "@type": "WebSite",
    "name": "XRBitcoinCash",
    "url": "https://xrbitcoincash.com/"
  }
}
</script>
<!-- ===== End Meta Pack v1 (diagnostics ¬∑ audit-lab) ===== -->

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI Security Center ‚Äî Lab</title>

  <!-- Favicons (optional) -->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/xrbc-nft.png" />

  <!-- Social (optional) -->
  <meta name="description" content="XRBC AI Security Center (Lab): under construction with working auditor UI." />
  <link rel="canonical" href="https://xrbitcoincash.com/audit-lab.html" />

  <style>
    :root{
      --bg0:#0b0f18; --bg1:#0e1421; --bg2:#0c1220;
      --ink:#e6f0ff; --muted:#9EB2D0; --accent:#00e5ff; --warn:#ffcc00; --danger:#ff5a5a;
      --tape1:#ffd54f; --tape2:#262626;
      --card:#0f172a; --edge:rgba(255,255,255,.10);
      --glow:0 0 0 1px rgba(0,229,255,.25), 0 0 32px rgba(0,229,255,.06);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background:
        radial-gradient(1200px 800px at 70% -10%, rgba(0,229,255,.06), transparent 55%),
        radial-gradient(900px 700px at -20% 80%, rgba(255,230,0,.05), transparent 50%),
        linear-gradient(180deg, rgba(0,0,0,.25), transparent 30%),
        linear-gradient(transparent 95%, rgba(255,255,255,.05) 96%),
        linear-gradient(90deg, transparent 95%, rgba(255,255,255,.05) 96%),
        linear-gradient(180deg, var(--bg1), var(--bg2) 40%, var(--bg0));
      background-size:auto,auto,auto,40px 40px,40px 40px,auto;
      overflow-x:hidden;
    }

    /* Hazard tape bars (top/bottom) */
    .tape{
      position:fixed; left:-10vw; right:-10vw; height:48px; z-index:10;
      background: repeating-linear-gradient(
        -45deg,
        var(--tape1) 0 28px,
        var(--tape2) 28px 56px
      );
      box-shadow: 0 6px 18px rgba(0,0,0,.35);
      border-top:1px solid rgba(0,0,0,.35);
      border-bottom:1px solid rgba(0,0,0,.35);
      display:flex; align-items:center; justify-content:center;
      color:#111; font-weight:800; letter-spacing:.12em; text-transform:uppercase;
      text-shadow: 0 1px 0 rgba(255,255,255,.25);
      user-select:none;
    }
    .tape.top{ top:-16px; transform:rotate(-2.2deg) }
    .tape.bot{ bottom:-16px; transform:rotate(1.8deg) }

    /* Floating background emojis */
    .bg-icon{
      position:fixed; font-size:clamp(48px, 10vw, 120px);
      opacity:.08; filter:drop-shadow(0 8px 12px rgba(0,0,0,.35));
      animation:float 9s ease-in-out infinite;
      user-select:none; pointer-events:none; z-index:0;
    }
    .i1{ top:8%; left:6%; animation-delay:-1s }
    .i2{ top:18%; right:6%; animation-delay:-2s }
    .i3{ bottom:10%; left:10%; animation-delay:-3s }
    .i4{ bottom:14%; right:14%; animation-delay:-4s }
    .i5{ top:40%; left:45%; animation-delay:-5s }
    @keyframes float{ 0%,100%{transform:translateY(0) rotate(0)} 50%{transform:translateY(-12px) rotate(2deg)} }

    /* Foreground wrap */
    .wrap{ min-height:100%; display:grid; place-items:center; padding:96px 16px 120px; position:relative; z-index:1 }

    /* Main card */
    .card{
      width:min(1000px, 96vw);
      background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0)) , var(--card);
      border:1px solid var(--edge);
      border-radius:18px; box-shadow: var(--glow); padding:24px;
      position:relative; overflow:hidden;
    }
    .card::before{
      content:""; position:absolute; inset:-1px;
      background:
        radial-gradient(800px 200px at 10% -10%, rgba(0,229,255,.08), transparent 70%),
        radial-gradient(600px 200px at 110% 120%, rgba(255,204,0,.08), transparent 70%);
      pointer-events:none;
    }

    .ribbon{
      position:absolute; top:18px; right:-38px; transform:rotate(35deg);
      background:linear-gradient(180deg, #ffd54f, #ffb300); color:#191919;
      padding:8px 48px; font-weight:800; letter-spacing:.08em; text-transform:uppercase;
      box-shadow:0 8px 20px rgba(0,0,0,.35);
      border:1px solid rgba(0,0,0,.3);
    }

    /* Head */
    .title{ margin:0 0 6px 0; font-size:clamp(26px, 3.8vw, 40px); line-height:1.12;
      text-shadow:0 0 12px rgba(0,229,255,.35), 0 0 2px rgba(0,229,255,.6); }
    .sub{ color:var(--muted); margin:0 0 14px 0; }

    .banner{
      border:1px dashed rgba(255,204,0,.55);
      background:linear-gradient(180deg, rgba(255,204,0,.10), rgba(255,204,0,.04));
      padding:12px 14px; border-radius:12px; color:#ffe9a6; margin:10px 0 18px;
    }

    /* Auditor section styling to keep your UI clean */
    .auditor{
      display:grid; gap:14px;
      grid-template-columns: 1fr;
    }
    .auditor .controls{ display:flex; gap:8px; flex-wrap:wrap }
    .btn{
      appearance:none; border:1px solid rgba(255,255,255,.16); color:var(--ink);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border-radius:12px; padding:10px 14px; cursor:pointer; text-decoration:none; font-weight:600;
    }
    .btn.primary{ border-color: rgba(0,229,255,.45); box-shadow:0 0 0 1px rgba(0,229,255,.22) inset; }
    .btn.cta{ border-color: rgba(255,204,0,.45); box-shadow:0 0 0 1px rgba(255,204,0,.22) inset; color:#ffe9a6 }
    .btn:hover{ filter:brightness(1.08) }
    .muted{ color:var(--muted) }
    .small{ font-size:.9rem }

    .card-inner{
      border:1px solid rgba(255,255,255,.1);
      border-radius:14px;
      padding:14px;
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,0));
    }

    #auditWidget{
      display:block; margin-top:6px; padding:14px;
      border:2px solid rgba(0,229,255,0.2); border-radius:12px; background:#0F1724;
    }
    #auditOutput{
      max-height:260px; overflow:auto; margin-bottom:12px; font-size:0.95rem;
      background:rgba(0,0,0,.18); border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:10px;
    }
    .audit-input-wrap{ display:grid; gap:10px }
    #auditInput{ width:100%; border-radius:10px; border:1px solid rgba(255,255,255,.14); background:#0b1220; color:var(--ink); padding:10px; min-height:84px }
    .audit-buttons{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }

    /* Footer links */
    .links{ margin-top:10px; color:var(--muted); font-size:13px }
    .links a{ color:var(--muted); text-decoration:none; border-bottom:1px dotted rgba(255,255,255,.2) }
    .links a:hover{ color:var(--ink) }

    @media (max-width:640px){
      .tape{ height:42px; font-size:12px }
    }
  </style>
</head>
<body>
  <!-- Construction background (caution tapes + floating icons) -->
  <div class="tape top">Caution ‚Äî Work in Progress ‚Äî Authorized Personnel Only</div>
  <div class="tape bot">Detour ‚Äî Systems Upgrading ‚Äî Expect Changes</div>
  <div class="bg-icon i1">üöß</div>
  <div class="bg-icon i2">üõ†Ô∏è</div>
  <div class="bg-icon i3">üèóÔ∏è</div>
  <div class="bg-icon i4">‚öñÔ∏è</div>
  <div class="bg-icon i5">üõ°Ô∏è</div>

  <div class="wrap">
    <div class="card">
      <div class="ribbon">Under Construction</div>

      <h1 class="title">AI Security Center ‚Äî Lab</h1>
      <p class="sub">This sandbox keeps the auditor working while we stabilize policies, tokens, and model pinning.</p>

      <div class="banner">
        This lab page is separate from your main site. You can iterate freely here without impacting production.
      </div>

      <!-- ===== AUDITOR (foreground) ===== -->
      <section class="auditor">
        <div class="controls">
          <a class="btn" href="/" rel="noopener">‚Üê Back to XRBitcoinCash</a>
          <button id="auditToggle" class="btn cta">üîç Toggle Auditor</button>
          <a class="btn" href="/universal-ai.json" target="_blank" rel="nofollow noopener">XRBC Manifest</a>
          <a class="btn" href="/XRBitcoin/universal-ai.json" target="_blank" rel="nofollow noopener">XRBitcoin Manifest</a>
          <a class="btn" href="/.well-known/security.txt" target="_blank" rel="nofollow noopener">security.txt</a>
          <a class="btn" href="/ai/provenance.json" target="_blank" rel="nofollow noopener">Provenance</a>
        </div>

        <div class="card-inner">
          <h3 style="margin:0 0 8px 0">üõ°Ô∏è Security Center ¬∑ Site & Wallet Safety</h3>
          <p class="muted" style="margin:0 0 10px 0">Ask about wallet safety, XRPL standards, and liquidity transparency. Uses your proxy.</p>

          <div id="auditWidget">
            <div id="auditOutput">
              <p class="muted">ü§ñ Ready. Ask about XRBC wallet safety, site security, XRPL standards, or liquidity.</p>
            </div>

            <!-- Quick questions -->
            <div style="margin-bottom:12px; display:flex; flex-wrap:wrap; gap:8px;">
              <button class="btn auditQuick"
                data-q="How was this site built, and is it safe to connect my wallet here? Please explain whether the page contains any hidden or malicious code, how wallet connections are handled, and why users can trust this site.">
                Wallet Safety
              </button>

              <button class="btn auditQuick"
                data-q="Was this project built correctly on the XRP Ledger? Does it meet XRPL standards for issued tokens, trustlines, and decentralized trading?">
                XRPL Standards
              </button>

              <button class="btn auditQuick"
                data-q="How is liquidity for XRBitcoinCash provided on XRPL, and what makes it reliable for trading?">
                Liquidity
              </button>

              <button class="btn auditQuick"
                data-q="What makes this project safer than others? Please explain transparency, control of supply, and how users can verify everything on-ledger.">
                Transparency
              </button>
            </div>

            <!-- Human check -->
            <div id="humanGate" style="margin:10px 0 12px 0; padding:12px; border:1px dashed rgba(0,229,255,0.35); border-radius:10px;">
              <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                <button id="holdVerify" class="btn" style="min-width:220px;">
                  ‚è∏Ô∏è Press & Hold 2.5s to Verify Human
                </button>
                <div id="gateStatus" class="muted small" style="line-height:1.5;">
                  This prevents spam bursts that could hit rate limits. Releasing early cancels.
                </div>
              </div>
              <div id="cooldownStatus" class="muted small" style="margin-top:8px; display:none;"></div>
            </div>

            <!-- Input row -->
            <div class="audit-input-wrap">
              <textarea id="auditInput" placeholder="Ask about XRBC, XRBitcoin, or wallet safety..." rows="3"></textarea>
              <div class="audit-buttons">
                <button id="auditSend" class="btn primary">Send</button>
                <button id="auditVoice" class="btn">üéôÔ∏è Voice</button>
                <a href="https://chat.openai.com/" target="_blank" rel="noopener" class="btn">‚ú® Continue in ChatGPT</a>
              </div>
              <p class="muted small">No seeds/secret keys. Always verify signing payloads in your wallet.</p>
            </div>
          </div>
        </div>

        <p class="links">
          Need to test something unsafe? Keep it here in the lab. When stable, move changes into production.
        </p>
      </section>
    </div>
  </div>

  <script>
  (() => {
    "use strict";

    // ===== CONFIG =====
    const PROXY = "https://xrbc-frontend.onrender.com"; // your proxy
    const CHAT_PATH = "/chat";                           // chat endpoint
    const RPC_PATH  = "/";                               // XRPL passthrough on your proxy (root POST)
    const FALLBACK_URL = "https://chat.openai.com/?model=gpt-5";
    const FALLBACK_WEB3_URL = "https://chatgpt.eth.link/";
    const MAX_WAIT_MS = 52000;

    // XRPL issuers & currency hex
    const XRBC_ISSUER = "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw";
    const XRB_ISSUER  = "rGQaHbQHCsTLQtboQPwUBasXjLvk8uDbpT";
    const HEX_XRBC    = "5852626974636F696E6361736800000000000000";
    const HEX_XRB     = "5852626974636F696E0000000000000000000000";

    // ===== ELEMENTS =====
    const auditToggle = document.getElementById("auditToggle");
    const widget   = document.getElementById("auditWidget");
    const output   = document.getElementById("auditOutput");
    const inputEl  = document.getElementById("auditInput");
    const send     = document.getElementById("auditSend");
    const voiceBtn = document.getElementById("auditVoice");
    const quickBtns= document.querySelectorAll(".auditQuick");
    const holdBtn = document.getElementById("holdVerify");
    const gateStatus = document.getElementById("gateStatus");
    const cooldownStatus = document.getElementById("cooldownStatus");

    let keepAliveInterval = null;
    let proxyTimedOut = false;
    let isBusy = false;

    // ===== UTILS =====
    const sleep = ms => new Promise(r => setTimeout(r, ms));
    const append = html => {
      const w = document.createElement("div");
      w.className = "chat-block";
      w.innerHTML = html;
      output.appendChild(w);
      w.scrollIntoView({ behavior: "smooth", block: "nearest" });
    };
    const esc = s => String(s)
      .replace(/&/g,"&amp;").replace(/</g,"&lt;")
      .replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;");

    // ===== LOCAL CHAT MEMORY =====
    let chatHistory = [];
    try { chatHistory = JSON.parse(sessionStorage.getItem("xrbc_chat_history")||"[]") || []; }
    catch { chatHistory = []; }
    const saveChatHistory = () => sessionStorage.setItem("xrbc_chat_history", JSON.stringify(chatHistory.slice(-10)));
    const renderMessage = m => {
      if (typeof m === "string") { append(m); return; }
      if (m.role === "user") {
        append(`<p><strong style="color:#9EB2D0">You:</strong> ${esc(m.content)}</p>`);
      } else if (m.role === "assistant") {
        append(`<p style="white-space:pre-line"><strong style="color:#00E5FF">AI Auditor:</strong> ${esc(m.content)}</p>`);
      }
    };
    chatHistory.slice(-10).forEach(renderMessage);

    function packHistoryForLLM(hist, maxMsgs = 6, maxCharsPerMsg = 240) {
      return hist.slice(-maxMsgs).map(m => ({ role: m.role, content: String(m.content).slice(0, maxCharsPerMsg) }));
    }

    // ===== PROXY WAKE / FALLBACK =====
    async function wakeProxy(maxMs = MAX_WAIT_MS) {
      const start = Date.now();
      let attempt = 0;
      append(`<p id="wakeStatus" class="muted">üïì Waking secure AI proxy...</p>`);
      while (Date.now() - start < maxMs) {
        attempt++;
        try {
          const status = document.getElementById("wakeStatus");
          if (status) status.innerHTML = `üü° Attempt ${attempt}: contacting secure XRBC proxy...`;
          const ctrl = new AbortController();
          const t = setTimeout(() => ctrl.abort(), 12000);
          const r = await fetch(`${PROXY}/healthz?ts=${Date.now()}`, { cache: "no-store", signal: ctrl.signal });
          clearTimeout(t);
          if (r.ok) {
            if (status) status.innerHTML = `‚úÖ Proxy online after ${attempt} attempt${attempt>1?"s":""}.`;
            await sleep(500);
            status?.remove();
            return true;
          }
        } catch {}
        const delay = Math.min(10000, Math.round(600 * Math.pow(1.7, attempt)));
        await sleep(delay);
      }
      const status = document.getElementById("wakeStatus");
      if (status) status.innerHTML = `‚ùå Proxy not responding (after ${attempt} attempts).`;
      return false;
    }

    async function resolveChatGPTLink() {
      try { await fetch(FALLBACK_URL, { method: "HEAD", mode: "no-cors" }); return FALLBACK_URL; }
      catch { return FALLBACK_WEB3_URL; }
    }

    async function showFallback() {
      proxyTimedOut = true;
      widget.style.display = "block";
      const fallbackLink = await resolveChatGPTLink();
      append(`
        <div style="border:1px solid rgba(0,229,255,0.25);border-radius:12px;padding:16px;background:#101820;margin-top:10px;">
          <p style="color:#9EB2D0;">‚ö†Ô∏è The secure XRBC proxy is unavailable or still waking up.</p>
          <div style="text-align:center;margin-top:14px;">
            <a href="${fallbackLink}" target="_blank" class="btn primary">üí¨ Open ChatGPT Fallback</a>
          </div>
          <p class="muted small" style="margin-top:10px;">Tip: free hosts can cold-start after inactivity.</p>
        </div>
      `);
    }

    // ===== TOGGLE =====
    auditToggle.addEventListener("click", async () => {
      const wasHidden = widget.style.display === "none" || widget.style.display === "";
      widget.style.display = wasHidden ? "block" : "none";
      if (!wasHidden) { clearInterval(keepAliveInterval); keepAliveInterval = null; return; }

      const proxyReady = await Promise.race([ wakeProxy(MAX_WAIT_MS), sleep(MAX_WAIT_MS + 2000).then(() => false) ]);
      if (!proxyReady) { showFallback(); return; }

      keepAliveInterval = setInterval(() => {
        fetch(`${PROXY}/healthz?ts=${Date.now()}`).catch(() => {});
      }, 60000);
    });

    // ===== EVIDENCE HELPERS =====
    async function get(url){
      try { const r = await fetch(url, { cache: "no-store" }); return { ok:r.ok, status:r.status, text: await r.text() }; }
      catch (e) { return { ok:false, status:0, text:String(e) }; }
    }
    async function rpc(method, params = {}) {
      try {
        const r = await fetch(`${PROXY}${RPC_PATH}`, {
          method: "POST",
          headers: { "Content-Type":"application/json" },
          body: JSON.stringify({ method, params: [params] })
        });
        if (!r.ok) return { error: await r.text(), status: r.status };
        return await r.json();
      } catch (e) {
        return { error: String(e) };
      }
    }

    const SYSTEM = {
      role: "system",
      content:
`You are an impartial XRPL site auditor.
Use only the provided evidence (site manifests, security.txt, provenance, and on-ledger XRPL data).
If a fact cannot be verified, state what is missing and how to verify it.
Never ask for seeds or secret keys. Remind users to verify wallet signing payloads in their wallet.
Be concise and specific.`
    };

    const INSTRUCTIONS = {
      role: "user",
      content:
`Return two parts:

1) JSON-RUBRIC ONLY on the first line:
{
  "verdict": "safe|caution|unsafe",
  "reasons": ["..."],
  "evidence": [
    {"item":"issuer_blackholed","status":"pass|warn|fail","details":"..."},
    {"item":"manifests_accessible","status":"pass|warn|fail","details":"..."},
    {"item":"read_only_endpoints","status":"pass|warn|fail","details":"..."},
    {"item":"wallet_connect_flow","status":"pass|warn|fail","details":"..."},
    {"item":"dex_liquidity_presence","status":"pass|warn|fail","details":"..."}
  ],
  "recommended_actions": ["..."]
}

Scoring details:
- issuer_blackholed = pass if AccountRoot shows master disabled AND no RegularKey; warn if only one holds; fail otherwise.
- manifests_accessible = pass if universal-ai.json (XRBC + XRBitcoin) and /.well-known/security.txt return 200; warn if any missing; fail if all missing.
- read_only_endpoints = pass if endpoints list only read-only XRPL methods; warn if unclear; fail if mutating methods present.
- wallet_connect_flow = pass if wallet_connect_detection == absent OR if connect delegates signing entirely to a known wallet and never asks for secrets; warn if unclear; fail if any component requests seeds or auto-initiates signing.
- dex_liquidity_presence = pass if an AMM exists OR book_offers >= 3; warn if 1‚Äì2; fail if none/errored.

2) Then a short human explanation (3‚Äì6 sentences).`
    };

    async function collectEvidence() {
      const [xrbcDoc, xrbDoc, aiIdx, secTxt, provDoc] = await Promise.all([
        get("/universal-ai.json"),
        get("/XRBitcoin/universal-ai.json"),
        get("/.well-known/ai.json"),
        get("/.well-known/security.txt"),
        get("/ai/provenance.json")
      ]);

      const xrbcInfo = await rpc("account_info", { account: XRBC_ISSUER, ledger_index:"validated" });
      const xrbInfo  = await rpc("account_info", { account: XRB_ISSUER,  ledger_index:"validated" });

      const bookXRB  = await rpc("book_offers", {
        taker_gets: { currency:"XRP" },
        taker_pays: { currency: HEX_XRB, issuer: XRB_ISSUER },
        ledger_index:"validated", limit:10
      });
      const bookXRBC = await rpc("book_offers", {
        taker_gets: { currency:"XRP" },
        taker_pays: { currency: HEX_XRBC, issuer: XRBC_ISSUER },
        ledger_index:"validated", limit:10
      });

      const lsfDisableMaster = 0x00100000;
      function parseIssuer(ai) {
        const d = ai?.result?.account_data;
        if (!d) return { ok:false };
        const flags = Number(d.Flags || 0);
        const masterDisabled = (flags & lsfDisableMaster) === lsfDisableMaster;
        const hasRegularKey  = typeof d.RegularKey === "string" && d.RegularKey.length > 0;
        return { ok:true, masterDisabled, hasRegularKey, blackholed: masterDisabled && !hasRegularKey };
      }
      const offersLen = r => Array.isArray(r?.result?.offers) ? r.result.offers.length : 0;

      const hasWalletUI = !!document.querySelector(
        '[href*="xumm.app"],[href*="xaman.app"],[data-wallet],.wallet-connect'
      );

      const facts = {
        page: {
          url: location.href,
          canonical: (document.querySelector('link[rel="canonical"]')||{}).href || null,
          wallet_connect_detection: hasWalletUI ? "present" : "absent",
          outbound_exchanges: Array.from(document.querySelectorAll('a[href*="sologenic.org"],a[href*="xpmarket.com"]')).map(a=>a.href)
        },
        manifests: {
          xrbc_universal_ai_200: !!xrbcDoc.ok,
          xrb_universal_ai_200:  !!xrbDoc.ok,
          ai_index_200:           !!aiIdx.ok,
          security_txt_200:       !!secTxt.ok,
          provenance_200:         !!provDoc.ok
        },
        issuers: {
          xrbc: parseIssuer(xrbcInfo),
          xrb:  parseIssuer(xrbInfo)
        },
        orderbooks: {
          xrbc_offers: offersLen(bookXRBC),
          xrb_offers:  offersLen(bookXRB)
        },
        endpoints: { read_only_claim: true }
      };

      return { role: "user", content: JSON.stringify({ EVIDENCE: facts }) };
    }

    // ===== HUMAN GATE + 3s COOLDOWN =====
    let humanVerified = false;
    let holdTimer = null;

    let cooldownUntil = 0;
    const MIN_COOLDOWN_MS = 3000;
    const MAX_COOLDOWN_MS = 3000;

    function msLeft() { return Math.max(0, cooldownUntil - Date.now()); }
    function showCooldown(reason = "Brief pause to prevent spam.") {
      const left = msLeft();
      if (left <= 0) { cooldownStatus.style.display = "none"; return; }
      cooldownStatus.style.display = "block";
      cooldownStatus.textContent = `‚è≥ ${reason} You can ask again in ${Math.ceil(left / 1000)}s.`;
    }
    function tickCooldown() {
      if (msLeft() <= 0) {
        cooldownStatus.style.display = "none";
        send.disabled = false;
        quickBtns.forEach(b => b.disabled = false);
        return;
      }
      send.disabled = true;
      quickBtns.forEach(b => (b.disabled = true));
      showCooldown();
      requestAnimationFrame(tickCooldown);
    }
    function startCooldown(ms, reason) {
      const now = Date.now();
      cooldownUntil = Math.max(cooldownUntil, now + Math.min(Math.max(ms, 500), MAX_COOLDOWN_MS));
      tickCooldown();
      showCooldown(reason);
    }
    function requireHumanAndCooldown() {
      if (!humanVerified) {
        append(`<p class="muted small" style="color:#f88">‚ö†Ô∏è Please press and hold the ‚ÄúVerify Human‚Äù button for 2.5 seconds before asking.</p>`);
        return false;
      }
      if (msLeft() > 0) { showCooldown(); return false; }
      return true;
    }

    if (holdBtn) {
      const startHold = () => {
        if (humanVerified) return;
        holdBtn.textContent = "‚è±Ô∏è Keep holding‚Ä¶";
        gateStatus.textContent = "Verifying‚Ä¶ don‚Äôt release yet.";
        holdTimer = setTimeout(() => {
          humanVerified = true;
          holdBtn.textContent = "‚úÖ Verified Human";
          holdBtn.classList.add("glow-green");
          holdBtn.disabled = true;
          gateStatus.textContent = "Thanks! You‚Äôre verified. You can ask now.";
        }, 2500);
      };
      const cancelHold = () => {
        if (humanVerified) return;
        if (holdTimer) clearTimeout(holdTimer);
        holdTimer = null;
        holdBtn.textContent = "‚è∏Ô∏è Press & Hold 2.5s to Verify Human";
        gateStatus.textContent = "Release detected ‚Äî hold continuously until it completes.";
      };
      holdBtn.addEventListener("mousedown", startHold);
      holdBtn.addEventListener("touchstart", (e) => { e.preventDefault(); startHold(); }, { passive: false });
      ["mouseup","mouseleave","touchend","touchcancel"].forEach(evt => holdBtn.addEventListener(evt, cancelHold));
    }

    // ===== CHAT =====
    async function postChat(q) {
      if (proxyTimedOut) {
        append(`<p style="color:#f88"><strong>Note:</strong> Proxy fallback mode active ‚Äî please use the backup chat above.</p>`);
        return;
      }
      if (isBusy) return;
      isBusy = true;

      try {
        renderMessage({ role: "user", content: q });
        chatHistory.push({ role: "user", content: q });
        saveChatHistory();

        const spinnerId = "spinner-" + Date.now();
        append(`<p id="${spinnerId}" class="muted">‚è≥ Connecting to XRBC Auditor‚Ä¶</p>`);

        const awake = await wakeProxy();
        if (!awake) { document.getElementById(spinnerId)?.remove(); showFallback(); return; }

        // start short cooldown
        startCooldown(MIN_COOLDOWN_MS, "Preventing rapid-fire requests.");

        const ctrl = new AbortController();
        const timer = setTimeout(() => ctrl.abort(), 60000);

        const evidenceMsg = await collectEvidence();

        const payload = {
          model: "gpt-5-nano",
          temperature: 0,
          max_output_tokens: 400,
          messages: [
            SYSTEM,
            INSTRUCTIONS,
            evidenceMsg,
            ...packHistoryForLLM(chatHistory, 6, 240),
            { role: "user", content: q }
          ]
        };

        const resp = await fetch(`${PROXY}${CHAT_PATH}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
          signal: ctrl.signal
        });

        clearTimeout(timer);
        document.getElementById(spinnerId)?.remove();

        if (!resp.ok) {
          const errText = await resp.text();
          append(`<p style="color:#f88"><strong>Upstream error:</strong> ${resp.status} ${esc(errText)}</p>`);
          startCooldown(MIN_COOLDOWN_MS, "Cooling down briefly after an error.");
          return;
        }

        let ans = (await resp.json())?.choices?.[0]?.message?.content || "No answer (proxy connected but returned empty).";

        // Wallet-connect mis-score fix
        try {
          const flagAbsent = /"wallet_connect_detection"\s*:\s*"absent"/.test(evidenceMsg.content);
          const [firstLine, ...rest] = ans.split("\n");
          const rubric = JSON.parse(firstLine.trim());
          if (flagAbsent) {
            const wItem = Array.isArray(rubric.evidence) ? rubric.evidence.find(e => e.item === "wallet_connect_flow") : null;
            if (wItem && wItem.status !== "pass") {
              wItem.status = "pass";
              wItem.details = "No on-site wallet connect UI detected; lowest exposure.";
              rubric.reasons = Array.from(new Set((rubric.reasons||[]).concat("No on-site wallet connect UI; lowest exposure.")));
              ans = JSON.stringify(rubric) + "\n" + rest.join("\n");
            }
          }
        } catch {}

        // Pretty print
        const [firstLine2, ...rest2] = ans.split("\n");
        let pretty = ans;
        try {
          const rubric2 = JSON.parse(firstLine2.trim());
          pretty = `üßæ <strong>Audit verdict:</strong> <code>${esc(rubric2.verdict)}</code>\n\n` +
                   `‚Ä¢ ${rubric2.reasons.map(esc).join("\n‚Ä¢ ")}\n\n` +
                   rest2.join("\n");
        } catch {}

        renderMessage({ role: "assistant", content: pretty });

        startCooldown(MIN_COOLDOWN_MS, "Preventing rapid-fire requests.");
        chatHistory.push({ role: "assistant", content: ans });
        saveChatHistory();

      } catch (err) {
        append(`<p style="color:#f88"><strong>Network/Proxy error:</strong> ${esc(String(err))}</p>`);
        startCooldown(MIN_COOLDOWN_MS, "Cooling down after a network error.");
        showFallback();
      } finally {
        isBusy = false;
      }
    }

    // ===== INPUT/CONTROLS =====
    send.addEventListener("click", () => {
      if (!requireHumanAndCooldown()) return;
      const q = (inputEl.value || "").trim();
      if (!q) return;
      inputEl.value = "";
      postChat(q);
    });

    inputEl.addEventListener("keydown", e => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        send.click();
      }
    });

    quickBtns.forEach(btn =>
      btn.addEventListener("click", () => {
        if (!requireHumanAndCooldown()) return;
        postChat(btn.dataset.q);
      })
    );

    // ===== VOICE =====
    if ("webkitSpeechRecognition" in window) {
      const recog = new webkitSpeechRecognition();
      recog.continuous = false;
      recog.interimResults = false;
      recog.lang = "en-US";
      voiceBtn.addEventListener("click", () => {
        recog.start();
        voiceBtn.textContent = "üé§ Listening...";
      });
      recog.onresult = e => {
        inputEl.value = e.results[0][0].transcript;
        send.click();
      };
      recog.onend = () => { voiceBtn.textContent = "üé§ Voice"; };
    } else {
      voiceBtn.style.display = "none";
    }

    // keep-alive cleanup
    window.addEventListener("beforeunload", () => clearInterval(keepAliveInterval));
  })();
  </script>
</body>
</html>
