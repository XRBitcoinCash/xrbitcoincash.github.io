<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <!-- === META & THEME === -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>XRBitcoinCash · Wallet Connect</title>
  <meta name="description" content="Connect Xaman/Xumm wallet to XRBitcoinCash for XRPL trading and liquidity." />
  <meta name="robots" content="index, follow" />
  <meta property="og:title" content="XRBitcoinCash · Wallet Connect" />
  <meta property="og:description" content="Connect your wallet to trade XRBC on XRPL." />
  <meta property="og:type" content="website" />
  <meta name="theme-color" content="#0b1118" />

  <style>
    /* (Your existing CSS unchanged) */
    :root { --bg:#0b1118; --panel:#0f1722; --text:#e7eef8; --brand:#a7ff83; --ink:#e7eef8; --accent:#a7ff83; }
    body{ margin:0; font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Inter,Roboto,Arial; color:var(--text); background:var(--bg); }
    header.appbar{ padding:14px 18px; background:linear-gradient(180deg, rgba(11,17,24,0.92), rgba(11,17,24,0.6)); display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid rgba(167,255,131,0.15); }
    .btn{ border:1px solid rgba(167,255,131,0.25); background:linear-gradient(180deg,var(--panel), #121c2a); color:var(--text); font-weight:700; padding:10px 14px; border-radius:12px; cursor:pointer; }
    .btn:hover{ border-color:var(--brand); } #walletAddress{ margin-left:1rem; font-family:ui-monospace,SFMono-Regular,Menlo,monospace; }
    @keyframes glowPulse { from { box-shadow: 0 0 4px var(--accent); } to { box-shadow: 0 0 14px var(--accent); } }

    :root { --xrbc-bg:#0f1722; --xrbc-panel:#121827; --xrbc-text:#e7eef8; --xrbc-accent:#7ef09a; --xrbc-danger:#ff6b6b; --xrbc-muted:#98a2b3; }
    #xrbc-dex-container{ max-width:1024px; margin:28px auto; padding:18px; background:linear-gradient(180deg,var(--xrbc-panel), #0b1320); border-radius:14px; color:var(--xrbc-text); font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial; box-shadow:0 8px 30px rgba(3,8,14,0.6); border:1px solid rgba(126,240,154,0.06); }
    #xrbc-dex-header{ display:flex; justify-content:space-between; align-items:center; gap:12px; } #xrbc-dex-header h2{ margin:0; color:var(--xrbc-accent); font-size:1.05rem; }
    #xrbc-dex-grid{ display:grid; grid-template-columns: 1fr 340px; gap:18px; margin-top:14px; }
    #xrbc-orderbook-card, #xrbc-metrics-card, #xrbc-order-form-card{ background:linear-gradient(180deg,#0b1220, #0f1726); border-radius:10px; padding:12px; border:1px solid rgba(255,255,255,0.05); }
    #xrbc-orderbook{ height:360px; overflow:auto; font-size:0.92rem; color:var(--xrbc-text); border-radius:8px; }
    .xrbc-row{ display:flex; justify-content:space-between; padding:6px 8px; align-items:center; border-bottom:1px dashed rgba(255,255,255,0.06); }
    .xrbc-bid{ color:#2ecc71; } .xrbc-ask{ color:#ff6b6b; }
    #xrbc-order-form { display:flex; flex-direction:column; gap:10px; } #xrbc-order-form input, #xrbc-order-form select{ padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.08); background:transparent; color:var(--xrbc-text); width:100%; }
    .xrbc-btn{ padding:10px 12px; border-radius:10px; border:none; cursor:pointer; font-weight:700; } .xrbc-btn-primary{ background:linear-gradient(180deg,#2b7fff,#1f4fd6); color:white; } .xrbc-btn-ghost{ background:transparent; border:1px solid rgba(255,255,255,0.12); color:var(--xrbc-text); }
    #xrbc-status{ font-size:0.92rem; color:var(--xrbc-muted); } .xrbc-small{ font-size:0.86rem; color:var(--xrbc-muted); }
    @media (max-width:920px){ #xrbc-dex-grid{ grid-template-columns:1fr; } }
  </style>
</head>
<body>

<header class="appbar">
  <div class="brand"><strong>XRBitcoinCash</strong> · Wallet Connect</div>
  <div class="actions">
    <button id="connectWalletButton" type="button" class="btn">Connect Wallet</button>
    <span id="walletAddress">Status: Not connected</span>
  </div>
</header>

<header style="display:flex; align-items:center; padding:12px 18px; gap:12px;">
  <a href="/index.html" style="display:flex; align-items:center; text-decoration:none;">
    <img src="/xrbc-nft.png" alt="XRBC Home" style="width:44px; height:44px; border-radius:8px; animation: glowPulse 2.5s infinite alternate;" />
    <span style="margin-left:12px; font-weight:600; color:var(--ink);">Home</span>
  </a>
  <button id="xrpl-node-btn" class="btn" style="margin-left:auto; background:#3a1f1f; border-color:#6d2b2b;">XRPL Node: Disconnected</button>
</header>

<main style="padding:20px;">
  <div id="xrbc-dex-container" aria-live="polite" role="region" aria-label="XRBC DEX module">
    <div id="xrbc-dex-header">
      <h2>XRBC DEX — Live orderbook & metrics</h2>
      <div id="xrbc-header-actions" class="xrbc-small">
        <span id="xrbc-wallet-view">Wallet: <em id="xrbc-wallet-addr">Not connected</em></span>
        <button id="xrbc-refresh-btn" class="xrbc-btn xrbc-btn-ghost" title="Refresh market data">Refresh</button>
      </div>
    </div>

    <div id="xrbc-dex-grid">
      <div>
        <div id="xrbc-orderbook-card">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px; gap:12px;">
            <div>
              <label for="xrbc-pair-select" class="xrbc-small">Pair</label>
              <select id="xrbc-pair-select" style="margin-left:8px;padding:6px;border-radius:8px;">
                <option value="XRBC/XRP">XRBC / XRP</option>
              </select>
            </div>
            <div class="xrbc-small">Top 20 levels</div>
          </div>
          <div id="xrbc-orderbook">
            <div class="xrbc-row"><strong>Side</strong><strong>Price (XRP)</strong><strong>Amount (XRBC)</strong></div>
            <div class="xrbc-row"><em class="xrbc-small">Load an orderbook to view levels</em></div>
          </div>
        </div>

        <div id="xrbc-metrics-card" style="margin-top:12px;">
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <strong>Quick metrics</strong>
            <span class="xrbc-small">Snapshot</span>
          </div>
          <div style="display:flex;gap:12px;margin-top:10px;flex-wrap:wrap;">
            <div><div class="xrbc-small">Spread</div><div id="xrbc-metric-spread">—</div></div>
            <div><div class="xrbc-small">Best Bid</div><div id="xrbc-metric-bestbid">—</div></div>
            <div><div class="xrbc-small">Best Ask</div><div id="xrbc-metric-bestask">—</div></div>
            <div><div class="xrbc-small">Top Depth (bid/ask)</div><div id="xrbc-metric-depth">—</div></div>
            <div style="width:100%;margin-top:8px;">
              <label class="xrbc-small">Simulate slippage for amount (XRBC)</label>
              <input id="xrbc-sim-amount" type="number" step="0.000001" min="0" placeholder="e.g., 10" style="width:160px;">
              <div class="xrbc-small" style="margin-top:6px;">Estimated slippage: <strong id="xrbc-sim-result">—</strong></div>
            </div>
          </div>
        </div>
      </div>

      <aside>
        <div id="xrbc-order-form-card">
          <div style="display:flex; gap:8px; margin-bottom:8px;">
            <button id="tab-market" class="xrbc-btn xrbc-btn-primary" aria-pressed="true">Market</button>
            <button id="tab-limit"  class="xrbc-btn xrbc-btn-ghost" aria-pressed="false">Limit</button>
          </div>
          <div id="xrbc-order-form">
            <div>
              <label class="xrbc-small" for="xrbc-order-side">Side</label>
              <select id="xrbc-order-side">
                <option value="buy">Buy XRBC (spend XRP)</option>
                <option value="sell">Sell XRBC (receive XRP)</option>
              </select>
            </div>
            <div>
              <label class="xrbc-small" for="xrbc-order-amount">Amount (XRBC)</label>
              <input id="xrbc-order-amount" type="number" step="0.000001" min="0">
            </div>
            <div id="limit-price-row" style="display:none;">
              <label class="xrbc-small" for="xrbc-order-price">Limit price (XRP per XRBC)</label>
              <input id="xrbc-order-price" type="number" step="0.000001" min="0" placeholder="e.g., 0.50">
            </div>
            <div style="display:flex;gap:8px; flex-wrap:wrap;">
              <button id="xrbc-submit-order" class="xrbc-btn xrbc-btn-primary">Create Offer (Local Vault/Xumm)</button>
              <button id="xrbc-simulate-btn" class="xrbc-btn xrbc-btn-ghost">Simulate</button>
            </div>
            <div id="xrbc-order-feedback" class="xrbc-small" style="margin-top:8px;color:var(--xrbc-muted);">Status: idle</div>
            <div id="xrbc-status" class="xrbc-small" style="margin-top:10px;">Node: <span id="xrbc-node-status">disconnected</span></div>
          </div>
        </div>
      </aside>
    </div>
  </div>
</main>

<!-- === CONFIG PLACEHOLDER === -->
<script type="application/json" id="app-config">
{
  "xummApiKey": "2abde023-0df1-49a2-a4dc-86d776f6318d",
  "rpcEndpoint": "wss://s1.ripple.com",
  "assetCode": "XRbitcoincash",
  "issuer": "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw",
  "localAgent": {
    "wss": "wss://localhost:8443",
    "ws": "ws://localhost:3001"
  }
}
</script>

<!-- === LIBRARIES === -->
<script src="https://xaman.app/assets/cdn/xumm.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xrpl@2.2.0/dist/npm/xrpl.min.js"></script>

<!-- === WALLET & DEX: LOCAL-AGENT SUPPORT ADDED === -->
<script>
(function(){
  'use strict';
  const cfg = JSON.parse(document.getElementById('app-config').textContent||'{}');
  // Keep original Xumm init
  const xumm = new Xumm(cfg.xummApiKey);

  // DOM references (kept from your original file)
  const btn = document.getElementById('connectWalletButton');
  const statusEl = document.getElementById('walletAddress');
  const walletAddrEl = document.getElementById('xrbc-wallet-addr');
  const xrplNodeBtn   = document.getElementById('xrpl-node-btn');
  const nodeStatusEl  = document.getElementById('xrbc-node-status');
  const orderbookEl   = document.getElementById('xrbc-orderbook');
  const spreadEl      = document.getElementById('xrbc-metric-spread');
  const bestBidEl     = document.getElementById('xrbc-metric-bestbid');
  const bestAskEl     = document.getElementById('xrbc-metric-bestask');
  const depthEl       = document.getElementById('xrbc-metric-depth');
  const simAmountEl   = document.getElementById('xrbc-sim-amount');
  const simResultEl   = document.getElementById('xrbc-sim-result');
  const refreshBtn    = document.getElementById('xrbc-refresh-btn');
  const submitBtn     = document.getElementById('xrbc-submit-order');
  const simulateBtn   = document.getElementById('xrbc-simulate-btn');
  const orderSideEl   = document.getElementById('xrbc-order-side');
  const orderAmountEl = document.getElementById('xrbc-order-amount');
  const orderPriceEl  = document.getElementById('xrbc-order-price');
  const orderFeedbackEl = document.getElementById('xrbc-order-feedback');
  const tabMarket     = document.getElementById('tab-market');
  const tabLimit      = document.getElementById('tab-limit');
  const limitPriceRow = document.getElementById('limit-price-row');

  // App constants
  const XRBC_CODE  = cfg.assetCode || 'XRbitcoincash';
  const XRBC_ISSUER= cfg.issuer || 'rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw';
  const DEFAULT_WSS = cfg.rpcEndpoint || 'wss://s1.ripple.com';
  const LOCAL_WSS = (cfg.localAgent && cfg.localAgent.wss) || 'wss://localhost:8443';
  const LOCAL_WS  = (cfg.localAgent && cfg.localAgent.ws)  || 'ws://localhost:3001';
  const MAX_LEVELS = 20;

  // state
  let xrplClient = null;           // xrpl.Client instance when using public node fallback
  let localSocket = null;          // WebSocket to local agent when in use
  let lastOrderbook = [];
  let usingLocalAgent = false;

  // UI helpers
  function updateNodeButton(connected, label){
    if(!xrplNodeBtn) return;
    xrplNodeBtn.style.background = connected? '#1f3a2a' : '#3a1f1f';
    xrplNodeBtn.style.borderColor= connected? '#2e7d32' : '#6d2b2b';
    xrplNodeBtn.textContent = label || (connected? 'XRPL Node: Connected' : 'XRPL Node: Disconnected');
    if(nodeStatusEl) nodeStatusEl.textContent = connected? 'connected' : 'disconnected';
  }

  // Xumm SDK initial wiring (unchanged)
  function setBtn(state){
    if(state==='connect'){ btn.textContent='Connect Wallet'; btn.disabled=false; }
    if(state==='disconnect'){ btn.textContent='Disconnect'; btn.disabled=false; }
    if(state==='busy'){ btn.disabled=true; }
  }
  xumm.on('ready', ()=>{ console.log('Xumm SDK ready'); setBtn('connect'); });

  async function disconnectWallet(){
    try {
      await xumm.logout();
      statusEl.textContent = '✅ Your wallet has disconnected safely.';
      setBtn('connect');
      if (walletAddrEl) walletAddrEl.textContent = 'Not connected';
      window.__xrbcState.userAccount = null;
    } catch (err) {
      console.error('Error disconnecting wallet:', err);
      statusEl.textContent = '⚠ Could not disconnect — see console for details.';
    }
  }
  btn.addEventListener('click', async ()=>{
    if (btn.textContent.trim() === 'Disconnect') return disconnectWallet();
    statusEl.textContent = 'Connecting...';
    setBtn('busy');
    try {
      const auth = await xumm.authorize(); // QR/deep link
      const account = await xumm.user.account;
      statusEl.textContent = 'Connected: ' + account;
      if (walletAddrEl) walletAddrEl.textContent = account;
      window.__xrbcState.userAccount = account;
      setBtn('disconnect');
    } catch (err) {
      console.error(err);
      statusEl.textContent = 'Status: Not connected';
      setBtn('connect');
    }
  });

  // Expose for debugging
  window.__xrbcState = window.__xrbcState || {};
  window.__xrbcState.xumm = xumm;

  /************************************************************************
   Local-wallet / Local-agent protocol (browser <> local agent)
   ------------------------------------------------------------------------
   The local-agent (a process you run on your machine) speaks a tiny JSON
   WebSocket protocol:

   Client -> Agent (examples)
   { type: 'subscribe_book', pair: { base:{currency:'XRBC', issuer:'r....'}, quote:{currency:'XRP'} }, limit: 20 }
   { type: 'get_server_info' }
   { type: 'sign_tx', tx: { TransactionType:'OfferCreate', ... } }

   Agent -> Client
   { type: 'book_snapshot', offers: [...] }         // response to subscribe_book (initial)
   { type: 'book_update', offers: [...] }           // incremental or replacements
   { type: 'ledger_close', ledger_index: 12345, txn_count: 3 }
   { type: 'signed', result: { signed:true, txid:'...' } } // response to sign_tx
   { type: 'error', message: '...' }
   ************************************************************************/

  // Try to connect to local agent (secure first)
  function tryLocalAgent() {
    return new Promise((resolve) => {
      // prefer secure local wss (only works for https pages)
      const pageIsSecure = location.protocol === 'https:';
      const tryUrls = pageIsSecure ? [LOCAL_WSS, LOCAL_WS] : [LOCAL_WS, LOCAL_WSS];

      let connected = false;
      let socket = null;
      let tries = 0;

      function tryUrl() {
        if(connected || tries >= tryUrls.length) return resolve(null);
        const url = tryUrls[tries++];
        try {
          socket = new WebSocket(url);
        } catch (e) {
          console.warn('Local agent WS open error', e);
          setTimeout(tryUrl, 150);
          return;
        }

        socket.onopen = () => {
          connected = true;
          usingLocalAgent = true;
          localSocket = socket;
          console.log('Connected to local agent at', url);
          updateNodeButton(true, 'Local Vault: Connected');
          attachLocalHandlers(socket);
          resolve(socket);
        };
        socket.onerror = (ev) => {
          console.warn('Local agent connection error to', url, ev);
          socket.close?.();
          setTimeout(tryUrl, 150);
        };
        socket.onclose = () => {
          if(!connected) { /* try next url */ setTimeout(tryUrl, 150); }
        };
      }
      tryUrl();
      // timeout fallback in 1s -> resolve(null)
      setTimeout(()=>{ if(!connected) resolve(null); }, 1200);
    });
  }

  function attachLocalHandlers(socket){
    socket.onmessage = (evt)=>{
      try {
        const data = JSON.parse(evt.data);
        if(!data.type) return;
        switch(data.type){
          case 'book_snapshot':
            lastOrderbook = data.offers || [];
            renderOrderbook(lastOrderbook);
            computeMetrics(lastOrderbook);
            break;
          case 'book_update':
            lastOrderbook = data.offers || lastOrderbook;
            renderOrderbook(lastOrderbook);
            computeMetrics(lastOrderbook);
            break;
          case 'ledger_close':
            // optionally show ledger info
            console.log('ledger_close', data);
            break;
          case 'signed':
            if(data.result && data.result.signed===true){
              orderFeedbackEl.textContent = 'Order signed by local vault. TxID: ' + (data.result.txid || 'unknown');
              // Suggest refreshing
              loadOrderbook();
            } else {
              orderFeedbackEl.textContent = 'Local vault rejection or failure.';
            }
            break;
          case 'error':
            console.error('Local agent error:', data.message);
            break;
          default:
            console.log('Local agent message', data);
        }
      } catch(err){
        console.error('Invalid local agent message', err);
      }
    };
    socket.onclose = ()=> {
      console.warn('Local agent disconnected');
      usingLocalAgent = false;
      localSocket = null;
      updateNodeButton(false);
      // fallback: connect to public rippled for reads
      connectXRPL().then(()=>loadOrderbook());
    };
  }

  // If local agent is present, ask it to subscribe to the pair
  function subscribeLocalBook(){
    if(!localSocket || localSocket.readyState !== WebSocket.OPEN) return;
    const payload = {
      type: 'subscribe_book',
      pair: {
        base: { currency: XRBC_CODE, issuer: XRBC_ISSUER },
        quote: { currency: 'XRP' }
      },
      limit: MAX_LEVELS
    };
    try { localSocket.send(JSON.stringify(payload)); } catch(e){ console.error('send failed', e); }
  }

  // Local-agent signing helper (sends a sign request to local vault)
  async function signWithLocalVault(txjson){
    if(!localSocket || localSocket.readyState !== WebSocket.OPEN){ orderFeedbackEl.textContent = 'Local vault not connected.'; return null; }
    return new Promise((resolve) => {
      const id = 'id_' + Date.now() + '_' + Math.floor(Math.random()*9999);
      const handler = (evt) => {
        try {
          const d = JSON.parse(evt.data);
          if(d.type==='signed' && d.id === id){
            localSocket.removeEventListener('message', handler);
            resolve(d.result);
          }
        } catch(e){}
      };
      localSocket.addEventListener('message', handler);
      const payload = { type:'sign_tx', id, tx: txjson };
      try { localSocket.send(JSON.stringify(payload)); } catch(e){ resolve(null); }
      // timeout 45s
      setTimeout(()=>{ localSocket.removeEventListener('message', handler); resolve(null); }, 45000);
    });
  }

  /************************************************************************
   XRPL fallback (public rippled) for read-only market data
   ************************************************************************/
  async function connectXRPL(){
    try {
      if(window.xrplClient && window.xrplClient.isConnected()){
        updateNodeButton(true, 'Public Node: Connected');
        return window.xrplClient;
      }
      // create a new client
      xrplClient = new xrpl.Client(DEFAULT_WSS);
      await xrplClient.connect();
      window.xrplClient = xrplClient;
      updateNodeButton(true, 'Public Node: Connected');
      console.log('✅ XRPL connected:', DEFAULT_WSS);
      return xrplClient;
    } catch(err){
      console.error('XRPL connection failed:', err);
      updateNodeButton(false);
      return null;
    }
  }

  // Load orderbook via public node
  async function loadOrderbook(){
    if(!orderbookEl) return;
    orderbookEl.innerHTML = "<div class='xrbc-row'><em>Loading orderbook…</em></div>";

    // If local agent is connected, ask it to subscribe (it will send snapshot)
    if(usingLocalAgent && localSocket){
      subscribeLocalBook();
      return;
    }

    // otherwise fallback to public node
    if(!xrplClient || !xrplClient.isConnected()){
      await connectXRPL();
      if(!xrplClient || !xrplClient.isConnected()){
        orderbookEl.innerHTML = "<div class='xrbc-row' style='color:var(--xrbc-danger)'>XRPL node not connected.</div>";
        return;
      }
    }

    const req = {
      command: 'book_offers',
      taker_gets: { currency: XRBC_CODE, issuer: XRBC_ISSUER },
      taker_pays: { currency: 'XRP' },
      limit: MAX_LEVELS
    };
    try {
      const res = await xrplClient.request(req);
      const offers = res.result?.offers || [];
      lastOrderbook = offers;
      renderOrderbook(offers);
      computeMetrics(offers);
    } catch(err){
      console.error('book_offers error:', err);
      orderbookEl.innerHTML = `<div class='xrbc-row' style='color:var(--xrbc-danger)'>Orderbook error: ${err.message||err}</div>`;
    }
  }

  // helper conversion fns
  function dropsToXrp(d){ return Number(d)/1_000_000; }
  function xrpToDrops(x){ return String(Math.round(Number(x)*1_000_000)); }

  // render & metrics same as your original code (kept)
  function renderOrderbook(offers){
    if(!offers || !offers.length){ orderbookEl.innerHTML = "<div class='xrbc-row'><em>No offers found</em></div>"; return; }
    const container = document.createElement('div');
    const head = document.createElement('div'); head.className='xrbc-row';
    head.innerHTML = "<strong>Side</strong><strong>Price (XRP)</strong><strong>Amount (XRBC)</strong>";
    container.appendChild(head);
    offers.forEach(o=>{
      const price = o.quality ? Number(o.quality) : null;
      let amount = '—';
      if (o.TakerGets && typeof o.TakerGets === 'object' && o.TakerGets.value) amount = parseFloat(o.TakerGets.value);
      else if (o.TakerGets && !isNaN(o.TakerGets)) amount = dropsToXrp(o.TakerGets);
      let side = 'Buy';
      if (o.TakerGets && typeof o.TakerGets === 'object' && o.TakerGets.currency === XRBC_CODE) side = 'Sell';
      const row = document.createElement('div'); row.className='xrbc-row';
      row.innerHTML = `<div class='${side==='Buy'?'xrbc-bid':'xrbc-ask'}'>${side}</div><div>${price? price.toFixed(6): '—'}</div><div>${amount}</div>`;
      container.appendChild(row);
    });
    orderbookEl.innerHTML = '';
    orderbookEl.appendChild(container);
  }

  function computeMetrics(offers){
    const asks=[], bids=[];
    (offers||[]).forEach(o=>{
      const price = o.quality ? Number(o.quality) : null;
      let amount = 0;
      if (o.TakerGets && typeof o.TakerGets === 'object' && o.TakerGets.value) amount = Number(o.TakerGets.value);
      else if (o.TakerGets) amount = dropsToXrp(o.TakerGets);
      if (o.TakerGets && typeof o.TakerGets === 'object' && o.TakerGets.currency === XRBC_CODE) asks.push({price, amount}); else bids.push({price, amount});
    });
    asks.sort((a,b)=>a.price-b.price);
    bids.sort((a,b)=>b.price-a.price);
    const bestAsk=asks[0]?.price ?? null;
    const bestBid=bids[0]?.price ?? null;
    bestAskEl.textContent = bestAsk? bestAsk.toFixed(6): '—';
    bestBidEl.textContent = bestBid? bestBid.toFixed(6): '—';
    spreadEl.textContent = (bestAsk!=null && bestBid!=null)? (bestAsk-bestBid).toFixed(6): '—';
    const topBids=bids.slice(0,5).reduce((s,x)=>s+(x.amount||0),0);
    const topAsks=asks.slice(0,5).reduce((s,x)=>s+(x.amount||0),0);
    depthEl.textContent = `${topBids.toFixed(6)} / ${topAsks.toFixed(6)}`;
  }

  // slippage simulator (kept)
  function simulateSlippage(side, amountXRBC){
    if(!lastOrderbook || !lastOrderbook.length) return 'No orderbook';
    const asks=[], bids=[];
    lastOrderbook.forEach(o=>{
      const price = o.quality ? Number(o.quality) : null;
      let amount = 0;
      if (o.TakerGets && typeof o.TakerGets === 'object' && o.TakerGets.value) amount = Number(o.TakerGets.value);
      else if (o.TakerGets) amount = dropsToXrp(o.TakerGets);
      if (o.TakerGets && typeof o.TakerGets === 'object' && o.TakerGets.currency === XRBC_CODE) asks.push({price, amount}); else bids.push({price, amount});
    });
    asks.sort((a,b)=>a.price-b.price);
    bids.sort((a,b)=>b.price-a.price);
    const levels = side==='buy'? asks : bids;
    let remaining = Number(amountXRBC); if(remaining<=0) return 'Enter a positive amount';
    let filledValue=0;
    for(const lvl of levels){
      if(remaining<=0) break;
      const take=Math.min(remaining, lvl.amount||0);
      if(!take || !lvl.price) continue;
      filledValue += take * lvl.price;
      remaining -= take;
    }
    if(remaining>0) return 'Insufficient depth';
    const avgPrice = filledValue/Number(amountXRBC);
    const bestPrice = (side==='buy'? (asks[0]?.price) : (bids[0]?.price)) || avgPrice;
    const slipPct = ((avgPrice-bestPrice)/bestPrice)*100;
    return `Avg ${avgPrice.toFixed(6)} XRP — slippage ${slipPct.toFixed(4)}%`;
  }

  // Offer creation: now tries local vault first, then Xumm as fallback
  async function createOffer(side, amount, priceOrNull, type){
    const xummInstance = window.__xrbcState?.xumm || xumm;
    let userAccount = window.__xrbcState?.userAccount || null;
    orderFeedbackEl.textContent = 'Preparing offer…';

    if(!userAccount){
      try { userAccount = await xummInstance.user.account; window.__xrbcState.userAccount = userAccount; } catch(e){}
    }
    if(!userAccount){ orderFeedbackEl.textContent='Wallet not connected.'; return; }

    // Determine price for market orders from best levels
    let usePrice = priceOrNull;
    if(type==='market'){
      const best = (side==='buy')? bestAskEl.textContent : bestBidEl.textContent;
      if(!best || best==='—'){ orderFeedbackEl.textContent='No liquidity for market order.'; return; }
      usePrice = Number(best);
    }
    if(!usePrice || usePrice<=0){ orderFeedbackEl.textContent='Enter a valid price.'; return; }

    // Build fields
    let TakerGets, TakerPays, Flags = 0;
    const totalXrp = Number(usePrice) * Number(amount);
    if(side==='buy'){
      TakerGets = xrpToDrops(totalXrp);
      TakerPays = { currency: XRBC_CODE, issuer: XRBC_ISSUER, value: Number(amount).toFixed(6) };
    } else {
      TakerGets = { currency: XRBC_CODE, issuer: XRBC_ISSUER, value: Number(amount).toFixed(6) };
      TakerPays = xrpToDrops(totalXrp);
      Flags |= 0x00080000; // tfSell
    }
    if(type==='market') Flags |= 0x00020000; // tfImmediateOrCancel

    const tx = { TransactionType:'OfferCreate', Account:userAccount, TakerGets, TakerPays, Flags };

    // First, try local vault signing if present
    if(usingLocalAgent && localSocket){
      orderFeedbackEl.textContent = 'Sending sign request to local vault…';
      try {
        const res = await signWithLocalVault(tx);
        if(res && res.signed===true){
          orderFeedbackEl.textContent = 'Signed by local vault. TxID: ' + (res.txid || 'unknown');
          return;
        } else {
          orderFeedbackEl.textContent = 'Local vault rejected or timed out; falling back to Xumm.';
        }
      } catch(err){
        console.error('Local vault sign error', err);
        orderFeedbackEl.textContent = 'Local vault error; falling back to Xumm.';
      }
    }

    // Fallback to Xumm payload
    try {
      orderFeedbackEl.textContent = 'Sending sign request to Xumm…';
      if(xumm.payload?.createAndSubscribe){
        const sub = await xumm.payload.createAndSubscribe({ txjson: tx }, (evt)=>{
          if(!evt?.data) return;
          if(evt.data.signed===true){ orderFeedbackEl.textContent='Order signed (Xumm) and placed.'; return true; }
          if(evt.data.signed===false){ orderFeedbackEl.textContent='Signature rejected.'; return false; }
        });
        const deeplink = sub?.created?.next?.alternative_url;
        if(deeplink){ const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent); if(isMobile) window.location.href = deeplink; else orderFeedbackEl.innerHTML = `Open Xumm to sign: <a target="_blank" rel="noopener" href="${deeplink}">Open Xumm</a>`; }
      } else if (xumm.payload?.create){
        const created = await xumm.payload.create({ txjson: tx });
        const deeplink = created?.next?.alternative_url;
        if(deeplink){ const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent); if(isMobile) window.location.href = deeplink; else orderFeedbackEl.innerHTML = `Open Xumm to sign: <a target="_blank" rel="noopener" href="${deeplink}">Open Xumm</a>`; }
        else { orderFeedbackEl.textContent='Payload created; follow Xumm flow.'; }
      } else {
        orderFeedbackEl.textContent='Xumm payload API unavailable.';
      }
    } catch(err){
      console.error('Xumm payload error', err);
      orderFeedbackEl.textContent = `Error creating payload: ${err.message||err}`;
    }
  }

  // UI event bindings
  if(refreshBtn) refreshBtn.addEventListener('click', loadOrderbook);
  if(simulateBtn) simulateBtn.addEventListener('click', ()=>{
    const amt = Number(orderAmountEl.value || simAmountEl.value || 0);
    if(!amt || amt<=0){ orderFeedbackEl.textContent='Enter an amount to simulate.'; return; }
    const side = orderSideEl.value;
    const res = simulateSlippage(side, amt);
    simResultEl.textContent = (typeof res==='string')? res : JSON.stringify(res);
    orderFeedbackEl.textContent = 'Simulation complete';
  });
  if(submitBtn) submitBtn.addEventListener('click', async ()=>{
    const side = orderSideEl.value;
    const amount = Number(orderAmountEl.value);
    const type = tabMarket.getAttribute('aria-pressed')==='true'? 'market' : 'limit';
    const price = type==='limit'? Number(orderPriceEl.value) : null;
    if(!amount || amount<=0){ orderFeedbackEl.textContent='Enter a valid amount.'; return; }
    await createOffer(side, amount, price, type);
  });

  function activateTab(which){
    if(which==='market'){
      tabMarket.className='xrbc-btn xrbc-btn-primary'; tabMarket.setAttribute('aria-pressed','true');
      tabLimit.className='xrbc-btn xrbc-btn-ghost';  tabLimit.setAttribute('aria-pressed','false');
      limitPriceRow.style.display='none';
    } else {
      tabMarket.className='xrbc-btn xrbc-btn-ghost'; tabMarket.setAttribute('aria-pressed','false');
      tabLimit.className='xrbc-btn xrbc-btn-primary'; tabLimit.setAttribute('aria-pressed','true');
      limitPriceRow.style.display='block';
    }
  }
  tabMarket?.addEventListener('click', ()=>activateTab('market'));
  tabLimit?.addEventListener('click', ()=>activateTab('limit'));

  // Initialization: try local agent first, then fallback to public node
  window.addEventListener('DOMContentLoaded', async () => {
    activateTab('market');
    orderFeedbackEl.textContent = 'Initializing market data…';
    const local = await tryLocalAgent();
    if(local){
      // local agent will push snapshot if subscribed
      subscribeLocalBook();
    } else {
      // fallback to public rippled
      await connectXRPL();
      await loadOrderbook();
    }
  });

  // quick debug API
  window.__xrbcDex = { loadOrderbook, simulateSlippage: (side, amt)=>simulateSlippage(side, amt), lastOrderbook: ()=>lastOrderbook, usingLocalAgent: ()=>usingLocalAgent };
})();
</script>

<!-- === NOTES / links (visible in page for convenience) === -->
<script>
console.info('XRBC DEX loaded. local agent preference:', JSON.parse(document.getElementById('app-config').textContent||'{}').localAgent);
console.info('Local-agent protocol: subscribe_book, book_snapshot, book_update, ledger_close, sign_tx, signed');
</script>

</body>
</html>
