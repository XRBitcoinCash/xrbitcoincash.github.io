<!DOCTYPE html>
<html lang="no" data-theme="dark">
<head>

  
<meta http-equiv="Content-Security-Policy" 
      content="default-src 'self'; 
               script-src 'self' https://xumm.app https://xaman.app https://unpkg.com 'unsafe-inline'; 
               connect-src 'self' https://xumm.app https://xaman.app wss://s1.ripple.com wss://s2.ripple.com; 
               style-src 'self' 'unsafe-inline'; 
               img-src 'self' data: https://xumm.app https://xaman.app; 
               frame-src https://xumm.app https://xaman.app;">

  
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>XRBitcoinCash · Wallet Connect</title>
  <meta name="description" content="Connect Xaman/Xumm wallet to XRBitcoinCash for XRPL trading and liquidity." />
  <meta name="robots" content="index, follow" />
  <meta property="og:title" content="XRBitcoinCash · Wallet Connect" />
  <meta property="og:description" content="Connect your wallet to trade XRBC on XRPL." />
  <meta property="og:type" content="website" />
  <meta name="theme-color" content="#0b1118" />
  <style>
    :root {
      --bg: #0b1118;
      --panel: #0f1722;
      --text: #e7eef8;
      --brand: #a7ff83;
    }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Inter, Roboto, Arial;
      color: var(--text);
      background: var(--bg);
    }
    header.appbar {
      padding: 14px 18px;
      background: linear-gradient(180deg, rgba(11,17,24,0.92), rgba(11,17,24,0.6));
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(167,255,131,0.15);
    }
    .btn {
      border: 1px solid rgba(167,255,131,0.25);
      background: linear-gradient(180deg, var(--panel), #121c2a);
      color: var(--text);
      font-weight: 700;
      padding: 10px 14px;
      border-radius: 12px;
      cursor: pointer;
    }
    .btn:hover {
      border-color: var(--brand);
    }
    #walletAddress {
      margin-left: 1rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
    }
    @keyframes glowPulse {
      from { box-shadow: 0 0 4px var(--accent); }
      to { box-shadow: 0 0 14px var(--accent); }
    }
    /* DEX styles */
    :root {
      --xrbc-bg: #0f1722;
      --xrbc-panel: #121827;
      --xrbc-text: #e7eef8;
      --xrbc-accent: #7ef09a;
      --xrbc-danger: #ff6b6b;
      --xrbc-muted: #98a2b3;
    }
    #xrbc-dex-container {
      max-width:900px;
      margin:28px auto;
      padding:18px;
      background: linear-gradient(180deg,var(--xrbc-panel), #0b1320);
      border-radius:14px;
      color:var(--xrbc-text);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      box-shadow: 0 8px 30px rgba(3,8,14,0.6);
      border: 1px solid rgba(126,240,154,0.06);
    }
    #xrbc-dex-header { display:flex; justify-content:space-between; align-items:center; gap:12px; }
    #xrbc-dex-header h2 { margin:0; color:var(--xrbc-accent); font-size:1.05rem; }
    #xrbc-dex-grid { display:grid; grid-template-columns: 1fr 320px; gap:18px; margin-top:14px; }
    #xrbc-orderbook-card, #xrbc-metrics-card { background: linear-gradient(180deg,#0b1220, #0f1726); border-radius:10px; padding:12px; border:1px solid rgba(255,255,255,0.03); }
    #xrbc-orderbook { height:320px; overflow:auto; font-size:0.92rem; color:var(--xrbc-text); }
    .xrbc-row { display:flex; justify-content:space-between; padding:6px 8px; align-items:center; border-bottom:1px dashed rgba(255,255,255,0.01); }
    .xrbc-bid { color:#2ecc71; }
    .xrbc-ask { color:#ff6b6b; }
    #xrbc-order-form { background:transparent; display:flex; flex-direction:column; gap:10px; }
    #xrbc-order-form input, #xrbc-order-form select { padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:var(--xrbc-text); }
    .xrbc-btn { padding:10px 12px; border-radius:10px; border:none; cursor:pointer; font-weight:700; }
    .xrbc-btn-primary { background:linear-gradient(180deg,#2b7fff,#1f4fd6); color:white; }
    .xrbc-btn-ghost { background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--xrbc-text); }
    #xrbc-status { font-size:0.92rem; color:var(--xrbc-muted); }
    .xrbc-small { font-size:0.86rem; color:var(--xrbc-muted); }
    @media (max-width:880px) { #xrbc-dex-grid { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <header class="appbar">
    <div class="brand">
      <strong>XRBitcoinCash</strong> · Wallet Connect
    </div>
    <div class="actions">
      <button id="connectWalletButton" type="button" class="btn" disabled>Connect Wallet</button>
      <span id="walletAddress">Status: Ikke koblet</span>
    </div>
  </header>

  <header style="display: flex; align-items: center; padding: 12px 18px;">
    <a href="/index.html" style="display: flex; align-items: center; text-decoration: none;">
      <img src="/xrbc-nft.png" alt="XRBC Home" style="width: 44px; height: 44px; border-radius: 8px; animation: glowPulse 2.5s infinite alternate;" />
      <span style="margin-left: 12px; font-weight: 600; color: var(--ink);">Home</span>
    </a>
  </header>

  <main style="padding:20px;">
    <div id="xrbc-dex-root">
      <div id="xrbc-dex-container" aria-live="polite" role="region" aria-label="XRBC DEX module">
        <div id="xrbc-dex-header">
          <h2>XRBC DEX — Live orderbook & markets</h2>
          <div id="xrbc-header-actions" class="xrbc-small">
            <span id="xrbc-wallet-view">Wallet: <em id="xrbc-wallet-addr">Ikke koblet</em></span>
            <button id="xrbc-refresh-btn" class="xrbc-btn xrbc-btn-ghost" title="Oppdater markedsdata">Refresh</button>
          </div>
        </div>

        <div id="xrbc-dex-grid">
          <!-- LEFT: Orderbook + metrics -->
          <div>
            <div id="xrbc-orderbook-card">
              <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                <div>
                  <label for="xrbc-pair-select" class="xrbc-small">Pair</label>
                  <select id="xrbc-pair-select" style="margin-left:8px;padding:6px;border-radius:8px;">
                    <option value="XRBC/XRP">XRbitcoincash / XRP</option>
                  </select>
                </div>
                <div class="xrbc-small">Top 20 levels</div>
              </div>

              <div id="xrbc-orderbook" aria-live="polite">
                <div class="xrbc-row"><strong>Type</strong><strong>Pris</strong><strong>Amount</strong></div>
                <div class="xrbc-row"><em class="xrbc-small">Laster orderbook…</em></div>
              </div>
            </div>

            <div id="xrbc-metrics-card" style="margin-top:12px;">
              <div style="display:flex;justify-content:space-between;align-items:center;">
                <strong>Quick metrics</strong>
                <span class="xrbc-small">Snapshot</span>
              </div>

              <div style="display:flex;gap:12px;margin-top:10px;flex-wrap:wrap;">
                <div><div class="xrbc-small">Spread</div><div id="xrbc-metric-spread">—</div></div>
                <div><div class="xrbc-small">Best Bid</div><div id="xrbc-metric-bestbid">—</div></div>
                <div><div class="xrbc-small">Best Ask</div><div id="xrbc-metric-bestask">—</div></div>
                <div><div class="xrbc-small">Top Depth (bid/ask)</div><div id="xrbc-metric-depth">—</div></div>
              </div>
            </div>
          </div>

          <!-- RIGHT: Order form (Limit + Market) -->
          <aside>
            <div id="xrbc-order-form-card">
              <div id="xrbc-order-form" >
                <div>
                  <label class="xrbc-small" for="xrbc-order-mode">Order type</label>
                  <select id="xrbc-order-mode">
                    <option value="limit">Limit</option>
                    <option value="market">Market</option>
                  </select>
                </div>
                <div>
                  <label class="xrbc-small" for="xrbc-order-side">Side</label>
                  <select id="xrbc-order-side">
                    <option value="buy">Buy XRBC (spend XRP)</option>
                    <option value="sell">Sell XRBC (receive XRP)</option>
                  </select>
                </div>
                <div>
                  <label class="xrbc-small" for="xrbc-order-amount">Amount (XRBC)</label>
                  <input id="xrbc-order-amount" type="number" step="0.000001" min="0" placeholder="f.eks. 10">
                </div>
                <div id="xrbc-price-row">
                  <label class="xrbc-small" for="xrbc-order-price">Price (XRP per XRBC) — kun for Limit</label>
                  <input id="xrbc-order-price" type="number" step="0.000001" min="0" placeholder="pris per XRBC">
                </div>
                <div style="display:flex;gap:8px;">
                  <button id="xrbc-submit-order" class="xrbc-btn xrbc-btn-primary">Plasser ordre (Xumm)</button>
                  <button id="xrbc-calc-btn" class="xrbc-btn xrbc-btn-ghost" title="Beregn estimerte kostnader">Estimate</button>
                </div>
                <div id="xrbc-order-feedback" class="xrbc-small" style="margin-top:8px;color:var(--xrbc-muted);">Status: idle</div>
                <div id="xrbc-status" class="xrbc-small" style="margin-top:10px;">Node: <span id="xrbc-node-status">disconnecting…</span></div>
                <div class="xrbc-small" style="margin-top:6px;color:var(--xrbc-muted);">Rule: orders must be within ±0.25 XRP from mid-price (when mid-price is available).</div>
              </div>
            </div>
          </aside>
        </div>
      </div>
    </div>
  </main>

  <!-- === CONFIG ripple main net serve local or 3rd party when full roll out === -->
  <script type="application/json" id="app-config">
{
  "xummApiKey": "2abde023-0df1-49a2-a4dc-86d776f6318d",
  "rpcEndpoint": "wss://s1.ripple.com"
}

  </script>

  <!-- External libs: Xumm + xrpl -->
<script src="https://xaman.app/assets/cdn/xumm.min.js"></script>
<script src="https://unpkg.com/xrpl/dist/xrpl.min.js"></script>


  <script>
  (function(){
    'use strict';

    // Konstanter
    const XRBC_ISSUER = "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw";
    const XRBC_CODE = "XRbitcoincash";

const PRIMARY_WSS = siteCfg.rpcEndpoint || "wss://s1.ripple.com";

let xrplClient = null;

// Function to connect to XRPL
async function connectXRPL() {
  try {
    xrplClient = new xrpl.Client(PRIMARY_WSS);
    await xrplClient.connect();
    console.log("Connected to XRPL node at", PRIMARY_WSS);
    nodeStatusEl.textContent = 'connected';
    xrplNodeStatus.textContent = 'connected';
  } catch (err) {
    console.error("XRPL connection failed:", err);
    nodeStatusEl.textContent = 'connection failed';
    xrplNodeStatus.textContent = 'connection failed';
  }
}

 const MAX_LEVELS = 20;
    const MAX_SPREAD_ALLOWED = 0.25; // i XRP — regelen du ba om

    // DOM refs
    const pairSelect = document.getElementById('xrbc-pair-select');
    const orderbookEl = document.getElementById('xrbc-orderbook');
    const walletAddrEl = document.getElementById('xrbc-wallet-addr');
    const nodeStatusEl = document.getElementById('xrbc-node-status');
    const spreadEl = document.getElementById('xrbc-metric-spread');
    const bestBidEl = document.getElementById('xrbc-metric-bestbid');
    const bestAskEl = document.getElementById('xrbc-metric-bestask');
    const depthEl = document.getElementById('xrbc-metric-depth');
    const refreshBtn = document.getElementById('xrbc-refresh-btn');
    const submitBtn = document.getElementById('xrbc-submit-order');
    const calcBtn = document.getElementById('xrbc-calc-btn');
    const orderModeEl = document.getElementById('xrbc-order-mode');
    const orderSideEl = document.getElementById('xrbc-order-side');
    const orderAmountEl = document.getElementById('xrbc-order-amount');
    const orderPriceEl = document.getElementById('xrbc-order-price');
    const orderFeedbackEl = document.getElementById('xrbc-order-feedback');
    const xrplNodeStatus = document.getElementById('xrbc-node-status');
    const connectWalletBtn = document.getElementById('connectWalletButton');
    const walletStatusSpan = document.getElementById('walletAddress');
// read site config safely
    let siteCfg = {};
    try {
      const c = document.getElementById('app-config');
      if (c) siteCfg = JSON.parse(c.textContent || '{}');
    } catch(e){ console.warn('app-config parse error', e); }

    // Prevent runtime config tampering
Object.freeze(siteCfg);

// Validate endpoint before connect
if (!/^wss:\/\/[a-z0-9\.-]+(:[0-9]+)?$/i.test(siteCfg.rpcEndpoint)) {
  console.error("Invalid XRPL endpoint");
  throw new Error("Blocked unsafe endpoint");
}
// runtime state
let xumm = null;
let userAccount = null;

    let lastOrderbook = null; // raw offers array
    let bestBid = null, bestAsk = null;

    // Utility: drops conversion using xrpl library if present
    function toDrops(xrp) {
      if (window.xrpl && typeof xrpl.xrpToDrops === 'function') return xrpl.xrpToDrops(String(xrp));
      return String(Math.round(Number(xrp) * 1_000_000));
    }
    function fromDrops(drops) {
      if (!drops) return 0;
      return Number(drops) / 1_000_000;
    }

async function initClients() {
  // Connect to XRPL
  await connectXRPL();

  // Initialize Xumm SDK
  try {
    if (window.Xumm) {
      const apiKey = siteCfg?.xummApiKey || "7737775c-1645-4a4e-a92d-ffe51530a348";
      xumm = new Xumm(apiKey);
      console.log("Xumm initialized");

      // Enable connect wallet button
      connectWalletBtn.disabled = false;
    } else {
      console.error("Xumm SDK not loaded");
    }
  } catch (e) {
    console.error("Xumm init error:", e);
  }
}


    // Load orderbook fra XRPL (book_offers)
    async function loadOrderbook(){
      orderbookEl.innerHTML = "<div class='xrbc-row'><em>Loading orderbook…</em></div>";
      if (!xrplClient || !xrplClient.isConnected()) {
        orderbookEl.innerHTML = "<div class='xrbc-row' style='color:var(--xrbc-danger)'>XRPL node not connected.</div>";
        return;
      }
      const req = {
        command: "book_offers",
        taker_gets: { currency: XRBC_CODE, issuer: XRBC_ISSUER },
        taker_pays: { currency: "XRP" },
        limit: MAX_LEVELS
      };
      try {
        const res = await xrplClient.request(req);
        const offers = (res && res.result && res.result.offers) ? res.result.offers : [];
        lastOrderbook = offers;
        renderOrderbook(offers);
        computeMetrics(offers);
      } catch (err) {
        console.error('book_offers error', err);
        orderbookEl.innerHTML = `<div class='xrbc-row' style='color:var(--xrbc-danger)'>Orderbook error: ${err.message || err}</div>`;
      }
    }

    // Render orderbook: show inferred side, price, amount
    function renderOrderbook(offers){
      if (!offers || !offers.length) {
        orderbookEl.innerHTML = "<div class='xrbc-row'><em>Ingen offers funnet</em></div>";
        bestBid = bestAsk = null;
        return;
      }
      const container = document.createElement('div');
      const head = document.createElement('div');
      head.className = 'xrbc-row';
      head.innerHTML = "<strong>Side</strong><strong>Pris</strong><strong>Amount</strong>";
      container.appendChild(head);

      offers.forEach((o)=>{
        const quality = o.quality ? parseFloat(o.quality) : null;
        let amount = '—';
        if (o.TakerGets && typeof o.TakerGets === 'object' && o.TakerGets.value) {
          amount = parseFloat(o.TakerGets.value);
        } else if (o.TakerGets && !isNaN(o.TakerGets)) {
          amount = fromDrops(o.TakerGets);
        }
        // Determine side: if TakerGets is XRBC => maker is selling XRBC => ASK
        let type = 'Buy';
        if (o.TakerGets && typeof o.TakerGets === 'object' && o.TakerGets.currency === XRBC_CODE) type = 'Sell';
        else if (o.Flags && (o.Flags & 0x00080000)) type = 'Sell';

        const row = document.createElement('div');
        row.className = 'xrbc-row';
        row.innerHTML = `<div class="${type==='Buy'?'xrbc-bid':'xrbc-ask'}">${type}</div><div>${quality ? Number(quality).toFixed(6) : '—'}</div><div>${amount}</div>`;
        container.appendChild(row);
      });
      orderbookEl.innerHTML = '';
      orderbookEl.appendChild(container);
    }

    // compute metrics (best bid/ask, spread, depth)
    function computeMetrics(offers){
      if (!offers || !offers.length) {
        spreadEl.textContent = '—'; bestBidEl.textContent = '—'; bestAskEl.textContent = '—'; depthEl.textContent = '—';
        bestBid = bestAsk = null;
        return;
      }
      const asks = [], bids = [];
      offers.forEach(o=>{
        const price = o.quality ? Number(o.quality) : null;
        let amount = 0;
        if (o.TakerGets && typeof o.TakerGets === 'object' && o.TakerGets.value) amount = Number(o.TakerGets.value);
        else if (o.TakerGets) amount = fromDrops(o.TakerGets);
        if (o.TakerGets && typeof o.TakerGets === 'object' && o.TakerGets.currency === XRBC_CODE) {
          asks.push({price, amount});
        } else {
          bids.push({price, amount});
        }
      });

      asks.sort((a,b)=>a.price - b.price);
      bids.sort((a,b)=>b.price - a.price);

      bestAsk = (asks.length>0) ? asks[0].price : null;
      bestBid = (bids.length>0) ? bids[0].price : null;
      bestAskEl.textContent = bestAsk ? bestAsk.toFixed(6) : '—';
      bestBidEl.textContent = bestBid ? bestBid.toFixed(6) : '—';
      if (bestAsk !== null && bestBid !== null) {
        const sp = bestAsk - bestBid;
        spreadEl.textContent = sp.toFixed(6);
      } else spreadEl.textContent = '—';

      const topBids = bids.slice(0,5).reduce((s,x)=>s + (x.amount || 0), 0);
      const topAsks = asks.slice(0,5).reduce((s,x)=>s + (x.amount || 0), 0);
      depthEl.textContent = `${topBids.toFixed(6)} / ${topAsks.toFixed(6)}`;
    }

    // Slippage / market fill estimator (brukes for Estimate og Market ordre)
    function estimateMarketFill(side, amountXRBC){
      if (!lastOrderbook || !lastOrderbook.length) return { error: 'Ingen orderbook' };
      const asks = [], bids = [];
      lastOrderbook.forEach(o=>{
        const price = o.quality ? Number(o.quality) : null;
        let amount = 0;
        if (o.TakerGets && typeof o.TakerGets === 'object' && o.TakerGets.value) amount = Number(o.TakerGets.value);
        else if (o.TakerGets) amount = fromDrops(o.TakerGets);
        if (o.TakerGets && typeof o.TakerGets === 'object' && o.TakerGets.currency === XRBC_CODE) asks.push({price, amount});
        else bids.push({price, amount});
      });
      asks.sort((a,b)=>a.price - b.price);
      bids.sort((a,b)=>b.price - a.price);

      const levels = (side === 'buy') ? asks : bids;
      let remaining = Number(amountXRBC);
      if (remaining <= 0) return { error: 'Beløpet må være positivt' };
      let filledValue = 0; // sum(price * qty)
      const trace = [];
      for (const lvl of levels) {
        if (remaining <= 0) break;
        const lvlAmt = lvl.amount || 0;
        if (!lvlAmt || !lvl.price) continue;
        const take = Math.min(remaining, lvlAmt);
        filledValue += take * lvl.price;
        trace.push({price: lvl.price, qty: take});
        remaining -= take;
      }
      if (remaining > 0) return { error: 'Insufficient depth' };
      const avgPrice = filledValue / Number(amountXRBC);
      return { avgPrice, filledValue, trace };
    }

    // Create Offer via Xumm (brukes for både limit og market flows)
    async function createOfferViaXumm(side, amount, price) {
      if (!window.Xumm && !xumm) {
        orderFeedbackEl.textContent = 'Xumm SDK ikke tilgjengelig på siden.';
        return;
      }
      // sørg for userAccount
      if (!userAccount) {
        try {
          if (xumm && xumm.user && typeof xumm.user.account !== 'undefined') {
            userAccount = await xumm.user.account;
            if (userAccount) walletAddrEl.textContent = userAccount;
          }
        } catch(e){}
      }
      if (!userAccount) { orderFeedbackEl.textContent = 'Wallet ikke koblet (Xumm).'; return; }

      // Build TakerGets / TakerPays avhengig av side
      let takerGets, takerPays;
      if (side === 'buy') {
        // buy XRBC: spend XRP (TakerGets = XRP drops), receive XRBC (TakerPays = IOU)
        takerGets = toDrops(Number(price) * Number(amount)); // total XRP to give
        takerPays = { currency: XRBC_CODE, issuer: XRBC_ISSUER, value: Number(amount).toFixed(6) };
      } else {
        // sell XRBC: TakerGets = XRBC IOU, TakerPays = XRP drops
        takerGets = { currency: XRBC_CODE, issuer: XRBC_ISSUER, value: Number(amount).toFixed(6) };
        takerPays = toDrops(Number(price) * Number(amount));
      }

      const tx = {
        TransactionType: "OfferCreate",
        Account: userAccount,
        TakerGets: takerGets,
        TakerPays: takerPays,
        Flags: (side === 'sell') ? 0x00080000 : 0
      };

      orderFeedbackEl.textContent = 'Sender signaturforespørsel til Xumm…';
      try {
        if (xumm && xumm.payload && typeof xumm.payload.createAndSubscribe === 'function') {
          const sub = await xumm.payload.createAndSubscribe({ txjson: tx }, (evt) => {
            if (!evt || !evt.data) return;
            if (evt.data.signed === true) {
              orderFeedbackEl.textContent = 'Order signert og sendt til ledger.';
              return true;
            } else if (evt.data.signed === false) {
              orderFeedbackEl.textContent = 'Signering avvist av bruker.';
              return false;
            }
          });
          if (sub && sub.created && sub.created.next && sub.created.next.alternative_url) {
            orderFeedbackEl.innerHTML = `Åpne Xumm for å signere: <a target="_blank" rel="noopener" href="${sub.created.next.alternative_url}">Åpne Xumm</a>`;
          }
        } else if (xumm && xumm.payload && typeof xumm.payload.create === 'function') {
          const created = await xumm.payload.create({ txjson: tx });
          if (created && created.next && created.next.alternative_url) {
            orderFeedbackEl.innerHTML = `Åpne Xumm for å signere: <a target="_blank" rel="noopener" href="${created.next.alternative_url}">Åpne Xumm</a>`;
          } else orderFeedbackEl.textContent = 'Payload opprettet; følg Xumm-flow.';
        } else if (window.Xumm && typeof window.Xumm === 'function') {
          // older/bundled variations (fallback)
          try {
            const created = await window.Xumm.payload.create({ txjson: tx });
            if (created && created.next && created.next.alternative_url) {
              orderFeedbackEl.innerHTML = `Åpne Xumm for å signere: <a target="_blank" rel="noopener" href="${created.next.alternative_url}">Åpne Xumm</a>`;
            }
          } catch(e){ orderFeedbackEl.textContent = 'Kunne ikke lage Xumm payload (fallback).' }
        } else {
          orderFeedbackEl.textContent = 'Xumm payload API ikke tilgjengelig (SDK inkompatibel).';
        }
      } catch (err) {
        console.error('Xumm payload error', err);
        orderFeedbackEl.textContent = `Feil ved oppretting: ${err.message || err}`;
      }
    }

    // Valider prisen i forhold til mid-price-regel (±0.25)
    function validatePriceWithinSpreadRule(price) {
      if (bestAsk === null || bestBid === null) {
        // hvis vi ikke har begge priser kan vi ikke kontrollere; avhend etter policy: tillat men advar
        return { ok: true, warning: 'Mid-price ikke tilgjengelig — kan ikke verifisere ±0.25 regelen.' };
      }
      const mid = (bestAsk + bestBid) / 2;
      const diff = Math.abs(Number(price) - mid);
      if (diff > MAX_SPREAD_ALLOWED) {
        return { ok: false, message: `Pris avviker med ${diff.toFixed(6)} XRP fra mid-price (tillatt maks ${MAX_SPREAD_ALLOWED}).` };
      }
      return { ok: true };
    }

    // Beregn og plasser ordre (limit eller market)
    async function placeOrderFlow() {
      const mode = orderModeEl.value; // limit | market
      const side = orderSideEl.value; // buy | sell
      const amount = Number(orderAmountEl.value);
      const priceInput = Number(orderPriceEl.value);

      if (!amount || amount <= 0) { orderFeedbackEl.textContent = 'Oppgi et gyldig antall XRBC.'; return; }

      let priceToUse = null;

      if (mode === 'limit') {
        if (!priceInput || priceInput <= 0) { orderFeedbackEl.textContent = 'Oppgi en gyldig pris for limit-order.'; return; }
        priceToUse = priceInput;

        // valider spread-regel
        const v = validatePriceWithinSpreadRule(priceToUse);
        if (!v.ok) { orderFeedbackEl.textContent = `Order avvist: ${v.message}`; return; }
        if (v.warning) { orderFeedbackEl.textContent = `Advarsel: ${v.warning}`; }

        // create payload
        await createOfferViaXumm(side, amount, priceToUse);
      } else {
        // Market order: estimer fra orderbook og bruk beste pris for å krysse booken.
        const est = estimateMarketFill(side, amount);
        if (est.error) { orderFeedbackEl.textContent = `Market order feilet: ${est.error}`; return; }
        const avgPrice = est.avgPrice;
        // For market ordre, vi plasserer et Offer på beste motpartspris for større sjanse for utførelse
        if (side === 'buy') {
          if (!bestAsk) { orderFeedbackEl.textContent = 'Ingen best ask tilgjengelig.'; return; }
          priceToUse = bestAsk;
        } else {
          if (!bestBid) { orderFeedbackEl.textContent = 'Ingen best bid tilgjengelig.'; return; }
          priceToUse = bestBid;
        }

        // valider spread-regel mot mid-price også
        const v = validatePriceWithinSpreadRule(priceToUse);
        if (!v.ok) { orderFeedbackEl.textContent = `Market order avvist: ${v.message}`; return; }
        if (v.warning) { orderFeedbackEl.textContent = `Advarsel: ${v.warning}`; }

        // Vis estimering før vi sender payload
        orderFeedbackEl.textContent = `Market estimate: Avg ${avgPrice.toFixed(6)} XRP — oppretter ordre til ${priceToUse.toFixed(6)} XRP. Sender til Xumm...`;

        await createOfferViaXumm(side, amount, priceToUse);
      }
    }

    // Beregn (Estimate) knappen: viser estimert avg price for Market-lignende fyll eller for Limit viser potensielt slippage
    function estimateHandler() {
      const mode = orderModeEl.value;
      const side = orderSideEl.value;
      const amount = Number(orderAmountEl.value);
      const priceInput = Number(orderPriceEl.value);

      if (!amount || amount <= 0) { orderFeedbackEl.textContent = 'Oppgi et gyldig antall XRBC for estimering.'; return; }

      if (mode === 'limit') {
        if (!priceInput || priceInput <= 0) { orderFeedbackEl.textContent = 'Oppgi pris for å estimere slippage for Limit.'; return; }
        const est = estimateMarketFill(side, amount);
        if (est.error) { orderFeedbackEl.textContent = `Estimering: ${est.error}`; return; }
        const slippagePct = ((est.avgPrice - priceInput) / priceInput) * 100;
        orderFeedbackEl.textContent = `Estimat ved market-fyll: avg ${est.avgPrice.toFixed(6)} XRP — estimert slippage vs din pris: ${slippagePct.toFixed(4)}%`;
      } else {
        const est = estimateMarketFill(side, amount);
        if (est.error) { orderFeedbackEl.textContent = `Estimering: ${est.error}`; return; }
        orderFeedbackEl.textContent = `Market estimate: avg ${est.avgPrice.toFixed(6)} XRP (fyller mot ${est.trace.length} nivåer)`;
      }
    }

    // Event bindings
    refreshBtn.addEventListener('click', ()=> loadOrderbook());
    submitBtn.addEventListener('click', ()=> placeOrderFlow());
    calcBtn.addEventListener('click', ()=> estimateHandler());

    // Toggle price input synlighet basert på order type
    orderModeEl.addEventListener('change', ()=> {
      const pr = document.getElementById('xrbc-price-row');
      if (orderModeEl.value === 'limit') pr.style.display = 'block';
      else pr.style.display = 'none';
    });
    // initial visibility
    if (orderModeEl.value !== 'limit') document.getElementById('xrbc-price-row').style.display = 'none';

    // Connect / Disconnect wallet via Xumm
    connectWalletBtn.addEventListener('click', async ()=>{
      if (!xumm && !window.Xumm) { walletStatusSpan.textContent = 'Xumm SDK ikke lastet'; return; }
      // Hvis allerede logget inn, bruk disconnect
      if (connectWalletBtn.textContent.trim() === 'Disconnect') {
        try {
          if (xumm && typeof xumm.logout === 'function') await xumm.logout();
          userAccount = null;
          walletAddrEl.textContent = 'Ikke koblet';
          walletStatusSpan.textContent = '✅ Lommebok frakoblet';
          connectWalletBtn.textContent = 'Connect Wallet';
        } catch(e){
          console.error('Logout error', e);
          walletStatusSpan.textContent = '⚠ Feil ved frakobling';
        }
        return;
      }

      // Connect — authorize
      try {
        connectWalletBtn.disabled = true;
        walletStatusSpan.textContent = 'Connecting…';
        const sdk = xumm || window.Xumm;
        if (sdk && typeof sdk.authorize === 'function') {
          const auth = await sdk.authorize();
          // autorisasjon fullført — hent konto
          try {
            if (sdk.user && typeof sdk.user.account !== 'undefined') {
              const acct = await sdk.user.account;
              if (acct) {
                userAccount = acct;
                walletAddrEl.textContent = acct;
                walletStatusSpan.textContent = 'Connected: ' + acct;
                connectWalletBtn.textContent = 'Disconnect';
              }
            }
          } catch(e){}
        } else {
          walletStatusSpan.textContent = 'Xumm.authorize ikke tilgjengelig.';
        }
      } catch (err) {
        console.error('Wallet connect error', err);
        walletStatusSpan.textContent = 'Status: Ikke koblet';
      } finally {
        connectWalletBtn.disabled = false;
      }
    });

    // Kickoff
    initClients().then(()=> {
      loadOrderbook();
      // rask wallet detect hvis Xumm SDK tilbyr
      try {
        if ((xumm && xumm.user && typeof xumm.user.account !== 'undefined')) {
          xumm.user.account.then(a=>{ if (a) { userAccount = a; walletAddrEl.textContent = a; walletStatusSpan.textContent = 'Connected: ' + a; connectWalletBtn.textContent = 'Disconnect'; }});
        }
      } catch(e){}
    });

    // Eksponer debug API
    window.__xrbcDex = {
      loadOrderbook,
      estimateMarketFill,
      lastOrderbook: ()=> lastOrderbook,
      bestBid: ()=> bestBid,
      bestAsk: ()=> bestAsk
    };

  })();
  </script>
<script>
(function(){
  'use strict';

  // --- Auto-refresh orderbook and metrics ---
  const REFRESH_INTERVAL_MS = 5000; // refresh every 5 seconds

  async function autoRefresh() {
    if (window.__xrbcDex && typeof window.__xrbcDex.loadOrderbook === 'function') {
      try {
        await window.__xrbcDex.loadOrderbook();
      } catch(e){
        console.error('Auto-refresh orderbook failed', e);
      }
    }
  }

  // Kick off interval
  setInterval(autoRefresh, REFRESH_INTERVAL_MS);

  // Optional: refresh immediately on load
  autoRefresh();
})();
</script>

</body>
</html>
