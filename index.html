<!DOCTYPE html>
<html lang="en">
<head>
  <!-- favicon -->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="shortcut icon" href="/favicon.png" type="image/png">
  <meta name="msapplication-TileImage" content="/favicon.png">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>XRBitcoinCash</title>

  <!-- Icons -->
  <link rel="icon" href="/xrbc-nft.png" />
  <link rel="apple-touch-icon" href="/xrbc-nft.png" />

  <!-- Primary SEO -->
  <meta name="description" content="XRBitcoinCash (XRBC) ‚Äî fast, low-fee XRPL token with integrated ChatGPT-powered Security Center. Trade XRBC, explore NFTs, and verify wallet safety directly on-page." />
  <meta name="keywords" content="XRBC, XRPL, XRBitcoinCash, cryptocurrency, token, liquidity pool, XUMM, XPMarket, ChatGPT, AI Security Center, wallet safety, crypto transparency" />
  <link rel="canonical" href="https://xrbitcoincash.com/" />

  <!-- Acknowledgement -->
  <meta name="generator" content="Built with assistance from ChatGPT AI" />
  <meta name="credit" content="Security Center powered by ChatGPT AI ‚Äî thank you to OpenAI for enabling transparent wallet safety audits." />

  <!-- Open Graph -->
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XRBitcoinCash ‚Äî XRBC on XRPL" />
  <meta property="og:description" content="Trade XRBC fast on XRPL. Low fees, 3s finality, and now an AI-powered Security Center by ChatGPT for wallet safety & transparency." />
  <meta property="og:image" content="https://xrbitcoincash.com/xrbc-nft.png" />
  <meta property="og:url" content="https://xrbitcoincash.com/" />

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="XRBitcoinCash ‚Äî XRBC on XRPL" />
  <meta name="twitter:description" content="XRBitcoinCash now features a ChatGPT-powered Security Center ‚Äî ask about wallet safety, XRPL standards, and liquidity directly on-site." />
  <meta name="twitter:image" content="https://xrbitcoincash.com/xrbc-nft.png" />

  <!-- External CSS -->
  <link rel="stylesheet" href="xrbc.css">
</head>

<body>
  <!-- üåô Light/Dark Mode Toggle -->
  <button class="toggle-theme" id="themeToggle">‚òÄÔ∏è</button>
  <script>
    const toggle = document.getElementById('themeToggle');
    toggle.addEventListener('click', () => {
      document.body.classList.toggle('light-mode');
      toggle.textContent = document.body.classList.contains('light-mode') ? 'üåô' : '‚òÄÔ∏è';
    });
  </script>

  <header>
    <div class="brand">
      <img src="/xrbc-nft.png" alt="XRBC logo" />
     <h1>XRBitcoinCash</h1>

    </div>
  </header>



<script>
// ===== CONFIGURE EXPIRY DATE HERE =====
const expiryDate = new Date("2026-08-22T05:00:00Z");

function updateTimer() {
  const now = new Date();
  const diff = expiryDate - now;

  if (diff <= 0) {
    document.getElementById("updateCountdown").innerHTML = "<span style='color:red;'>Expired! Update now.</span>";
    return;
  }

  const days = Math.floor(diff / (1000 * 60 * 60 * 24));
  const hours = Math.floor((diff / (1000 * 60 * 60)) % 24);
  const mins = Math.floor((diff / (1000 * 60)) % 60);

  let msg = `${days} days, ${hours} hrs, ${mins} min remaining`;
  if (days < 30) msg = `<span style="color:orange;">${msg}</span>`; // Warning when < 30 days
  document.getElementById("updateCountdown").innerHTML = msg;
}

updateTimer(); // run immediately
setInterval(updateTimer, 60000); // update every minute
</script>

<main>
  <section class="hero">
    <div class="particles">
      <div class="particle" style="top:20%;left:10%;animation-delay:0s"></div>
      <div class="particle" style="top:50%;left:30%;animation-delay:1s"></div>
      <div class="particle" style="top:80%;left:50%;animation-delay:2s"></div>
      <div class="particle" style="top:40%;left:70%;animation-delay:3s"></div>
      <div class="particle" style="top:60%;left:90%;animation-delay:4s"></div>
    </div>
   
    <div>
      <h2>Trade XRBC fast on XRPL</h2>
      <p>Low fees. ~3s finality. Transparent, non-custodial flows ‚Äî designed for fast on-ledger trading.</p>
      <div class="button-group">
        <a href="https://xrbitcoincash.com/nfts.html" class="btn primary">üé® NFT Gallery</a>
        <a href="https://xrbitcoincash.github.io/trade.html" class="btn primary glow-green">üöÄ Trade XRBC Now</a>
        <a href="https://xrbitcoincash.com/bs/" class="btn primary">Blockchain Specs</a>
        <a href="https://sologenic.org/amm/XRP_XRbitcoincash_rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw" 
           class="btn primary" target="_blank" rel="noopener noreferrer">
           üíß Sologenic Liquidity Pool
        </a>

        <a href="/whitepaper.html" class="btn ghost glow-white">Whitepaper</a>
        <a href="https://xrbitcoincash.com/about.html" class="btn ghost">About XRBC</a>
      </div>
    </div>

    <aside class="card nft glow-green">
      <img src="/xrbc-nft.png" alt="XRBitcoinCash NFT" />
      <p class="muted small" style="margin-top:10px">
        <a href="https://sologenic.org/profile/xrbitcoincash.com" target="_blank" style="color:var(--muted)">Official XRBitcoinCash artwork</a>
      </p>
    </aside>
  </section>

  <section class="grid">
    <div class="feature card">
      <h3>About XRBC</h3>
      <p class="muted">
        XRBitcoinCash (XRBC) is a fast, low-fee asset on the XRP Ledger, backed by transparent tokenomics and open governance.
        Issuer: <strong>rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw</strong>, Code: <strong>XRbitcoincash</strong>.
        With a trustline cap of <strong>20,999,999.999999996</strong>, XRBC is designed for sustainable liquidity and long-term growth.
      </p>
    </div>
    <div class="feature card">
      <h3>Trading</h3>
      <p class="muted">
        Trading on XRPL means you can exchange assets directly on-ledger without intermediaries. Using the built-in decentralized exchange (DEX),
        you can place limit orders, swap instantly through liquidity pools, or trade via automated market makers like Sologenic AMM.
      </p>
    </div>
    <div class="feature card">
      <h3>NFTs</h3>
      <p class="muted">Collections, drops, and artwork tied to XRBC.</p>
    </div>
  </section>

/* === Security Center Buttons + Layout === */
#auditInput {
  width: 100%;
  min-height: 80px;
  resize: vertical;
  border: 1px solid rgba(0,229,255,0.25);
  border-radius: 10px;
  padding: 10px 12px;
  background: rgba(15,23,36,0.9);
  color: var(--ink);
  font-family: 'Inter', sans-serif;
  font-size: 0.95rem;
  margin-bottom: 10px;
  box-shadow: 0 0 8px rgba(0,229,255,0.08);
}
#auditInput:focus {
  border-color: var(--accent);
  box-shadow: 0 0 14px rgba(0,229,255,0.3);
}

.audit-buttons {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 14px;
  flex-wrap: wrap;
  margin-top: 10px;
}

/* Gradient Animated Buttons */
#auditSend, #auditVoice, .btn-glow-link {
  flex: 1 1 32%;
  padding: 12px 0;
  border-radius: 10px;
  color: #fff;
  font-weight: 700;
  border: none;
  cursor: pointer;
  text-align: center;
  text-shadow: 0 0 3px rgba(0,0,0,0.3);
  background-size: 300% 300%;
  animation: btnGradientShift 6s ease infinite;
  transition: transform 0.25s, box-shadow 0.25s;
}

#auditSend { background: linear-gradient(90deg, var(--accent), var(--green), var(--blue)); }
#auditVoice { background: linear-gradient(90deg, var(--purple), var(--accent), var(--green)); }
.btn-glow-link { background: linear-gradient(90deg, var(--orange), var(--red), var(--purple)); box-shadow: 0 0 12px rgba(255,76,76,0.4); }

#auditSend:hover, #auditVoice:hover, .btn-glow-link:hover {
  transform: scale(1.05);
  box-shadow: 0 0 18px rgba(0,229,255,0.45);
}

@keyframes btnGradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

.helper.small {
  text-align: right;
  font-size: 0.9rem;
  color: var(--muted);
  opacity: 0.9;
  margin-top: 6px;
}

@media (max-width: 700px) {
  .audit-buttons { flex-direction: column; align-items: stretch; }
  #auditSend, #auditVoice, .btn-glow-link { width: 100%; }
  .helper.small { text-align: left; }
}

  
  </section>
</main>

<footer class="ecosystem-footer">
  <div class="footer-container">
    <h3>XRBitcoin Ecosystem</h3>
    <p class="ecosystem-desc">
      Interlinked XRPL-based assets ‚Äî XRBitcoinCash (XRBC), XRBitcoin, and Jesus Christ Saves Token (JCS).
    </p>

    <div class="ecosystem-links">
      <a href="https://xrbitcoincash.com" class="eco-link" target="_blank" rel="noopener">
        <img src="/xrbc-nft.png" alt="XRBitcoinCash logo">
        <span>XRBitcoinCash</span>
      </a>

      <a href="/XRBitcoin/" class="eco-link" target="_blank" rel="noopener">
        <img src="/XRBitcoin/xrbitcoin-logo.png" alt="XRBitcoin logo">
        <span>XRBitcoin</span>
      </a>

      <a href="https://jesuschristsavestoken.com/" class="eco-link" target="_blank" rel="noopener">
        <img src="/JCS-token-on-the-XRPL/jcs-logo.png" alt="Jesus Christ Saves Token logo">
        <span>Jesus Christ Saves</span>
      </a>

      <a href="https://x.com/XRbitcoincash" target="_blank" class="eco-link" rel="noopener">
        <img src="https://upload.wikimedia.org/wikipedia/commons/6/6f/Logo_of_Twitter.svg" alt="Twitter" style="width:22px; height:22px;">
        <span>Twitter</span>
      </a>
    </div>

    <p class="ecosystem-tagline"><strong>Built on the XRP Ledger.</strong></p>
  </div>
</footer>




<script>
(() => {
  "use strict";

  // ===== 1) SCROLL FADE-IN =====
  const features = document.querySelectorAll(".feature");
  const fadeObserver = new IntersectionObserver(
    entries => entries.forEach(e => {
      if (e.isIntersecting) {
        e.target.classList.add("visible");
        fadeObserver.unobserve(e.target);
      }
    }),
    { threshold: 0.2 }
  );
  features.forEach(f => fadeObserver.observe(f));

  // ===== 2) CONFIG =====
  const PROXY = "https://xrbc-frontend.onrender.com";
  const CHAT_PATH = "/chat";
  const FALLBACK_URL = "https://chat.openai.com/?model=gpt-5";
  const FALLBACK_WEB3_URL = "https://chatgpt.eth.link/";
  const MAX_WAIT_MS = 52000;

  // ===== 3) ELEMENTS =====
  const toggle   = document.getElementById("auditToggle");
  const widget   = document.getElementById("auditWidget");
  const output   = document.getElementById("auditOutput");
  const inputEl  = document.getElementById("auditInput");  // input or textarea
  const send     = document.getElementById("auditSend");
  const voiceBtn = document.getElementById("auditVoice");
  const quickBtns= document.querySelectorAll(".auditQuick");

  let keepAliveInterval = null;
  let proxyTimedOut = false;

  // ===== 4) UTILS =====
  const sleep = ms => new Promise(r => setTimeout(r, ms));
  const append = html => {
    const w = document.createElement("div");
    w.className = "chat-block";
    w.innerHTML = html;
    output.appendChild(w);
    w.scrollIntoView({ behavior: "smooth", block: "nearest" });
  };
  const esc = s => String(s)
    .replace(/&/g,"&amp;").replace(/</g,"&lt;")
    .replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;");

  // ===== 5) LOCAL CHAT MEMORY (sessionStorage/tab-scoped) =====
  // Normalize history to array of {role, content}
  let chatHistory = [];
  try {
    const raw = JSON.parse(sessionStorage.getItem("xrbc_chat_history") || "[]");
    chatHistory = Array.isArray(raw) ? raw : [];
  } catch { chatHistory = []; }

  const saveChatHistory = () =>
    sessionStorage.setItem("xrbc_chat_history", JSON.stringify(chatHistory.slice(-10)));

  const renderMessage = m => {
    if (typeof m === "string") {
      // legacy HTML message (from older version) ‚Äî just append
      append(m);
      return;
    }
    if (m.role === "user") {
      append(`<p><strong style="color:#9EB2D0">You:</strong> ${esc(m.content)}</p>`);
    } else if (m.role === "assistant") {
      append(`<p style="white-space:pre-line"><strong style="color:#00E5FF">AI Auditor:</strong> ${esc(m.content)}</p>`);
    }
  };

  // restore last 10 messages (if any)
  chatHistory.slice(-10).forEach(renderMessage);

  // ===== 6) WAKE PROXY =====
  async function wakeProxy(maxMs = MAX_WAIT_MS) {
    const start = Date.now();
    let attempt = 0;
    append(`<p id="wakeStatus" style="color:#888;">üïì Waking secure AI proxy...</p>`);
    while (Date.now() - start < maxMs) {
      attempt++;
      try {
        const status = document.getElementById("wakeStatus");
        if (status) status.innerHTML = `üü° Attempt ${attempt}: contacting secure XRBC proxy...`;
        const ctrl = new AbortController();
        const t = setTimeout(() => ctrl.abort(), 12000);
        const r = await fetch(`${PROXY}/healthz?ts=${Date.now()}`, { cache: "no-store", signal: ctrl.signal });
        clearTimeout(t);
        if (r.ok) {
          if (status) status.innerHTML = `‚úÖ Proxy online after ${attempt} attempt${attempt>1?"s":""}.`;
          await sleep(800);
          status?.remove();
          return true;
        }
      } catch {}
      const delay = Math.min(10000, Math.round(600 * Math.pow(1.7, attempt)));
      await sleep(delay);
    }
    const status = document.getElementById("wakeStatus");
    if (status) status.innerHTML = `‚ùå Proxy not responding (after ${attempt} attempts).`;
    return false;
  }

  async function resolveChatGPTLink() {
    try {
      await fetch(FALLBACK_URL, { method: "HEAD", mode: "no-cors" });
      return FALLBACK_URL;
    } catch { return FALLBACK_WEB3_URL; }
  }

  async function showFallback() {
    proxyTimedOut = true;
    widget.style.display = "block";
    const fallbackLink = await resolveChatGPTLink();
    append(`
      <div style="border:1px solid rgba(0,229,255,0.25); border-radius:12px; padding:16px; background:#101820; margin-top:10px;">
        <p style="color:#9EB2D0;">‚ö†Ô∏è The secure XRBC proxy is currently unavailable or still waking up.<br><br>
        You can continue your conversation directly with ChatGPT below:</p>
        <div style="text-align:center;margin-top:14px;">
          <a href="${fallbackLink}" target="_blank" class="btn primary glow-blue">üí¨ Open ChatGPT Fallback</a>
        </div>
        <p style="margin-top:10px; color:#777; font-size:0.85rem;">
          Tip: Render free plans can take 30‚Äì45 seconds to start after inactivity. If you retry in a moment, the integrated Security Center should come online automatically.
        </p>
      </div>
    `);
  }

  // ===== 7) TOGGLE WIDGET (instant open; async wake) =====
  toggle.addEventListener("click", async () => {
    const wasHidden = widget.style.display === "none" || widget.style.display === "";
    widget.style.display = wasHidden ? "block" : "none";
    if (!wasHidden) { clearInterval(keepAliveInterval); keepAliveInterval = null; return; }

    const proxyReady = await Promise.race([ wakeProxy(MAX_WAIT_MS), sleep(MAX_WAIT_MS + 2000).then(() => false) ]);
    if (!proxyReady) { showFallback(); return; }

    keepAliveInterval = setInterval(() => {
      fetch(`${PROXY}/healthz?ts=${Date.now()}`).catch(() => {});
    }, 60000);
  });

  // ===== 8) CHAT FUNCTION =====
  async function postChat(q) {
    if (proxyTimedOut) {
      append(`<p style="color:#f88"><strong>Note:</strong> Proxy fallback mode active ‚Äî please use the backup chat link above.</p>`);
      return;
    }

    // Show + log user message (object form)
    renderMessage({ role: "user", content: q });
    chatHistory.push({ role: "user", content: q });
    saveChatHistory();

    const spinnerId = "spinner-" + Date.now();
    append(`<p id="${spinnerId}" style="color:#9EB2D0">‚è≥ Connecting to XRBC Auditor‚Ä¶</p>`);

    const awake = await wakeProxy();
    if (!awake) { document.getElementById(spinnerId)?.remove(); showFallback(); return; }

    try {
      const ctrl = new AbortController();
      const timer = setTimeout(() => ctrl.abort(), 60000);

      // Send up to last 10 messages + current user query
      const payload = { messages: chatHistory.slice(-10).concat([{ role: "user", content: q }]) };

      const resp = await fetch(`${PROXY}${CHAT_PATH}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
        signal: ctrl.signal
      });

      clearTimeout(timer);
      document.getElementById(spinnerId)?.remove();

      if (!resp.ok) {
        const errText = await resp.text();
        append(`<p style="color:#f88"><strong>Upstream error:</strong> ${resp.status} ${esc(errText)}</p>`);
        return;
      }

      const data = await resp.json();
      const ans = data?.choices?.[0]?.message?.content || "No answer (proxy connected but returned empty).";

      renderMessage({ role: "assistant", content: ans });
      chatHistory.push({ role: "assistant", content: ans });
      saveChatHistory();

    } catch (err) {
      document.getElementById(spinnerId)?.remove();
      showFallback();
    }
  }

  // ===== 9) INPUT/CONTROLS =====
  // Click send
  send.addEventListener("click", () => {
    const q = (inputEl.value || "").trim();
    if (!q) return;
    inputEl.value = "";
    postChat(q);
  });

  // Enter to send (support textarea too: Shift+Enter = newline, Enter = send)
  inputEl.addEventListener("keydown", e => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      send.click();
    }
  });

  // Quick buttons
  quickBtns.forEach(btn =>
    btn.addEventListener("click", () => postChat(btn.dataset.q))
  );

  // Voice (feature-detect)
  if ("webkitSpeechRecognition" in window) {
    const recog = new webkitSpeechRecognition();
    recog.continuous = false;
    recog.interimResults = false;
    recog.lang = "en-US";
    voiceBtn.addEventListener("click", () => {
      recog.start();
      voiceBtn.textContent = "üé§ Listening...";
    });
    recog.onresult = e => {
      inputEl.value = e.results[0][0].transcript;
      send.click();
    };
    recog.onend = () => { voiceBtn.textContent = "üé§ Voice"; };
  } else {
    voiceBtn.style.display = "none";
  }

  // ===== 10) CLEANUP =====
  window.addEventListener("beforeunload", () => clearInterval(keepAliveInterval));
})();
</script>


</body>
</html>
