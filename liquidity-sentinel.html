<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <link rel="license" href="#license-proprietary">

  <!-- ===== XRBitcoinCash · Liquidity Sentinel (Health + Quick Buy) ===== -->
  <title>Liquidity Sentinel · XRPL · XRBitcoinCash</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="canonical" href="https://xrbitcoincash.com/liquidity-sentinel.html" />
  <link rel="alternate" hreflang="en" href="https://xrbitcoincash.com/liquidity-sentinel.html" />
  <meta name="description" content="Scan XRPL AMM pool health for your trustlines (slippage probes, scoring, filters), and quick-buy XRBC with a 2% cap. Self-custody with Xaman." />
  <meta name="robots" content="index,follow,max-snippet:-1,max-image-preview:large,max-video-preview:-1" />
  <meta name="theme-color" content="#0b0f14" />

  <!-- Open Graph -->
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="XRBitcoinCash" />
  <meta property="og:title" content="Liquidity Sentinel · XRPL" />
  <meta property="og:description" content="Pool health with slippage probes (Small 1/10 or Standard 10/100 XRP), CSV export, filters, and XRBC Quick Buy." />
  <meta property="og:url" content="https://xrbitcoincash.com/liquidity-sentinel.html" />
  <meta property="og:image" content="https://xrbitcoincash.com/xrbc-nft.png" />
  <meta property="og:locale" content="en_US" />

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Liquidity Sentinel · XRPL" />
  <meta name="twitter:description" content="Pool health with slippage probes (Small 1/10 or Standard 10/100 XRP), CSV export, filters, and XRBC Quick Buy." />
  <meta name="twitter:image" content="https://xrbitcoincash.com/xrbc-nft.png" />

  <!-- Icons -->
  <link rel="icon" href="/xrbc-nft.png" sizes="any" />
  <link rel="apple-touch-icon" href="/xrbc-nft.png" />

  <!-- Helpful preconnects -->
  <link rel="preconnect" href="https://xaman.app" crossorigin>
  <link rel="preconnect" href="https://xrbitcoincash-github-io.onrender.com" crossorigin>

  <!-- CSP -->
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src  'self' 'unsafe-inline' https://xumm.app https://xaman.app;
    style-src   'self' 'unsafe-inline';
    img-src     'self' data: https:;
    connect-src 'self' https://xumm.app https://oauth2.xumm.app https://xaman.app https://xrbitcoincash-github-io.onrender.com wss://xumm.app wss://xaman.app;
    frame-src   'self' https://xumm.app https://oauth2.xumm.app https://xaman.app;
    base-uri    'self';
    form-action 'self';
  ">

  <style>
:root{
  --wrap:1100px;--bg:#0b0f14;--panel:#0e1520;--panel-2:#0c131c;--ink:#e7edf5;--muted:#9fb0c5;--line:#2b3a4b;
  --ok:#22c55e;--err:#ef4444;--blue:#2563eb;--yellow:#f59e0b;--shadow:rgba(0,0,0,.35)
}
*{box-sizing:border-box}html,body{height:100%;max-width:100%;overflow-x:hidden}
body{background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;margin:0}
.container{max-width:var(--wrap);margin:16px auto;padding:0 max(16px, env(safe-area-inset-left))}
.card{background:linear-gradient(180deg,var(--panel),var(--panel-2));border:1px solid var(--line);border-radius:14px;padding:14px;box-shadow:0 10px 30px var(--shadow);margin-top:10px}
h1,h2,h3{margin:.1em 0}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.center{justify-content:center}
.col{display:flex;flex-direction:column;gap:10px;align-items:center}
.btn{appearance:none;border:1px solid var(--line);border-radius:12px;background:linear-gradient(180deg,#0e1520,#0c131c);color:var(--ink);padding:10px 14px;font-weight:800;cursor:pointer;min-height:44px;text-decoration:none;display:inline-flex;align-items:center;justify-content:center;text-align:center;white-space:normal;max-width:100%}
.btn.block{width:100%;max-width:360px}
.btn.small{font-weight:700;padding:6px 10px;min-height:32px;border-radius:10px}
.btn:disabled{opacity:.6;cursor:not-allowed}
.btn-green{ border-color:#14532d; background:linear-gradient(180deg,#0f1f16,#0b1510); }
.btn-blue{  border-color:#1e3a8a; background:linear-gradient(180deg,#0f172a,#0b1324); }
.btn-yellow{border-color:#713f12; background:linear-gradient(180deg,#1e1606,#191104); }
.btn-red{   border-color:#7f1d1d; background:linear-gradient(180deg,#1a0d0d,#140a0a); }
.glow-green{box-shadow:0 0 0 2px rgba(34,197,94,.25), 0 0 20px rgba(34,197,94,.18)}
.glow-yellow{box-shadow:0 0 0 2px rgba(245,158,11,.25), 0 0 20px rgba(245,158,11,.18)}
.glow-blue{box-shadow:0 0 0 2px rgba(37,99,235,.25), 0 0 20px rgba(37,99,235,.18)}
.status{font-size:13px;color:var(--muted)} .status.ok{color:var(--ok)} .status.err{color:var(--err)}
table{width:100%;border-collapse:collapse;margin-top:10px;font-size:14px}
th,td{padding:8px 10px;border-bottom:1px solid #1a2433;text-align:left;vertical-align:top}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
.hint{color:var(--muted);font-size:12.5px}
.warn{border-left:4px solid #d97706;background:linear-gradient(180deg,#231b0c,#1a140a);border:1px solid #3a2f18;border-radius:10px;padding:10px;color:#f3e8d0}
.badge{display:inline-block;padding:2px 8px;border:1px solid var(--line);border-radius:9999px;margin-left:8px}
.badge.testnet{background:#102018;color:#9fe29f;border-color:#2c4} .badge.mainnet{background:#181820;color:#cfd2ff;border-color:#44c}
.panel-note{border:1px dashed var(--line);border-radius:10px;padding:8px 10px;margin-top:8px}
.panel-note-green{border-color:#14532d;color:#22c55e}
.log{max-height:200px;overflow:auto;border:1px solid #1a2433;border-radius:10px;padding:8px;background:#0b111a;font-size:12px;white-space:pre-wrap}
.pill{display:inline-block;padding:2px 8px;border:1px solid var(--line);border-radius:9999px}
.H{background:rgba(34,197,94,.12);border-color:#165b34}
.C{background:rgba(245,158,11,.12);border-color:#8a5a09}
.R{background:rgba(239,68,68,.12);border-color:#7a2222}

/* Responsive tweaks */
@media (max-width: 720px) {
  .card h1, .card h2, .card h3, .card p.hint { text-align: center; }
  #healthWrap { overflow-x: auto; }
  #healthWrap table { min-width: 560px; }
}

/* Header grid */
.hero-top{display:grid;grid-template-columns:1fr auto 1fr;align-items:center}
.hero-top .left{justify-self:start}
.hero-top .center{justify-self:center}
.hero-top .right{justify-self:end;text-align:right}

/* Safe embed mode */
body.embed .container{max-width:none}
body.embed .card{border-radius:0;box-shadow:none;border:none;margin-top:0}
body.embed header{display:none}
  </style>

  <!-- Xaman SDK -->
  <script src="https://xaman.app/assets/cdn/xumm.min.js" crossorigin="anonymous"></script>
</head>
<body>
<noscript>
  <div class="card" style="max-width:var(--wrap);margin:16px auto;color:#fca5a5;border-color:#7f1d1d">
    This tool requires JavaScript to function. Please enable JavaScript to use wallet connect and scanning.
  </div>
</noscript>

<main class="container" aria-live="polite">

  <!-- PRIMARY -->
  <section class="card" id="primary" aria-labelledby="hero-title">
    <div class="hero-top">
      <div class="left">
        <img src="/xrbc-nft.png" alt="XRBC" width="32" height="32" style="border-radius:6px;border:1px solid var(--line)" loading="lazy" decoding="async">
      </div>
      <div class="center">
        <a class="btn glow-blue" href="/index.html" id="btnHome">Home</a>
      </div>
      <div class="right">
        <button id="btnNetBadge" class="btn small" type="button" disabled>Mainnet</button>
        <div class="row" style="margin-top:6px">
          <label class="hint" for="network">Network</label>
          <select id="network" aria-label="Network">
            <option value="mainnet" selected>Mainnet</option>
            <option value="testnet">Testnet</option>
          </select>
        </div>
      </div>
    </div>

    <div class="col" style="margin-top:8px">
      <h1 id="hero-title" style="margin:0">Liquidity Sentinel</h1>
      <p class="hint" style="margin:0">Scan AMM pool health for your trustlines with adjustable slippage probes, filters, and CSV export. Connect via Xaman. Desktop shows QR; mobile deep-links.</p>
    </div>

    <div class="row center" style="margin-top:10px">
      <button id="btnXumm" class="btn glow-green" type="button" title="Connect with Xaman wallet">Connect Xaman</button>
      <button id="btnDisconnect" class="btn glow-red" type="button" disabled>Disconnect</button>
      <span id="challengeBadge" class="badge" style="display:none" aria-live="polite" title="Human challenge code (also appears in wallet Memo)">••••••</span>
    </div>
    <p id="walletStatus" class="status">Status: Not connected</p>

    <div class="panel-note">
      <p class="hint" style="margin:0">No secrets are entered here. You review and sign in your wallet. We never custody funds.</p>
    </div>
  </section>

  <!-- LIQUIDITY HEALTH -->
  <section class="card" aria-labelledby="health">
    <h2 id="health" style="margin-top:0">Wallet Liquidity Health</h2>
    <p class="hint">Find XRP↔IOU pools for your trustlines, estimate slippage at two probes, and score each token.</p>

    <div class="row center" style="gap:8px">
      <button id="btnHealthScan" class="btn glow-blue" type="button" disabled>Scan Health</button>
      <button id="btnHealthRetry" class="btn small" type="button" title="Re-run health scan">Retry</button>

      <!-- Probe preset -->
      <label class="hint" style="display:flex;gap:8px;align-items:center">
        Probe:
        <select id="probePreset" aria-label="Slippage probe preset">
          <option value="small">Small (1 / 10 XRP)</option>
          <option value="standard" selected>Standard (10 / 100 XRP)</option>
        </select>
      </label>

      <!-- Filters -->
      <label class="hint" style="display:flex;gap:8px;align-items:center">
        <input id="riskOnly" type="checkbox"> Risk only
      </label>
      <label class="hint" style="display:flex;gap:8px;align-items:center">
        <input id="hideNoPool" type="checkbox"> Hide “No Pool”
      </label>

      <button id="btnExportCsv" class="btn small" type="button" title="Export table as CSV">Export CSV</button>
    </div>

    <div id="xrbcBadge" class="status" style="margin-top:8px"></div>
    <div id="healthStatus" class="status"></div>
    <div id="healthNote" class="hint" style="margin-top:8px">Connect wallet to enable scanning.</div>

    <div id="healthWrap" style="overflow:auto;margin-top:8px">
      <table id="healthTable" style="display:none">
        <thead>
          <tr>
            <th>Token</th>
            <th>Pool</th>
            <th>Reserves (XRP / IOU)</th>
            <th>Fee</th>
            <th id="slipHeader">Slippage (10 / 100 XRP)</th>
            <th>Score</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody id="healthBody"></tbody>
      </table>
    </div>
  </section>

  <!-- QUICK BUY (XRBC) -->
  <section class="card" aria-labelledby="buyxrbc">
    <h2 id="buyxrbc">Quick Buy · XRBitcoinCash (XRBC)</h2>
    <div class="panel-note" style="margin-top:8px;border:1px solid var(--line);border-left:4px solid #60a5fa;border-radius:10px;padding:10px 12px;background:linear-gradient(180deg,#0e1520,#0c131c);">
      <p class="hint" style="margin:0;color:#60a5fa;font-weight:700;">XRPL pathfinding with a <strong>2%</strong> cap. Review &amp; sign in Xaman. <strong>Trustline required.</strong></p>
    </div>
    <div class="col" style="margin-top:8px">
      <button class="btn btn-green glow-green block"  id="buy1"   type="button">Buy 1 XRBC for XRP</button>
      <button class="btn btn-blue glow-blue block"    id="buy25"  type="button">Buy 25 XRBC for XRP</button>
      <button class="btn btn-yellow glow-yellow block"id="buy50"  type="button">Buy 50 XRBC for XRP</button>
      <button class="btn btn-red glow-red block"      id="buy100" type="button">Buy 100 XRBC for XRP</button>
    </div>
    <div class="col" style="margin-top:10px">
      <button id="btnTrustXRBC" class="btn block" type="button">Add XRBC Trust Line (Allow Rippling)</button>
      <span class="hint">Issuer: <span class="mono" id="xrbcIssuerPill" style="display:inline-block;max-width:18ch;overflow-wrap:anywhere;word-break:break-all;vertical-align:top">rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw</span></span>
    </div>
    <p id="buyStatus" class="status"></p>
  </section>

  <!-- RESULTS -->
  <section class="card" aria-labelledby="res">
    <h2 id="res">Results</h2>
    <div id="resultBox" class="hint">Receipts will appear here.</div>
    <div class="panel-note" style="margin-top:10px">
      <div class="hint">Activity log</div>
      <pre id="log" class="log" aria-live="polite"></pre>
    </div>
  </section>

  <!-- EMBED -->
  <section class="card" aria-labelledby="embed">
    <h2 id="embed">Embed this tool on your site</h2>
    <p class="hint">Copy the snippet below. It renders an iframe in “embed mode.”</p>
    <div class="panel-note">
<pre id="embedCode" class="log" style="user-select:all;white-space:pre-wrap">&lt;div id="xrbc-widget" style="width:100%;max-width:1100px;margin:auto"&gt;&lt;/div&gt;
&lt;script&gt;(function(w,d,c,u,h){var el=d.getElementById(c)||d.body.appendChild(Object.assign(d.createElement('div'),{id:c}));
var f=d.createElement('iframe');f.src=u;f.style.width='100%';f.style.minHeight=h;f.style.border='0';f.loading='lazy';el.appendChild(f);
})(window,document,'xrbc-widget','https://xrbitcoincash.com/liquidity-sentinel.html?embed=1&amp;network=mainnet','780px');&lt;/script&gt;</pre>
    </div>
  </section>

  <!-- LEGAL -->
  <section class="card" aria-labelledby="important">
    <h2 id="important">Important</h2>
    <div class="warn">
      <p><strong>No custody / no brokerage.</strong> You construct & sign XRPL transactions in your own wallet. We don’t take possession of funds.</p>
      <p><strong>Finality & risk.</strong> XRPL transactions are irreversible. Verify asset, network, amounts, fees, and slippage in your wallet before approval.</p>
      <p><strong>No guarantees.</strong> Provided “AS IS.” You are responsible for legal compliance.</p>
    </div>
    <div id="license-proprietary" class="license" style="color:var(--muted);font-size:12px;white-space:pre-wrap;line-height:1.45;border-top:1px solid var(--line);padding-top:10px;margin-top:10px">
<strong>Proprietary License — Liquidity Sentinel (XRPL)</strong>
Copyright (c) 2025 XRBitcoinCash. All rights reserved.
    </div>
  </section>

</main>

<!-- App configuration (keep immediately before main script) -->
<script type="application/json" id="app-config">
{
  "proxyUrl": "https://xrbitcoincash-github-io.onrender.com",
  "xummApiKey": "f3efcfc9-90d0-4c06-b632-b4680f24c207",
  "networks": { "mainnet": { "label": "Mainnet" }, "testnet": { "label": "Testnet" } },
  "xrbc": {
    "issuer": "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw",
    "currencyHex": "5852626974636F696E6361736800000000000000"
  },
  "boot": { "autoResume": true, "autoLoadData": true, "refreshOnFocus": true }
}
</script>

<!-- Main script -->
<script>
(function(){
  'use strict';

  /* ===== Embed mode ===== */
  (function initEmbedMode(){
    try { const q=new URLSearchParams(location.search); if (q.get('embed')==='1') document.body.classList.add('embed'); } catch {}
  })();

  /* ===== CONFIG ===== */
  const cfg = JSON.parse(document.getElementById('app-config').textContent || '{}');
  const PROXY_BASE   = cfg.proxyUrl || '';
  const XUMM_API_KEY = cfg.xummApiKey || '';
  const XRBC         = cfg.xrbc || {};
  const BOOT         = cfg.boot || {};
  const XRP_TO_DROPS = 1_000_000;

  /* ===== STATE ===== */
  const state = { network:'mainnet', account:null, adapter:null };

  /* ===== DOM ===== */
  const $ = id => document.getElementById(id);
  const $walletStatus = $('walletStatus');
  const $btnXumm      = $('btnXumm');
  const $btnDisconnect= $('btnDisconnect');
  const $networkSel   = $('network');
  const $btnNetBadge  = $('btnNetBadge');
  const $log          = $('log');

  // Health
  const $btnHealthScan = $('btnHealthScan');
  const $btnHealthRetry= $('btnHealthRetry');
  const $probePreset   = $('probePreset');
  const $riskOnly      = $('riskOnly');
  const $hideNoPool    = $('hideNoPool');
  const $healthStatus  = $('healthStatus');
  const $healthTable   = $('healthTable');
  const $healthBody    = $('healthBody');
  const $healthNote    = $('healthNote');
  const $slipHeader    = $('slipHeader');
  const $xrbcBadge     = $('xrbcBadge');
  const $btnExportCsv  = $('btnExportCsv');

  // Quick Buy
  const $buyStatus = $('buyStatus');

  /* ===== UTILS ===== */
  function log(s){ if($log){ $log.textContent += s + '\\n'; $log.scrollTop = $log.scrollHeight; } }
  function setStatus(node,text,cls){
    if(!node) return; node.textContent=text; node.classList.remove('ok','err'); if(cls) node.classList.add(cls);
    if(node===$walletStatus) log('[wallet] '+text);
    else if(node===$healthStatus) log('[health] '+text);
    else if(node===$buyStatus) log('[buy] '+text);
  }
  const N=v=>Number.isFinite(Number(v))?Number(v):0;
  const isXRP=a=>typeof a==='string'||(a&&a.currency==='XRP');

  function updateNetUI(){
    const s = state.network==='testnet'?'Testnet':'Mainnet';
    if($btnNetBadge){ $btnNetBadge.textContent=s; $btnNetBadge.className='btn small badge ' + (s==='Testnet'?'testnet':'mainnet'); }
  }
  function proxyUrl(){ return PROXY_BASE + (state.network==='testnet' ? '?network=testnet' : ''); }
  function updateConnectButtons(){
    const connected = Boolean(state.account && state.adapter);
    if($btnXumm){ $btnXumm.disabled = connected; $btnXumm.style.display = connected ? 'none' : ''; $btnXumm.textContent='Connect Xaman'; }
    if($btnDisconnect){ $btnDisconnect.disabled = !connected; $btnDisconnect.style.display = connected ? '' : 'none'; }
    if($btnHealthScan){ $btnHealthScan.disabled = !connected; }
  }

  function asciiToHex(s){ let out=''; for(let i=0;i<s.length;i++){ out += s.charCodeAt(i).toString(16).padStart(2,'0'); } return out.toUpperCase(); }
  let __LS_CHALLENGE = null;
  function newChallenge6(){ return String(Math.floor(100000 + Math.random()*900000)); }
  function setChallengeBadge(code){
    const el = $('challengeBadge'); if(!el) return;
    if(!code){ el.style.display='none'; el.textContent=''; return; }
    el.textContent = code; el.style.display = 'inline-block';
  }
  function buildMemos(){
    const app = 'Sentinel Liquidity Health';
    const ch  = __LS_CHALLENGE || newChallenge6();
    __LS_CHALLENGE = ch;
    return [
      { Memo: { MemoType: asciiToHex('APP'),       MemoData: asciiToHex(app) } },
      { Memo: { MemoType: asciiToHex('CHALLENGE'), MemoData: asciiToHex(ch)  } },
      { Memo: { MemoType: asciiToHex('DOMAIN'),    MemoData: asciiToHex('xrbitcoincash.com') } }
    ];
  }
  function attachMemos(tx){
    try{
      const m = buildMemos();
      tx.Memos = Array.isArray(tx.Memos) ? tx.Memos.concat(m) : m;
    }catch{}
    return tx;
  }

  /* ===== XRPL PROXY ===== */
  async function xrplRequest(payload,{timeoutMs=12000}={}){
    if(!PROXY_BASE) throw new Error('Proxy URL missing');
    const ctrl=new AbortController(); const t=setTimeout(()=>ctrl.abort(),timeoutMs);
    try{
      const res=await fetch(proxyUrl(),{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload), signal:ctrl.signal, redirect:'error', cache:'no-store', credentials:'omit' });
      if(!res.ok) throw new Error('Proxy HTTP '+res.status);
      const data=await res.json(); if(data && data.error) throw new Error('XRPL '+(data.error?.message||'error')); return data;
    } finally { clearTimeout(t); }
  }
  async function call(method,params){ const r=await xrplRequest({method,params:[{...params,ledger_index:'validated'}]}); return r?.result; }

  /* ===== Account helpers ===== */
  async function getAccountInfo(acct){ const r=await call('account_info',{account:acct}); return r?.account_data||{}; }
  async function listUserTokens(acct){
    const out = [];
    try{
      const r = await call('account_lines', { account: acct, limit: 400 });
      for(const l of (r?.lines || [])){
        const bal = Number(l.balance || 0);
        if (bal > 0) out.push({
          code: (l.currency || '').toString().toUpperCase(),
          issuer: l.account || l.issuer || l.account,
          balance: bal
        });
      }
    }catch{}
    return out;
  }
  function hexToAscii(hex){
    try{
      const clean = hex.replace(/[^0-9A-F]/gi,'').toUpperCase();
      if(clean.length%2!==0 || clean.length<2) return null;
      let out=''; for(let i=0;i<clean.length;i+=2){ const b=parseInt(clean.slice(i,i+2),16); if(!b) break; if(b<32 || b>126) return null; out+=String.fromCharCode(b); }
      return out || null;
    }catch{ return null; }
  }
  function tokenDisplay(code){
    const isHex = /^[0-9A-F]{10,}$/.test(code);
    if(!isHex) return { ticker: code, hex: null, label: code };
    const ascii = hexToAscii(code);
    if(ascii) return { ticker: ascii, hex: code, label: `${ascii} (${code})` };
    return { ticker: null, hex: code, label: code };
  }

  /* ===== AMM helpers ===== */
  async function ammInfoXrpIou(currencyHex, issuer){
    try{
      const r = await xrplRequest({ method:'amm_info', params:[{ asset:{currency:'XRP'}, asset2:{currency:currencyHex, issuer} }] });
      return r?.result?.amm || null;
    }catch{ return null; }
  }
  function estSlippageXrpToIou(xrpIn, xrpRes, iouRes){
    if (xrpIn <= 0 || xrpRes <= 0 || iouRes <= 0) return {dy:0, slip:0};
    const dy = (iouRes * xrpIn) / (xrpRes + xrpIn);
    const spot = iouRes / xrpRes;
    const eff = dy / xrpIn;
    const slip = Math.max(0, (spot - eff) / spot);
    return {dy, slip};
  }
  function scoreHealth({poolExists, xrpRes, fee, slipA, slipB, ledgerFresh}){
    let score = 0;
    if (poolExists) score += 1;
    if (xrpRes >= 500) score += 2; else if (xrpRes >= 100) score += 1;
    if (fee <= 0.3) score += 1; else if (fee <= 0.5) score += 0; else score -= 1;
    if (slipA <= 0.01) score += 2; else if (slipA <= 0.03) score += 1;
    if (slipB <= 0.03) score += 2; else if (slipB <= 0.10) score += 1;
    if (ledgerFresh) score += 1;
    let status = "Caution", cls="C";
    if (score >= 6) { status="Healthy"; cls="H"; }
    else if (score <= 2) { status="Risk"; cls="R"; }
    return {score, status, cls};
  }

  /* ===== Health scan ===== */
  async function refreshHealth(){
    if (!$healthBody) return;
    if (!state.account){ $healthNote.textContent='Connect wallet to enable scanning.'; return; }

    $healthBody.innerHTML=''; $healthTable.style.display='none';
    setStatus($healthStatus,'Fetching trustlines…');

    const srv = await call('server_state',{}).catch(()=>null);
    const ledgerFresh = !!(srv && srv.validated_ledger);

    const linesR = await call('account_lines',{account:state.account,limit:400}).catch(()=>null);
    const lines = (linesR && linesR.lines) ? linesR.lines : [];

    if (!lines.length){
      $healthNote.textContent='No trustlines found. You can still hold XRP without trustlines.';
      setStatus($healthStatus,'', ''); return;
    }

    // Probe sizes
    const preset = $probePreset?.value || 'standard';
    const PROBE_A = preset === 'small' ? 1 : 10;
    const PROBE_B = preset === 'small' ? 10 : 100;
    if ($slipHeader) $slipHeader.textContent = `Slippage (${PROBE_A} / ${PROBE_B} XRP)`;

    setStatus($healthStatus,`Found ${lines.length} trustlines. Checking pools with ${PROBE_A}/${PROBE_B} XRP probes…`);

    const XRBC_HEX = (XRBC.currencyHex||'').toUpperCase();
    let xrbcRow = null;
    const rows = [];

    for (const l of lines){
      const currencyHex = (l.currency||'').toUpperCase();
      const issuer = l.account || l.issuer;
      if (!currencyHex || !issuer) continue;

      const amm = await ammInfoXrpIou(currencyHex, issuer);
      if (!amm){
        const r = {
          token: tokenDisplay(currencyHex).label + ` (${issuer.slice(0,6)}…${issuer.slice(-4)})`,
          pool: 'XRP/IOU',
          xrpRes: '-', iouRes: '-', fee: '-',
          slipA: '-', slipB: '-', score: 0, status:'No Pool', cls:'R'
        };
        if (currencyHex===XRBC_HEX && issuer===XRBC.issuer) xrbcRow = r;
        rows.push(r);
        continue;
      }

      // XRP reserve can arrive as drops string
      let xrpRes = 0;
      let iouRes = 0;
      if (typeof amm.amount === 'string') xrpRes = Number(amm.amount) / 1_000_000;
      else if (amm.amount && typeof amm.amount.value !== 'undefined') xrpRes = Number(amm.amount.value);
      if (amm.amount2 && typeof amm.amount2.value !== 'undefined') iouRes = Number(amm.amount2.value);

      const feeBps = typeof amm.trading_fee === 'number' ? amm.trading_fee : 30;
      const feePct = feeBps/100;

      const sA = estSlippageXrpToIou(PROBE_A, xrpRes, iouRes);
      const sB = estSlippageXrpToIou(PROBE_B, xrpRes, iouRes);

      const health = scoreHealth({
        poolExists:true, xrpRes, fee: feePct, slipA: sA.slip, slipB: sB.slip, ledgerFresh
      });

      const r = {
        token: tokenDisplay(currencyHex).label + ` (${issuer.slice(0,6)}…${issuer.slice(-4)})`,
        pool: 'XRP/IOU',
        xrpRes: xrpRes.toFixed(2),
        iouRes: iouRes.toFixed(2),
        fee: feePct.toFixed(2) + '%',
        slipA: (sA.slip*100).toFixed(2) + '%',
        slipB: (sB.slip*100).toFixed(2) + '%',
        score: health.score,
        status: health.status,
        cls: health.cls
      };
      if (currencyHex===XRBC_HEX && issuer===XRBC.issuer) xrbcRow = r;
      rows.push(r);
    }

    if (xrbcRow){
      $xrbcBadge.innerHTML = `<span class="pill ${xrbcRow.cls}">${xrbcRow.status}</span> · Score ${xrbcRow.score} · ${xrbcRow.xrpRes} XRP reserves`;
    } else {
      $xrbcBadge.textContent = "XRBC not detected in this wallet (or no XRBC pool found).";
    }

    if (!rows.length){
      $healthNote.textContent = 'No pools found for this account’s trustlines (or pools unavailable).';
      setStatus($healthStatus,'Done.');
      return;
    }

    // Render rows
    $healthBody.innerHTML = rows.map(r => `
      <tr data-status="${r.status}">
        <td class="mono">${r.token}</td>
        <td>${r.pool}</td>
        <td>${r.xrpRes} XRP / ${r.iouRes}</td>
        <td>${r.fee}</td>
        <td>${r.slipA} / ${r.slipB}</td>
        <td class="mono">${r.score}</td>
        <td><span class="pill ${r.cls}">${r.status}</span></td>
      </tr>
    `).join("");
    $healthTable.style.display='';

    applyFilters();
    setStatus($healthStatus,'Done.','ok');
    $healthNote.textContent = '';
  }

  function applyFilters(){
    const riskOnly = $riskOnly?.checked;
    const hideNoPool = $hideNoPool?.checked;
    const rows = $healthBody?.querySelectorAll('tr') || [];
    rows.forEach(tr=>{
      const status = tr.getAttribute('data-status') || '';
      let show = true;
      if (riskOnly && status !== 'Risk') show = false;
      if (hideNoPool && status === 'No Pool') show = false;
      tr.style.display = show ? '' : 'none';
    });
  }

  function downloadCsvFromTable(){
    if (!$healthTable || $healthTable.style.display === 'none') return;
    const rows = [...$healthTable.querySelectorAll('tr')];
    if (!rows.length) return;

    const csv = rows.map(tr=>{
      const cells = [...tr.children];
      return cells.map(td=>{
        // strip commas/newlines, keep text content
        const t = (td.textContent || '').replace(/\\s+/g,' ').trim();
        // CSV escape
        return '"' + t.replace(/"/g,'""') + '"';
      }).join(',');
    }).join('\\n');

    const now = new Date();
    const y = now.getFullYear();
    const m = String(now.getMonth()+1).padStart(2,'0');
    const d = String(now.getDate()).padStart(2,'0');
    const hh= String(now.getHours()).padStart(2,'0');
    const mm= String(now.getMinutes()).padStart(2,'0');
    const ss= String(now.getSeconds()).padStart(2,'0');

    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `liquidity-health_${y}${m}${d}_${hh}${mm}${ss}.csv`;
    document.body.appendChild(a); a.click(); a.remove();
  }

  /* ===== Wallet adapters ===== */
  class WalletAdapter { name='Base'; async connect(){throw new Error('not implemented');} async signAndSubmit(_tx){throw new Error('not implemented');} async disconnect(){} }
  class XummAdapter extends WalletAdapter{
    constructor(){ super(); this.name='Xaman'; this.xumm=null; }
    async ensureSDK(){ if(typeof Xumm==='undefined') throw new Error('Xaman SDK not loaded'); if(!XUMM_API_KEY) throw new Error('Xaman API key missing'); if(!this.xumm) this.xumm=new Xumm(XUMM_API_KEY); }
    async resume(){
      await this.ensureSDK();
      const acct = await this.xumm.user.account;
      if(acct){ return { address: acct }; }
      return null;
    }
    async connect(){
      await this.ensureSDK();
      await this.xumm.authorize();
      const acct=await this.xumm.user.account;
      if(!acct) throw new Error('No account returned');
      return { address: acct };
    }
    async signAndSubmit(txjson){
      const { resolved, websocket, unsubscribe } = await this.xumm.payload.createAndSubscribe(
        { txjson, options:{ submit:true, expire:300 } },
        ev => {
          if (ev?.opened) setStatus($walletStatus,'Open Xaman to review & sign…');
          if (ev?.signed === false) setStatus($walletStatus,'Canceled in wallet.','err');
        }
      );
      const res = await resolved;
      try{ websocket?.close(); }catch{}
      try{ typeof unsubscribe==='function' && unsubscribe(); }catch{}
      if(!res?.signed) throw new Error('User rejected');
      return { hash: res?.txid || res?.id || '(pending)', result:'submitted' };
    }
    async disconnect(){ try{ await this.xumm?.logout(); }catch{} }
  }

  /* ===== Connect helpers ===== */
  function setAdapter(ad){ state.adapter = ad; updateConnectButtons(); }
  async function refreshAll(){
    if(!state.account) return;
    await refreshHealth().catch(e=>setStatus($healthStatus, e?.message||'Health error','err'));
  }
  async function connectWith(AdapterClass){
    try{
      setStatus($walletStatus,'Connecting…');
      const ad = new AdapterClass();
      const { address } = await ad.connect();
      state.account = address; setAdapter(ad);
      localStorage.setItem('xrbc.lastAccount', address);
      setStatus($walletStatus, ad.name+': '+address, 'ok');
      __LS_CHALLENGE = newChallenge6(); setChallengeBadge(__LS_CHALLENGE);
      await refreshAll();
    }catch(e){
      setStatus($walletStatus,(e && e.message) || 'Connect failed','err');
    } finally { updateConnectButtons(); }
  }
  async function tryResumeWallet(){
    try{
      const ad = new XummAdapter();
      const resumed = await ad.resume();
      if(resumed && resumed.address){
        state.account = resumed.address; setAdapter(ad);
        setStatus($walletStatus, ad.name+': '+resumed.address, 'ok');
        __LS_CHALLENGE = newChallenge6(); setChallengeBadge(__LS_CHALLENGE);
        await refreshAll();
      } else {
        const cached = localStorage.getItem('xrbc.lastAccount');
        if(cached){ state.account = cached; setStatus($walletStatus,'Previously connected: '+cached,'ok'); updateConnectButtons(); }
      }
    } catch(e){}
  }
  async function disconnect(){
    try{ await state.adapter?.disconnect?.(); }catch{}
    state.account=null; state.adapter=null;
    localStorage.removeItem('xrbc.lastAccount');
    setChallengeBadge('');
    setStatus($walletStatus,'Status: Not connected');
    setStatus($healthStatus,''); $healthBody.innerHTML=''; $healthTable.style.display='none'; $healthNote.textContent='Connect wallet to enable scanning.';
    updateConnectButtons();
  }

  /* ===== Quick Buy (XRBC) ===== */
  const XRBC_HEX=(XRBC.currencyHex||'').toUpperCase();
  function hexToAsciiLoose(hex){ try{ let out=''; for(let i=0;i<hex.length;i+=2){ const b=parseInt(hex.slice(i,i+2),16); if(!b) break; out+=String.fromCharCode(b);} return out||'XRBC'; }catch{ return 'XRBC'; } }
  const XRBC_CODE=hexToAsciiLoose(XRBC_HEX);

  async function hasXRBCTrustLine(acct){
    const r=await call('account_lines',{account:acct,peer:XRBC.issuer,limit:400});
    const lines=r?.lines||[]; return lines.some(l=>((l.currency||'').toUpperCase()===XRBC_CODE.toUpperCase())||((l.currency||'').toUpperCase()===XRBC_HEX));
  }

  async function addXRBCTrustLine(){
    if(!state.account || !state.adapter){ setStatus($buyStatus,'Connect wallet first.','err'); return; }
    setStatus($buyStatus,'Checking trust line…');
    try{
      const exists=await hasXRBCTrustLine(state.account);
      if(exists){ setStatus($buyStatus,'XRBC trust line already exists.','ok'); return; }
      __LS_CHALLENGE = newChallenge6(); setChallengeBadge(__LS_CHALLENGE);
      const tx = attachMemos({
        TransactionType:'TrustSet',
        Account: state.account,
        LimitAmount: { currency: XRBC_HEX, issuer: XRBC.issuer, value: "1000000000" },
        Flags: 0x00040000 /* tfClearNoRipple: allow rippling */
      });
      const res = await state.adapter.signAndSubmit(tx);
      setStatus($buyStatus,'TrustSet submitted. Wait for validation, then retry buy.','ok');
      log('tx hash: ' + (res.hash || '(pending)'));
    }catch(e){ setStatus($buyStatus,'TrustSet error: '+(e.message||e),'err'); }
  }

  async function pathFindBuy(acct, valueStr){
    const AMOUNT = { currency: XRBC_HEX, issuer: XRBC.issuer, value: valueStr };
    const pfWrap = await xrplRequest({
      method:'ripple_path_find',
      params:[{ source_account:acct, destination_account:acct, destination_amount:AMOUNT, source_currencies:[{currency:"XRP"}] }]
    }, { timeoutMs: 15000 });
    const alts = pfWrap?.result?.alternatives || [];
    if (!alts.length) throw new Error('No path found');

    let best = null;
    for (const a of alts){
      const sa = a.source_amount;
      const drops = typeof sa === 'string'
        ? N(sa)
        : (sa && sa.currency === 'XRP' ? Math.round(N(sa.value) * XRP_TO_DROPS) : Infinity);
      if (!isFinite(drops)) continue;
      if (!best || drops < best.drops) best = { alt: a, drops };
    }
    if (!best) throw new Error('No XRP route');
    const headroom = Math.ceil(best.drops * 1.02); // 2% cap
    return { TransactionType:'Payment', Account:acct, Destination:acct, Amount:AMOUNT, SendMax:String(headroom), Paths: best.alt.paths_computed || [] };
  }

  async function buyXRBC(units){
    if (!state.account || !state.adapter){ setStatus($buyStatus,'Connect wallet first.','err'); return; }
    try{
      setStatus($buyStatus,`Preparing to buy ${units} ${XRBC_CODE}…`);
      const exists = await hasXRBCTrustLine(state.account);
      if (!exists){ setStatus($buyStatus,'No XRBC trust line. Use “Add XRBC Trust Line” first.','err'); return; }

      __LS_CHALLENGE = newChallenge6(); setChallengeBadge(__LS_CHALLENGE);

      const txRaw = await pathFindBuy(state.account, String(units));
      const tx = attachMemos(txRaw);
      const res = await state.adapter.signAndSubmit(tx);
      setStatus($buyStatus,`Buy submitted. Hash: ${res && res.hash ? res.hash : '(pending)'}`,'ok');
    }catch(e){
      setStatus($buyStatus,(e && e.message) || 'Buy failed','err');
    }
  }

  /* ===== Wire UI ===== */
  document.getElementById('btnTrustXRBC')?.addEventListener('click',()=>addXRBCTrustLine());
  document.getElementById('buy1')?.addEventListener('click',()=>buyXRBC(1));
  document.getElementById('buy25')?.addEventListener('click',()=>buyXRBC(25));
  document.getElementById('buy50')?.addEventListener('click',()=>buyXRBC(50));
  document.getElementById('buy100')?.addEventListener('click',()=>buyXRBC(100));

  document.getElementById('btnXumm')?.addEventListener('click',()=>connectWith(XummAdapter));
  document.getElementById('btnDisconnect')?.addEventListener('click',()=>disconnect());
  document.getElementById('network')?.addEventListener('change',()=>{ state.network = (document.getElementById('network').value==='testnet') ? 'testnet' : 'mainnet'; updateNetUI(); if(state.account){ refreshAll(); } });

  if ($btnHealthScan) $btnHealthScan.addEventListener('click', ()=>{ refreshHealth().catch(e=>setStatus($healthStatus, e?.message||'Health error','err')); });
  if ($btnHealthRetry) $btnHealthRetry.addEventListener('click', ()=>{ refreshHealth().catch(e=>setStatus($healthStatus, e?.message||'Health error','err')); });
  if ($probePreset) $probePreset.addEventListener('change', ()=>{ if(state.account){ refreshHealth(); } else { const preset=$probePreset.value==='small'?'1/10':'10/100'; $slipHeader.textContent=`Slippage (${preset.replace('/',' / ')} XRP)`; } });
  if ($riskOnly) $riskOnly.addEventListener('change', applyFilters);
  if ($hideNoPool) $hideNoPool.addEventListener('change', applyFilters);
  if ($btnExportCsv) $btnExportCsv.addEventListener('click', downloadCsvFromTable);

  /* ===== Boot ===== */
  updateNetUI();
  if (BOOT.autoResume !== false) { tryResumeWallet().finally(()=>updateConnectButtons()); }
  if (BOOT.autoLoadData !== false) { setTimeout(()=>{ if(state.account){ refreshAll(); } }, 400); }
  if (BOOT.refreshOnFocus) {
    document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible' && state.account) refreshAll(); });
    window.addEventListener('focus', () => { if (state.account) refreshAll(); });
  }
})();
</script>
</body>
</html>
