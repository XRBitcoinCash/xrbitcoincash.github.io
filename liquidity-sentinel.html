<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>XRBitcoinCash · Sentinel Safety Tools</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="light dark" />
  <meta name="theme-color" content="#0b0f14" />
  <link rel="icon" href="/xrbc-nft.png" />

  <style>
    /* Minimal neutral styles so the IDs render; keep your project CSS as-is */
    :root{--ink:#e7edf5;--muted:#9fb0c5;--line:#2b3a4b;--bg:#0b0f14}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.5 system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif}
    .container{max-width:1100px;margin:16px auto;padding:0 16px}
    h1{margin:12px 0 8px}
    .row{display:grid;grid-template-columns:1fr;gap:12px}
    .card{border:1px solid var(--line);border-radius:12px;padding:12px;background:rgba(255,255,255,0.02)}
    .btn{border:1px solid var(--line);background:transparent;color:var(--ink);padding:8px 12px;border-radius:8px;cursor:pointer}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .btn.small{padding:4px 8px;font-size:12px}
    .badge{border-radius:999px}
    table{width:100%;border-collapse:collapse}
    th,td{border-bottom:1px solid var(--line);padding:8px;text-align:left}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .hint{color:var(--muted)}
    .status.ok{color:#22c55e}.status.err{color:#ef4444}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--line)}
    .pill.H{border-color:#22c55e;color:#22c55e}
    .pill.C{border-color:#f59e0b;color:#f59e0b}
    .pill.R{border-color:#ef4444;color:#ef4444}
    #progressBar{height:4px;background:#22c55e;width:0;border-radius:3px}
    pre{white-space:pre-wrap}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .right{margin-left:auto}
    .badge.mainnet{border-color:#22c55e}
    .badge.testnet{border-color:#f59e0b}
    #challengeBadge{display:none;border:1px dashed var(--line);padding:0 8px;border-radius:8px;margin-left:8px}
  </style>
</head>
<body>

  <div class="container">
    <header class="card">
      <div class="toolbar">
        <h1 style="margin:0">XRBitcoinCash · Sentinel</h1>
        <span id="challengeBadge" class="mono"></span>
        <span class="right"></span>
        <select id="network" class="btn small">
          <option value="mainnet" selected>Mainnet</option>
          <option value="testnet">Testnet</option>
        </select>
        <button id="btnNetBadge" class="btn small badge mainnet">Mainnet</button>
        <button id="btnXumm" class="btn">Connect Xaman</button>
        <button id="btnDisconnect" class="btn" style="display:none" disabled>Disconnect</button>
      </div>
      <div id="walletStatus" class="status mono hint">Status: Not connected</div>
      <div id="progressBar"></div>
      <div class="toolbar" style="margin-top:8px">
        <button id="btnCopyChallenge" class="btn small">Copy code</button>
        <button id="btnClearLog" class="btn small">Clear log</button>
      </div>
    </header>

    <section class="row" style="margin-top:12px">
      <!-- Offers -->
      <div class="card">
        <h2 style="margin-top:0">Open Orders</h2>
        <div id="offersStatus" class="status mono hint"></div>
        <div id="offersWrap" class="mono hint">No data yet.</div>
        <div id="resultBox" class="mono" style="margin-top:8px"></div>
      </div>

      <!-- Quick Buy + Trustline -->
      <div class="card">
        <h2 style="margin-top:0">XRBC Trust & Quick Buy</h2>
        <div class="toolbar">
          <button id="btnTrustXRBC" class="btn">Add XRBC Trust Line</button>
          <button id="buy1" class="btn">Buy 1 XRBC</button>
          <button id="buy25" class="btn">Buy 25 XRBC</button>
          <button id="buy50" class="btn">Buy 50 XRBC</button>
          <button id="buy100" class="btn">Buy 100 XRBC</button>
        </div>
        <div id="buyStatus" class="status mono hint" style="margin-top:8px"></div>
      </div>

      <!-- Stop-Loss Planner -->
      <div class="card">
        <h2 style="margin-top:0">Stop-Loss Planner</h2>
        <div id="slTokens" class="mono hint">Connect wallet first.</div>
        <div class="toolbar" style="margin-top:8px;gap:12px">
          <label>Mode:
            <select id="slMode" class="btn small">
              <option value="pct" selected>% drop from current</option>
              <option value="abs">Absolute price</option>
            </select>
          </label>
          <label>Value:
            <input id="slValue" type="number" class="btn small" step="0.000001" style="min-width:120px" placeholder="e.g. 10 for 10%">
          </label>
          <label>Target:
            <select id="slTarget" class="btn small">
              <option value="XRP" selected>XRP</option>
              <option value="RLUSD">RLUSD</option>
            </select>
          </label>
          <button id="btnPlanStops" class="btn">Plan Stops</button>
          <button id="btnCreateStops" class="btn" disabled>Create Stops</button>
        </div>
        <pre id="slPlanOut" class="mono" style="margin-top:8px"></pre>
        <div id="slStatus" class="status mono hint" style="margin-top:8px"></div>
      </div>

      <!-- Panic -->
      <div class="card">
        <h2 style="margin-top:0">Panic: Sell All IOUs → Selected Target</h2>
        <div class="toolbar" style="gap:12px">
          <label>Target:
            <select id="panicTarget" class="btn small">
              <option value="XRP" selected>XRP</option>
              <option value="RLUSD">RLUSD</option>
            </select>
          </label>
          <label>Slippage %:
            <input id="panicSlip" type="number" class="btn small" step="0.1" value="2" style="min-width:80px">
          </label>
          <label><input id="panicCancelFirst" type="checkbox"> Cancel open offers first</label>
          <button id="btnPanicPreview" class="btn">Preview</button>
          <button id="btnPanicSell" class="btn">Execute</button>
        </div>
        <pre id="panicPlanOut" class="mono" style="margin-top:8px"></pre>
        <div id="panicStatus" class="status mono hint" style="margin-top:8px"></div>
      </div>

      <!-- Health -->
      <div class="card">
        <h2 style="margin-top:0">Health Scan</h2>
        <div class="toolbar">
          <button id="btnHealthScan" class="btn" disabled>Scan Now</button>
          <button id="btnHealthRetry" class="btn">Retry</button>
          <label><input id="riskOnly" type="checkbox"> Show Risk only</label>
          <span id="xrbcBadge" class="mono hint"></span>
        </div>
        <div id="healthStatus" class="status mono hint" style="margin-top:8px"></div>
        <div id="healthNote" class="mono hint">Connect wallet to enable scanning.</div>
        <div style="overflow:auto;margin-top:8px">
          <table id="healthTable" style="display:none">
            <thead>
              <tr>
                <th>Token</th><th>Pool</th><th>Reserves</th><th>Fee</th><th>Slip 10/100</th><th>Score</th><th>Status</th>
              </tr>
            </thead>
            <tbody id="healthBody"></tbody>
          </table>
        </div>
      </div>

      <!-- Log -->
      <div class="card">
        <h2 style="margin-top:0">Log</h2>
        <pre id="log" class="mono" style="max-height:240px;overflow:auto"></pre>
      </div>
    </section>

    <footer class="card" style="margin-top:12px">
      <small class="mono">© <span id="copyrightYear">2025</span> XRBitcoinCash</small>
    </footer>
  </div>

  <!-- App configuration (keep immediately before main script) -->
  <script type="application/json" id="app-config">
  {
    "proxyUrl": "https://xrbitcoincash-github-io.onrender.com",
    "xummApiKey": "f3efcfc9-90d0-4c06-b632-b4680f24c207",
    "networks": { "mainnet": { "label": "Mainnet" }, "testnet": { "label": "Testnet" } },
    "xrbc": {
      "issuer": "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw",
      "currencyHex": "5852626974636F696E6361736800000000000000"
    },
    "boot": { "autoResume": true, "autoLoadData": true, "refreshOnFocus": true }
  }
  </script>

  <!-- Main script (merged: wallet connect + offers + stop-loss + panic + quick-buy + health + challenge memos + risk filter + UX helpers) -->
  <script>
  (function(){
    'use strict';

    const FIRST_COMMIT_YEAR = 2025;

    /* ===== Embed mode ===== */
    (function initEmbedMode(){
      try { const q=new URLSearchParams(location.search); if (q.get('embed')==='1') document.body.classList.add('embed'); } catch {}
    })();

    /* ===== Copy embed code ===== */
    (function initCopy(){
      const btn=document.getElementById('btnCopyIframe'); const pre=document.getElementById('embedCode');
      if(!btn||!pre) return;
      btn.addEventListener('click', async ()=>{
        try{ await navigator.clipboard.writeText(pre.textContent); btn.textContent='Copied'; setTimeout(()=>btn.textContent='Copy embed code',1200); }
        catch{
          const r=document.createRange(); r.selectNode(pre); const sel=window.getSelection();
          sel.removeAllRanges(); sel.addRange(r); document.execCommand('copy'); sel.removeAllRanges();
          btn.textContent='Copied'; setTimeout(()=>btn.textContent='Copy embed code',1200);
        }
      });
    })();

    /* ===== CONFIG ===== */
    const cfg = JSON.parse(document.getElementById('app-config').textContent || '{}');
    const PROXY_BASE   = cfg.proxyUrl || '';
    const XUMM_API_KEY = cfg.xummApiKey || '';
    const XRBC         = cfg.xrbc || {};
    const BOOT         = cfg.boot || {};
    const XRP_TO_DROPS = 1_000_000;

    /* ===== STATE ===== */
    const state = { network:'mainnet', account:null, adapter:null, offers:[], lastAccountInfo:null };

    /* ===== DOM ===== */
    const $ = id => document.getElementById(id);
    const $walletStatus = $('walletStatus');
    const $offersStatus = $('offersStatus');
    const $offersWrap   = $('offersWrap');
    const $resultBox    = $('resultBox');
    const $log          = $('log');
    const $btnXumm      = $('btnXumm');
    const $btnDisconnect= $('btnDisconnect');
    const $networkSel   = $('network');
    const $btnNetBadge  = $('btnNetBadge');
    const $progress     = $('progressBar'); // optional
    const $buyStatus    = $('buyStatus');

    // Stop-Loss & Panic
    const $slTokens = $('slTokens');
    const $slMode   = $('slMode');
    const $slValue  = $('slValue');
    const $slTarget = $('slTarget');
    const $slPlanOut= $('slPlanOut');
    const $slStatus = $('slStatus');

    const $panicTarget    = $('panicTarget');
    const $panicSlip      = $('panicSlip');
    const $panicCancelFirst = $('panicCancelFirst');
    const $panicPlanOut   = $('panicPlanOut');
    const $panicStatus    = $('panicStatus');
    const $btnPanicPreview= $('btnPanicPreview');
    const $btnPanicSell   = $('btnPanicSell');

    // Health
    const $btnHealthScan = $('btnHealthScan');
    const $healthStatus  = $('healthStatus');
    const $healthTable   = $('healthTable');
    const $healthBody    = $('healthBody');
    const $healthNote    = $('healthNote');
    const $xrbcBadge     = $('xrbcBadge');
    const $riskOnly      = $('riskOnly');
    const $btnHealthRetry= $('btnHealthRetry');

    // UX helpers (Patch B)
    const $btnCopyChallenge = $('btnCopyChallenge');
    const $btnClearLog      = $('btnClearLog');

    /* ===== UTILS ===== */
    function log(s){ if($log){ $log.textContent += s + '\n'; $log.scrollTop = $log.scrollHeight; } }
    function setStatus(node,text,cls){
      if(!node) return; node.textContent=text; node.classList.remove('ok','err'); if(cls) node.classList.add(cls);
      if(node===$walletStatus) log('[wallet] '+text);
      else if(node===$slStatus) log('[stop] '+text);
      else if(node===$panicStatus) log('[panic] '+text);
      else if(node===$healthStatus) log('[health] '+text);
    }
    const N=v=>Number.isFinite(Number(v))?Number(v):0;
    const isXRP=a=>typeof a==='string'||(a&&a.currency==='XRP');
    const fmtDrops=d=>(N(d)/XRP_TO_DROPS).toFixed(6)+' XRP';
    const amtStr=a=>isXRP(a)?fmtDrops(a):(Number(a.value).toFixed(6)+' '+(a.currency||'IOU'));
    const price=(gets,pays)=>{ const g=isXRP(gets)?N(gets)/XRP_TO_DROPS:N(gets.value); const p=isXRP(pays)?N(pays)/XRP_TO_DROPS:N(pays.value); return g>0?(p/g).toFixed(6):'—'; };
    function setProgress(pct){ if($progress) $progress.style.width=Math.max(0,Math.min(100,pct))+'%'; }
    function updateNetUI(){
      const s = state.network==='testnet'?'Testnet':'Mainnet';
      if($btnNetBadge){ $btnNetBadge.textContent=s; $btnNetBadge.className='btn small badge ' + (s==='Testnet'?'testnet':'mainnet'); }
    }
    function proxyUrl(){ return PROXY_BASE + (state.network==='testnet' ? '?network=testnet' : ''); }
    function updateConnectButtons(){
      const connected = Boolean(state.account && state.adapter);
      if($btnXumm){ $btnXumm.disabled = connected; $btnXumm.style.display = connected ? 'none' : ''; $btnXumm.textContent='Connect Xaman'; }
      if($btnDisconnect){ $btnDisconnect.disabled = !connected; $btnDisconnect.style.display = connected ? '' : 'none'; }
      if($btnHealthScan){ $btnHealthScan.disabled = !connected; }
    }
    function hexToAscii(hex){
      try{
        const clean = hex.replace(/[^0-9A-F]/gi,'').toUpperCase();
        if(clean.length%2!==0 || clean.length<2) return null;
        let out=''; for(let i=0;i<clean.length;i+=2){ const b=parseInt(clean.slice(i,i+2),16); if(!b) break; if(b<32 || b>126) return null; out+=String.fromCharCode(b); }
        return out || null;
      }catch{ return null; }
    }
    function tokenDisplay(code){
      const isHex = /^[0-9A-F]{10,}$/.test(code);
      if(!isHex) return { ticker: code, hex: null, label: code };
      const ascii = hexToAscii(code);
      if(ascii) return { ticker: ascii, hex: code, label: `${ascii} (${code})` };
      return { ticker: null, hex: code, label: code };
    }

    /* ===== Human test: challenge code shown + Memoed into tx ===== */
    let __LS_CHALLENGE = null;
    function newChallenge6(){ return String(Math.floor(100000 + Math.random()*900000)); }
    function asciiToHex(s){ let out=''; for(let i=0;i<s.length;i++){ out += s.charCodeAt(i).toString(16).padStart(2,'0'); } return out.toUpperCase(); }
    function setChallengeBadge(code){
      const el = $('challengeBadge'); if(!el) return;
      if(!code){ el.style.display='none'; el.textContent=''; return; }
      el.textContent = code; el.style.display = 'inline-block';
    }
    function buildMemos(){
      const app = 'Sentinel Liquidity Health';
      const ch  = __LS_CHALLENGE || newChallenge6();
      __LS_CHALLENGE = ch;
      return [
        { Memo: { MemoType: asciiToHex('APP'),       MemoData: asciiToHex(app) } },
        { Memo: { MemoType: asciiToHex('CHALLENGE'), MemoData: asciiToHex(ch)  } },
        { Memo: { MemoType: asciiToHex('DOMAIN'),    MemoData: asciiToHex('xrbitcoincash.com') } }
      ];
    }
    function attachMemos(tx){
      try{
        const m = buildMemos();
        tx.Memos = Array.isArray(tx.Memos) ? tx.Memos.concat(m) : m;
      }catch{}
      return tx;
    }
    function announceChallenge(){
      if (__LS_CHALLENGE){
        setChallengeBadge(__LS_CHALLENGE);
        log('Verify code in wallet: ' + __LS_CHALLENGE);
        setStatus($walletStatus, 'Verify code in wallet: ' + __LS_CHALLENGE);
      }
    }

    /* ===== XRPL PROXY ===== */
    async function xrplRequest(payload,{timeoutMs=12000}={}){
      if(!PROXY_BASE) throw new Error('Proxy URL missing');
      const ctrl=new AbortController(); const t=setTimeout(()=>ctrl.abort(),timeoutMs);
      try{
        const res=await fetch(proxyUrl(),{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload), signal:ctrl.signal, redirect:'error', cache:'no-store', credentials:'omit' });
        if(!res.ok) throw new Error('Proxy HTTP '+res.status);
        const data=await res.json(); if(data && data.error) throw new Error('XRPL '+(data.error?.message||'error')); return data;
      } finally { clearTimeout(t); }
    }
    async function call(method,params){ const r=await xrplRequest({method,params:[{...params,ledger_index:'validated'}]}); return r?.result; }

    /* ===== DATA ===== */
    async function getAccountInfo(acct){ const r=await call('account_info',{account:acct}); return r?.account_data||{}; }
    async function fetchOffers(acct){
      const s = $('offersStatus'); // optional
      if (s) setStatus(s,'Loading open orders…');
      try{
        const r=await call('account_offers',{account:acct,limit:500});
        state.offers=r?.offers||[]; if($offersWrap) renderOffers();
        if(s) setStatus(s,`Found ${state.offers.length} open offer(s).`,'ok');
      }catch(e){
        state.offers=[]; if($offersWrap) renderOffers();
        if(s) setStatus(s,'Error loading offers: '+(e.message||e),'err');
      }
    }
    function renderOffers(){
      $offersWrap && ($offersWrap.innerHTML='');
      if(!$offersWrap) return;
      if(!state.offers.length){
        const d=document.createElement('div'); d.className='hint'; d.textContent='No open offers found.'; $offersWrap.appendChild(d); return;
      }
      const wrap=document.createElement('div'); wrap.style.overflow='auto';
      const table=document.createElement('table'); const thead=document.createElement('thead'); const trh=document.createElement('tr');
      ['Offer Seq','Owner gets','Owner pays','Price','Action'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
      thead.appendChild(trh); table.appendChild(thead);
      const tbody=document.createElement('tbody');
      state.offers.forEach(o=>{
        const tr=document.createElement('tr');
        const tdSeq=document.createElement('td'); tdSeq.className='mono'; tdSeq.textContent=o.seq; tr.appendChild(tdSeq);
        const tdGets=document.createElement('td'); tdGets.textContent=amtStr(o.taker_gets); tr.appendChild(tdGets);
        const tdPays=document.createElement('td'); tdPays.textContent=amtStr(o.taker_pays); tr.appendChild(tdPays);
        const tdPx=document.createElement('td'); tdPx.textContent=price(o.taker_gets,o.taker_pays); tr.appendChild(tdPx);
        const tdAct=document.createElement('td'); const b=document.createElement('button'); b.className='btn'; b.type='button'; b.textContent='Cancel';
        b.addEventListener('click',()=>cancelOne(o.seq)); tdAct.appendChild(b); tr.appendChild(tdAct);
        tbody.appendChild(tr);
      });
      table.appendChild(tbody); wrap.appendChild(table); $offersWrap.appendChild(wrap);
    }
    async function beforeAfterReserveReport(acct,prevInfo){
      try{
        const now=await getAccountInfo(acct);
        const prevBal=N(prevInfo?.Balance)/XRP_TO_DROPS; const nowBal=N(now?.Balance)/XRP_TO_DROPS;
        const prevOwn=N(prevInfo?.OwnerCount); const nowOwn=N(now?.OwnerCount);
        const freed=Math.max(0,prevOwn-nowOwn)*2; const delta=(nowBal-prevBal).toFixed(6);
        $resultBox && ($resultBox.innerHTML = `<div>Freed reserve: <strong>${freed.toFixed(6)} XRP</strong>. Balance change: <strong>${delta} XRP</strong>.</div>`);
      }catch{}
    }

    /* ===== ADAPTERS ===== */
    class WalletAdapter { name='Base'; async connect(){throw new Error('not implemented');} async signAndSubmit(_tx){throw new Error('not implemented');} async disconnect(){} }
    class XummAdapter extends WalletAdapter{
      constructor(){ super(); this.name='Xaman'; this.xumm=null; }
      async ensureSDK(){ if(typeof Xumm==='undefined') throw new Error('Xaman SDK not loaded'); if(!XUMM_API_KEY) throw new Error('Xaman API key missing'); if(!this.xumm) this.xumm=new Xumm(XUMM_API_KEY); }
      async resume(){
        await this.ensureSDK();
        const acct = await this.xumm.user.account;
        if(acct){ return { address: acct }; }
        return null;
      }
      async connect(){
        await this.ensureSDK();
        await this.xumm.authorize();
        const acct=await this.xumm.user.account;
        if(!acct) throw new Error('No account returned');
        return { address: acct };
      }

      /* ===== PATCH #2: Replace this method with pinned post-commit refresh ===== */
      async signAndSubmit(txjson){
        // Pin the context at payload creation time
        const pinned = { net: state.network, acct: state.account };

        const { resolved, websocket, unsubscribe } = await this.xumm.payload.createAndSubscribe(
          { txjson, options:{ submit:true, expire:300 } },
          ev => {
            if (ev?.opened) setStatus($walletStatus,'Open Xaman to review & sign…');
            if (ev?.signed === false) setStatus($walletStatus,'Canceled in wallet.','err');
          }
        );

        const res = await resolved;

        try{ websocket?.close(); }catch{}
        try{ typeof unsubscribe==='function' && unsubscribe(); }catch{}

        if(!res?.signed) throw new Error('User rejected');

        // Post-commit refresh with the SAME network/account that signed
        setTimeout(() => {
          refreshNumbersOnlyPinned(pinned).catch(()=>{});
        }, 450); // small delay for propagation

        return { hash: res?.txid || res?.id || '(pending)', result:'submitted' };
      }
      /* ===== end PATCH #2 ===== */

      async disconnect(){ try{ await this.xumm?.logout(); }catch{} }
    }

    /* ===== CONNECT HELPERS ===== */
    function setAdapter(ad){ state.adapter = ad; updateConnectButtons(); }
    async function refreshAll(){
      if(!state.account) return;
      updateNetUI();
      state.lastAccountInfo = await getAccountInfo(state.account);
      await Promise.allSettled([
        fetchOffers(state.account),
        refreshSLTokens(),
        refreshHealth()
      ]);
    }

    /* ===== PATCH #1: Pinned post-commit refresh helpers (added right after refreshAll) ===== */
    function proxyUrlFor(net){ return PROXY_BASE + (net==='testnet' ? '?network=testnet' : ''); }

    async function xrplRequestNet(payload, net, {timeoutMs=12000}={}){
      if(!PROXY_BASE) throw new Error('Proxy URL missing');
      const ctrl=new AbortController(); const t=setTimeout(()=>ctrl.abort(),timeoutMs);
      try{
        const res=await fetch(proxyUrlFor(net),{
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body:JSON.stringify(payload),
          signal:ctrl.signal,
          redirect:'error',
          cache:'no-store',
          credentials:'omit'
        });
        if(!res.ok) throw new Error('Proxy HTTP '+res.status);
        const data=await res.json();
        if(data && data.error) throw new Error('XRPL '+(data.error?.message||'error'));
        return data;
      } finally { clearTimeout(t); }
    }

    async function callNet(method, params, net){
      const r = await xrplRequestNet({method, params:[{...params, ledger_index:'validated'}]}, net);
      return r?.result;
    }

    function ctxChanged(pinned){
      return (state.network !== pinned.net) || (state.account !== pinned.acct);
    }

    async function listUserTokensNet(acct, net){
      const out = [];
      try{
        const r = await callNet('account_lines', { account: acct, limit: 400 }, net);
        for(const l of (r?.lines || [])){
          const bal = Number(l.balance || 0);
          if (bal > 0) out.push({
            code: (l.currency || '').toString().toUpperCase(),
            issuer: l.account || l.issuer || l.account,
            balance: bal
          });
        }
      }catch{}
      return out;
    }

    function buildSLTableFromList(toks){
      const tbl = document.createElement('table');
      const thead = document.createElement('thead');
      thead.innerHTML = '<tr><th></th><th>Token / Hex</th><th>Issuer</th><th>Balance</th><th>Amt to protect</th></tr>';
      tbl.appendChild(thead);
      const tb = document.createElement('tbody');

      for (const t of toks){
        const tr = document.createElement('tr');

        const tdPick = document.createElement('td');
        const pick = document.createElement('input'); pick.type = 'checkbox'; pick.className = 'slPick';
        tdPick.appendChild(pick); tr.appendChild(tdPick);

        const tdLabel = document.createElement('td'); tdLabel.className='mono'; tdLabel.textContent = tokenDisplay(t.code).label; tr.appendChild(tdLabel);
        const tdIssuer= document.createElement('td'); tdIssuer.className='mono'; tdIssuer.style.wordBreak='anywhere'; tdIssuer.textContent = t.issuer; tr.appendChild(tdIssuer);
        const tdBal  = document.createElement('td'); tdBal.textContent = t.balance.toFixed(6); tr.appendChild(tdBal);

        const tdAmt  = document.createElement('td');
        const amtInput = document.createElement('input'); amtInput.type='number'; amtInput.className='slAmt';
        amtInput.step='0.000001'; amtInput.value=String(Math.max(0,t.balance).toFixed(6));
        tdAmt.appendChild(amtInput); tr.appendChild(tdAmt);

        tb.appendChild(tr);
      }
      tbl.appendChild(tb);
      return tbl;
    }

    async function refreshNumbersOnlyPinned(pinned){
      if (!pinned?.acct) return;

      // 1) Refresh open offers for the pinned account/network
      try{
        const r = await callNet('account_offers', {account: pinned.acct, limit: 500}, pinned.net);
        if (ctxChanged(pinned)) return; // user switched before we could render
        state.offers = r?.offers || [];
        if ($offersWrap) renderOffers();
        if ($offersStatus) setStatus($offersStatus, `Found ${state.offers.length} open offer(s).`, 'ok');
      }catch(e){
        if (ctxChanged(pinned)) return;
        state.offers = [];
        if ($offersWrap) renderOffers();
        if ($offersStatus) setStatus($offersStatus, 'Error loading offers: ' + (e.message || e), 'err');
      }

      // 2) Refresh Stop-Loss token list (balances) for the pinned account/network
      try{
        const toks = await listUserTokensNet(pinned.acct, pinned.net);
        if (ctxChanged(pinned)) return;
        if (!toks.length){
          if ($slTokens) $slTokens.textContent = 'No positive IOU balances found.';
        } else {
          if ($slTokens) $slTokens.replaceChildren(buildSLTableFromList(toks));
        }
      }catch{}
    }
    /* ===== end PATCH #1 ===== */

    async function connectWith(AdapterClass){
      try{
        setStatus($walletStatus,'Connecting…');
        const ad = new AdapterClass();
        const { address } = await ad.connect();
        state.account = address; setAdapter(ad);
        localStorage.setItem('xrbc.lastAccount', address);
        setStatus($walletStatus, ad.name+': '+address, 'ok');
        // Generate a fresh challenge on connect (visible before first sign)
        __LS_CHALLENGE = newChallenge6(); announceChallenge();
        $btnDisconnect.disabled = false;
        await refreshAll();
      }catch(e){
        setStatus($walletStatus,(e && e.message) || 'Connect failed','err');
      } finally { updateConnectButtons(); }
    }
    async function tryResumeWallet(){
      try{
        const ad = new XummAdapter();
        const resumed = await ad.resume();
        if(resumed && resumed.address){
          state.account = resumed.address; setAdapter(ad);
          setStatus($walletStatus, ad.name+': '+resumed.address, 'ok');
          __LS_CHALLENGE = newChallenge6(); announceChallenge();
          $btnDisconnect.disabled = false;
          await refreshAll();
        } else {
          const cached = localStorage.getItem('xrbc.lastAccount');
          if(cached){ state.account = cached; setStatus($walletStatus,'Previously connected: '+cached,'ok'); updateConnectButtons(); }
        }
      } catch(e){}
    }
    async function disconnect(){
      try{ await state.adapter?.disconnect?.(); }catch{}
      state.account=null; state.adapter=null; state.offers=[]; setProgress(0);
      localStorage.removeItem('xrbc.lastAccount');
      setChallengeBadge('');
      $offersWrap && ($offersWrap.innerHTML='<div class="hint">No data yet.</div>');
      setStatus($walletStatus,'Status: Not connected');
      setStatus($slStatus,''); setStatus($panicStatus,''); setStatus($healthStatus,'');
      $btnDisconnect.disabled=true; updateConnectButtons();
      $slTokens && ($slTokens.textContent='Connect wallet first.');
      $slPlanOut && ($slPlanOut.textContent = '');
      $panicPlanOut && ($panicPlanOut.textContent = '');
      $xrbcBadge && ($xrbcBadge.textContent='');
      $healthNote && ($healthNote.textContent='Connect wallet to enable scanning.');
      $healthTable && ($healthTable.style.display='none');
      $healthBody && ($healthBody.innerHTML='');
    }

    /* ===== CANCEL ===== */
    async function cancelOne(seq){
      if(!state.account || !state.adapter){ setStatus($offersStatus,'Connect wallet first.','err'); return; }
      const s = $('offersStatus'); if(s) setStatus(s,'Preparing cancel '+seq+'…');
      try{
        __LS_CHALLENGE = newChallenge6(); announceChallenge();
        const tx=attachMemos({TransactionType:'OfferCancel',Account:state.account,OfferSequence:Number(seq)});
        const res=await state.adapter.signAndSubmit(tx);
        if(s) setStatus(s,`Submitted cancel ${seq}.`,'ok');
        /* Removed the immediate fetchOffers(state.account) to avoid wrong-context refresh.
           Numbers now refresh via the pinned post-commit step in signAndSubmit. */
        log(`tx hash: ${res.hash || '(unknown)'}`); return res;
      }catch(e){ if(s) setStatus(s,'Error: '+(e.message||e),'err'); throw e; }
    }
    async function cancelAll(){
      const s = $('offersStatus');
      if(!state.account || !state.adapter){ if(s) setStatus(s,'Connect wallet first.','err'); return; }
      if(!state.offers.length){ if(s) setStatus(s,'No visible offers to cancel.'); return; }
      if(!confirm(`Cancel ${state.offers.length} offer(s)? You will approve each in your wallet.`)) return;
      const beforeInfo = state.lastAccountInfo || await getAccountInfo(state.account);
      let i=0; const total=state.offers.length;
      for (const o of state.offers){ i++; setProgress(Math.floor((i-1)/total*100)); try{ await cancelOne(o.seq); }catch{} }
      setProgress(100); await beforeAfterReserveReport(state.account,beforeInfo);
      if(s) setStatus(s,'Done.','ok');
    }

    /* ===== Slippage caps ===== */
    const ST_DEFAULT_SLIPPAGE_PCT = 2;
    const QUICK_BUY_SLIPPAGE_PCT  = 2;

    const TARGETS = {
      XRP:   { kind: 'XRP' },
      RLUSD: {
        kind: 'IOU',
        issuer: 'rMxCKbEDwqr76QuheSUMdEGf4B9xJ8m5De',
        currencyHex: '524C555344000000000000000000000000000000'
      }
    };

    const MIN_PANIC_VALUE = { XRP: 2, RLUSD: 2 };
    function belowMin(estValue, tgt){
      const min = tgt === 'RLUSD' ? MIN_PANIC_VALUE.RLUSD : MIN_PANIC_VALUE.XRP;
      return Number(estValue) < Number(min);
    }

    /* ===== Token discovery (positive balances) ===== */
    async function listUserTokens(acct){
      const out = [];
      try{
        const r = await call('account_lines', { account: acct, limit: 400 });
        for(const l of (r?.lines || [])){
          const bal = Number(l.balance || 0);
          if (bal > 0) out.push({
            code: (l.currency || '').toString().toUpperCase(),
            issuer: l.account || l.issuer || l.account,
            balance: bal
          });
        }
      }catch{}
      return out;
    }

    /* ===== Price helpers ===== */
    async function refPriceIOUtoXRP(currencyCode, issuer){
      try{
        const a = await xrplRequest({ method:'amm_info', params:[{ asset:{currency:'XRP'}, asset2:{currency:currencyCode, issuer} }] });
        const amm = a?.result?.amm;
        if (amm){
          const rxDrops = typeof amm.amount === 'string' ? Number(amm.amount) : Number(amm.amount?.value || 0);
          const rx = rxDrops / 1_000_000;
          const ry = Number(amm.amount2?.value || 0);
          if (rx > 0 && ry > 0) return rx / ry;
        }
      }catch{}
      try{
        const r = await xrplRequest({ method:'book_offers', params:[{ taker_gets:{currency:'XRP'}, taker_pays:{currency:currencyCode, issuer}, limit:1 }] });
        const of = r?.result?.offers?.[0];
        if (of){
          const gets = Number(of.TakerGets) / 1_000_000;
          const pays = Number(of.TakerPays?.value);
          if (pays > 0) return gets / pays;
        }
      }catch{}
      return null;
    }
    async function refPriceIOUtoRLUSD(currencyCode, issuer){
      const RL = TARGETS.RLUSD;
      try{
        const a = await xrplRequest({ method:'amm_info', params:[{ asset:{currency:RL.currencyHex, issuer:RL.issuer}, asset2:{currency:currencyCode, issuer} }] });
        const amm = a?.result?.amm;
        if (amm){
          const rL = Number(amm.amount?.value || 0);
          const rT = Number(amm.amount2?.value || 0);
          if (rL > 0 && rT > 0) return rL / rT;
        }
      }catch{}
      try{
        const r = await xrplRequest({ method:'book_offers', params:[{ taker_gets:{currency:RL.currencyHex, issuer:RL.issuer}, taker_pays:{currency:currencyCode, issuer}, limit:1 }] });
        const of = r?.result?.offers?.[0];
        if (of){
          const gets = Number(of.TakerGets?.value);
          const pays = Number(of.TakerPays?.value);
          if (pays > 0) return gets / pays;
        }
      }catch{}
      return null;
    }

    /* ===== Health (AMM reserves + slippage scoring) ===== */
    async function ammInfoXrpIou(currencyHex, issuer){
      try{
        const r = await xrplRequest({ method:'amm_info', params:[{ asset:{currency:'XRP'}, asset2:{currency:currencyHex, issuer} }] });
        return r?.result?.amm || null;
      }catch{ return null; }
    }
    function estSlippageXrpToIou(xrpIn, xrpRes, iouRes){
      if (xrpIn <= 0 || xrpRes <= 0 || iouRes <= 0) return {dy:0, slip:0};
      const dy = (iouRes * xrpIn) / (xrpRes + xrpIn);
      const spot = iouRes / xrpRes;
      const eff = dy / xrpIn;
      const slip = Math.max(0, (spot - eff) / spot);
      return {dy, slip};
    }
    function scoreHealth({poolExists, xrpRes, fee, slip10, slip100, ledgerFresh}){
      let score = 0;
      if (poolExists) score += 1;
      if (xrpRes >= 500) score += 2; else if (xrpRes >= 100) score += 1;
      if (fee <= 0.3) score += 1; else if (fee <= 0.5) score += 0; else score -= 1;
      if (slip10 <= 0.01) score += 2; else if (slip10 <= 0.03) score += 1;
      if (slip100 <= 0.03) score += 2; else if (slip100 <= 0.10) score += 1;
      if (ledgerFresh) score += 1;
      let status = "Caution", cls="C";
      if (score >= 6) { status="Healthy"; cls="H"; }
      else if (score <= 2) { status="Risk"; cls="R"; }
      return {score, status, cls};
    }

    function applyRiskFilter(){
      if(!$healthBody) return;
      const only = $riskOnly?.checked;
      const rows = $healthBody.querySelectorAll('tr');
      rows.forEach(tr=>{
        if(!only){ tr.style.display=''; return; }
        const pill = tr.querySelector('td:last-child .pill');
        const isRisk = pill && pill.classList.contains('R');
        tr.style.display = isRisk ? '' : 'none';
      });
    }

    async function refreshHealth(){
      if (!$healthBody) return;
      if (!state.account){ $healthNote.textContent='Connect wallet to enable scanning.'; return; }

      $healthBody.innerHTML=''; $healthTable.style.display='none';
      setStatus($healthStatus,'Fetching trustlines…');

      const srv = await call('server_state',{}).catch(()=>null);
      const ledgerFresh = !!(srv && srv.validated_ledger);

      const linesR = await call('account_lines',{account:state.account,limit:400}).catch(()=>null);
      const lines = (linesR && linesR.lines) ? linesR.lines : [];

      if (!lines.length){
        $healthNote.textContent='No trustlines found. You can still hold XRP without trustlines.';
        setStatus($healthStatus,'', ''); return;
      }
      setStatus($healthStatus,`Found ${lines.length} trustlines. Checking pools…`);

      const XRBC_HEX = (XRBC.currencyHex||'').toUpperCase();
      let xrbcRow = null;
      const rows = [];

      for (const l of lines){
        const currencyHex = (l.currency||'').toUpperCase();
        const issuer = l.account || l.issuer;
        if (!currencyHex || !issuer) continue;

        const amm = await ammInfoXrpIou(currencyHex, issuer);
        if (!amm){
          const r = {
            token: tokenDisplay(currencyHex).label + ` (${issuer.slice(0,6)}…${issuer.slice(-4)})`,
            pool: 'XRP/IOU',
            xrpRes: '-', iouRes: '-', fee: '-',
            slip10: '-', slip100: '-', score: 0, status:'No Pool', cls:'R'
          };
          if (currencyHex===XRBC_HEX && issuer===XRBC.issuer) xrbcRow = r;
          rows.push(r);
          continue;
        }

        // CORRECT parsing of reserves: XRP in drops string, IOU as .value
        let xrpRes = 0;
        let iouRes = 0;
        if (typeof amm.amount === 'string') {
          xrpRes = Number(amm.amount) / 1_000_000;
        } else if (amm.amount && typeof amm.amount.value !== 'undefined') {
          xrpRes = Number(amm.amount.value);
        }
        if (amm.amount2 && typeof amm.amount2.value !== 'undefined') {
          iouRes = Number(amm.amount2.value);
        }

        const feeBps = typeof amm.trading_fee === 'number' ? amm.trading_fee : 30;
        const feePct = feeBps/100;

        const s10 = estSlippageXrpToIou(10, xrpRes, iouRes);
        const s100 = estSlippageXrpToIou(100, xrpRes, iouRes);

        const health = scoreHealth({
          poolExists:true, xrpRes, fee: feePct, slip10: s10.slip, slip100: s100.slip, ledgerFresh
        });

        const r = {
          token: tokenDisplay(currencyHex).label + ` (${issuer.slice(0,6)}…${issuer.slice(-4)})`,
          pool: 'XRP/IOU',
          xrpRes: xrpRes.toFixed(2),
          iouRes: iouRes.toFixed(2),
          fee: feePct.toFixed(2) + '%',
          slip10: (s10.slip*100).toFixed(2) + '%',
          slip100: (s100.slip*100).toFixed(2) + '%',
          score: health.score,
          status: health.status,
          cls: health.cls
        };
        if (currencyHex===XRBC_HEX && issuer===XRBC.issuer) xrbcRow = r;
        rows.push(r);
      }

      if (xrbcRow){
        $xrbcBadge.innerHTML = `<span class="pill ${xrbcRow.cls}">${xrbcRow.status}</span> · Score ${xrbcRow.score} · ${xrbcRow.xrpRes} XRP reserves`;
      } else {
        $xrbcBadge.textContent = "XRBC not detected in this wallet (or no XRBC pool found).";
      }

      if (!rows.length){
        $healthNote.textContent = 'No pools found for this account’s trustlines (or pools unavailable).';
        setStatus($healthStatus,'Done.');
        return;
      }

      $healthBody.innerHTML = rows.map(r => `
        <tr>
          <td class="mono">${r.token}</td>
          <td>${r.pool}</td>
          <td>${r.xrpRes} XRP / ${r.iouRes}</td>
          <td>${r.fee}</td>
          <td>${r.slip10} / ${r.slip100}</td>
          <td class="mono">${r.score}</td>
          <td><span class="pill ${r.cls}">${r.status}</span></td>
        </tr>
      `).join("");
      $healthTable.style.display='';
      applyRiskFilter();
      setStatus($healthStatus,'Done.','ok');
      $healthNote.textContent = '';
    }

    /* ===== Build stop offers ===== */
    function buildStopOfferXRP({ acct, currencyCode, issuer, amountIOU, stopPriceXrpPerIOU }){
      const TF_SELL = 0x00080000;
      const xrpTotal = Math.max(0, Number(amountIOU) * Number(stopPriceXrpPerIOU));
      return {
        TransactionType: 'OfferCreate',
        Account: acct,
        TakerGets: { currency: currencyCode, issuer, value: String(amountIOU) },
        TakerPays: String(Math.ceil(xrpTotal * 1_000_000)),
        Flags: TF_SELL
      };
    }
    function buildStopOfferRLUSD({ acct, currencyCode, issuer, amountIOU, stopPriceRLUSDperIOU }){
      const RL = TARGETS.RLUSD;
      const rlTotal = Math.max(0, Number(amountIOU) * Number(stopPriceRLUSDperIOU));
      return {
        TransactionType: 'OfferCreate',
        Account: acct,
        TakerGets: { currency: currencyCode, issuer, value: String(amountIOU) },
        TakerPays: { currency: RL.currencyHex, issuer: RL.issuer, value: String(rlTotal) },
        Flags: 0x00080000
      };
    }

    /* ===== Pathfind payments ===== */
    async function pathfindSellIOUtoXRP({ acct, currencyCode, issuer, amountIOU, slippagePct }){
      const estPx = (await refPriceIOUtoXRP(currencyCode, issuer)) || 0;
      if (!estPx) throw new Error('No price');
      const estXrp = amountIOU * estPx;
      const slip = Math.max(0, Number(slippagePct)/100);
      const minDrops = Math.floor(Math.max(1, estXrp * (1 - slip) * 1_000_000)).toString();

      const pf = await xrplRequest({
        method:'ripple_path_find',
        params:[{
          source_account: acct,
          destination_account: acct,
          destination_amount: minDrops,
          source_currencies: [{ currency: currencyCode, issuer }]
        }]
      });
      const alt = (pf?.result?.alternatives || [])[0];
      if (!alt) throw new Error('No path');

      return {
        TransactionType: 'Payment',
        Account: acct,
        Destination: acct,
        Amount: minDrops,
        SendMax: { currency: currencyCode, issuer, value: String(amountIOU) },
        Flags: 0x00020000,
        DeliverMin: minDrops,
        Paths: alt.paths_computed || alt.paths_canonical || []
      };
    }
    async function pathfindSellIOUtoRLUSD({ acct, currencyCode, issuer, amountIOU, slippagePct }){
      const RL = TARGETS.RLUSD;
      const estPx = (await refPriceIOUtoRLUSD(currencyCode, issuer)) || 0;
      if (!estPx) throw new Error('No price');
      const estRl = amountIOU * estPx;
      const slip = Math.max(0, Number(slippagePct)/100);
      const minObj = { currency: RL.currencyHex, issuer: RL.issuer, value: String(estRl * (1 - slip)) };

      const pf = await xrplRequest({
        method:'ripple_path_find',
        params:[{
          source_account: acct,
          destination_account: acct,
          destination_amount: minObj,
          source_currencies: [{ currency: currencyCode, issuer }]
        }]
      });
      const alt = (pf?.result?.alternatives || [])[0];
      if (!alt) throw new Error('No path');

      return {
        TransactionType: 'Payment',
        Account: acct,
        Destination: acct,
        Amount: minObj,
        SendMax: { currency: currencyCode, issuer, value: String(amountIOU) },
        Flags: 0x00020000,
        DeliverMin: minObj,
        Paths: alt.paths_computed || alt.paths_canonical || []
      };
    }

    /* ===== Stop-Loss planner ===== */
    async function refreshSLTokens(){
      if (!state.account){ $slTokens.textContent='Connect wallet first.'; return; }
      const toks = await listUserTokens(state.account);
      if (!toks.length){ $slTokens.textContent='No positive IOU balances found.'; return; }

      const tbl = document.createElement('table');
      const thead = document.createElement('thead');
      thead.innerHTML = '<tr><th></th><th>Token / Hex</th><th>Issuer</th><th>Balance</th><th>Amt to protect</th></tr>';
      tbl.appendChild(thead);
      const tb = document.createElement('tbody');

      for (const t of toks){
        const tr = document.createElement('tr');

        const tdPick = document.createElement('td');
        const pick = document.createElement('input'); pick.type = 'checkbox'; pick.className = 'slPick';
        tdPick.appendChild(pick); tr.appendChild(tdPick);

        const tdLabel = document.createElement('td'); tdLabel.className='mono'; tdLabel.textContent = tokenDisplay(t.code).label; tr.appendChild(tdLabel);
        const tdIssuer= document.createElement('td'); tdIssuer.className='mono'; tdIssuer.style.wordBreak='anywhere'; tdIssuer.textContent = t.issuer; tr.appendChild(tdIssuer);
        const tdBal  = document.createElement('td'); tdBal.textContent = t.balance.toFixed(6); tr.appendChild(tdBal);

        const tdAmt  = document.createElement('td');
        const amtInput = document.createElement('input'); amtInput.type='number'; amtInput.className='slAmt'; amtInput.step='0.000001'; amtInput.value=String(Math.max(0,t.balance).toFixed(6));
        tdAmt.appendChild(amtInput); tr.appendChild(tdAmt);

        tb.appendChild(tr);
      }
      tbl.appendChild(tb);
      $slTokens.replaceChildren(tbl);
    }

    document.getElementById('btnPlanStops')?.addEventListener('click', async ()=>{
      if (!state.account) return ($slStatus.textContent='Connect wallet first.');
      const rows = [...($slTokens.querySelectorAll('tbody tr')||[])];
      const picks = rows.map(row=>{
        const ckb=row.querySelector('.slPick'); if(!ckb?.checked) return null;
        const codeLabel = row.children[1].textContent.trim();
        const hexMatch = codeLabel.match(/\(([0-9A-F]{10,})\)$/);
        const code = hexMatch ? hexMatch[1] : codeLabel.split(' ')[0];
        const issuer = row.children[2].textContent.trim();
        const bal = Number(row.children[3].textContent||0);
        const amt = Number(row.querySelector('.slAmt')?.value||0);
        return { code, issuer, bal, amt, label: codeLabel };
      }).filter(Boolean);
      if (!picks.length) return ($slStatus.textContent='Pick at least one token.');

      const mode = $slMode.value; const val = Number($slValue.value||0);
      if (!val || val <= 0) return ($slStatus.textContent='Enter a % or price.');
      const tgt = $slTarget.value;

      const lines = [];
      for (const p of picks){
        const basePx = (tgt === 'RLUSD') ? await refPriceIOUtoRLUSD(p.code, p.issuer)
                                         : await refPriceIOUtoXRP(p.code, p.issuer);
        if (!basePx){ lines.push(`❌ ${p.label}: no price`); continue; }
        const stopPx = (mode==='pct') ? (basePx * (1 - val/100)) : val;
        const unit = (tgt === 'RLUSD') ? 'RLUSD/IOU' : 'XRP/IOU';
        lines.push(`✅ ${p.label}: stop ${stopPx.toFixed(6)} ${unit} · amount ${p.amt.toFixed(6)} IOU`);
      }
      $slPlanOut.textContent = lines.join('\n');
      document.getElementById('btnCreateStops').disabled = !lines.some(l=>l.startsWith('✅'));
    });

    document.getElementById('btnCreateStops')?.addEventListener('click', async ()=>{
      if (!state.account || !state.adapter) return ($slStatus.textContent='Connect wallet first.');
      const rows = [...($slTokens.querySelectorAll('tbody tr')||[])];
      const mode = $slMode.value; const val = Number($slValue.value||0);
      const tgt  = $slTarget.value;

      $slStatus.textContent='Building stop orders…';
      let ok=0, fail=0;
      for (const row of rows){
        const ckb=row.querySelector('.slPick'); if(!ckb?.checked) continue;
        const codeLabel = row.children[1].textContent.trim();
        const hexMatch = codeLabel.match(/\(([0-9A-F]{10,})\)$/);
        const code = hexMatch ? hexMatch[1] : codeLabel.split(' ')[0];
        const issuer = row.children[2].textContent.trim();
        const amt = Number(row.querySelector('.slAmt')?.value||0);
        if (!amt || amt<=0) { fail++; continue; }

        try{
          const basePx = (tgt === 'RLUSD') ? await refPriceIOUtoRLUSD(code, issuer)
                                           : await refPriceIOUtoXRP(code, issuer);
          if (!basePx) throw new Error('no price');
          const stopPx = (mode==='pct') ? (basePx * (1 - val/100)) : val;

          const tx = (tgt === 'RLUSD')
            ? buildStopOfferRLUSD({ acct: state.account, currencyCode: code, issuer, amountIOU: amt, stopPriceRLUSDperIOU: stopPx })
            : buildStopOfferXRP({ acct: state.account, currencyCode: code, issuer, amountIOU: amt, stopPriceXrpPerIOU: stopPx });

          __LS_CHALLENGE = newChallenge6(); announceChallenge();
          await state.adapter.signAndSubmit(attachMemos(tx));
          ok++;
        }catch(e){ fail++; }
      }
      $slStatus.textContent = `Submitted ${ok} stop(s). Failed ${fail}.`;
    });

    /* ===== Panic preview/sell ===== */
    $btnPanicPreview?.addEventListener('click', async ()=>{
      if (!state.account) return ($panicStatus.textContent='Connect wallet first.');
      const toks = await listUserTokens(state.account);
      if (!toks.length){ $panicPlanOut.textContent='No positive IOU balances.'; return; }
      const tgt = $panicTarget.value;

      const rows = [];
      for (const t of toks){
        const disp = tokenDisplay(t.code).label;
        const px = (tgt === 'RLUSD') ? await refPriceIOUtoRLUSD(t.code, t.issuer)
                                     : await refPriceIOUtoXRP(t.code, t.issuer);
        if (px){
          const est  = px * t.balance;
          const unit = (tgt === 'RLUSD') ? 'RLUSD' : 'XRP';
          const low  = belowMin(est, tgt);
          rows.push({ ...t, disp, px, est, unit, route: !low, low });
        } else {
          rows.push({ ...t, disp, px:null, est:0, unit:(tgt==='RLUSD'?'RLUSD':'XRP'), route:false, low:false });
        }
      }
      rows.sort((a,b)=>b.est-a.est);

      const lines = rows.map(r=>{
        if(!r.px) return `❌ ${r.disp}: no route`;
        const perUnit = (tgt === 'RLUSD') ? 'RLUSD/IOU' : 'XRP/IOU';
        const base = `✅ ${r.disp}: est ${r.px.toFixed(6)} ${perUnit} × ${r.balance.toFixed(6)} = ${r.est.toFixed(6)} ${r.unit}`;
        return r.low ? base + '  ⚠ low liquidity — will skip' : base;
      });
      $panicPlanOut.textContent = lines.join('\n');
    });

    $btnPanicSell?.addEventListener('click', async ()=>{
      if (!state.account || !state.adapter) return ($panicStatus.textContent='Connect wallet first.');
      const slip = Number($panicSlip.value||ST_DEFAULT_SLIPPAGE_PCT);
      const tgt  = $panicTarget.value;

      if ($panicCancelFirst?.checked) {
        try { await cancelAll(); } catch {}
      }

      const toks = await listUserTokens(state.account);
      if (!toks.length){ $panicStatus.textContent='No positive IOU balances.'; return; }

      const scored = [];
      for (const t of toks){
        const px = (tgt === 'RLUSD') ? await refPriceIOUtoRLUSD(t.code, t.issuer)
                                     : await refPriceIOUtoXRP(t.code, t.issuer);
        if (px) scored.push({ ...t, est: px * t.balance });
      }
      scored.sort((a,b)=>b.est-a.est);

      const filtered = scored.filter(s => !belowMin(s.est, tgt));

      let ok=0, fail=0;
      for (const t of filtered){
        try{
          const tx = (tgt === 'RLUSD')
            ? await pathfindSellIOUtoRLUSD({ acct: state.account, currencyCode: t.code, issuer: t.issuer, amountIOU: t.balance, slippagePct: slip })
            : await pathfindSellIOUtoXRP  ({ acct: state.account, currencyCode: t.code, issuer: t.issuer, amountIOU: t.balance, slippagePct: slip });

          __LS_CHALLENGE = newChallenge6(); announceChallenge();
          await state.adapter.signAndSubmit(attachMemos(tx));
          ok++;
        }catch(e){ fail++; }
      }
      const skipped = (toks.length - scored.length) + (scored.length - filtered.length);
      $panicStatus.textContent = `Submitted ${ok} swap(s). Failed ${fail}. Skipped ${skipped} (no route/low liquidity).`;
    });

    /* ===== XRBC TRUST + BUY ===== */
    const XRBC_HEX=(XRBC.currencyHex||'').toUpperCase();
    function hexToAsciiLoose(hex){ try{ let out=''; for(let i=0;i<hex.length;i+=2){ const b=parseInt(hex.slice(i,i+2),16); if(!b) break; out+=String.fromCharCode(b);} return out||'XRBC'; }catch{ return 'XRBC'; } }
    const XRBC_CODE=hexToAsciiLoose(XRBC_HEX);

    async function hasXRBCTrustLine(acct){
      const r=await call('account_lines',{account:acct,peer:XRBC.issuer,limit:400});
      const lines=r?.lines||[]; return lines.some(l=>((l.currency||'').toUpperCase()===XRBC_CODE.toUpperCase())||((l.currency||'').toUpperCase()===XRBC_HEX));
    }
    async function addXRBCTrustLine(){
      if(!state.account || !state.adapter){ setStatus($buyStatus,'Connect wallet first.','err'); return; }
      setStatus($buyStatus,'Checking trust line…');
      try{
        const exists=await hasXRBCTrustLine(state.account);
        if(exists){ setStatus($buyStatus,'XRBC trust line already exists.','ok'); return; }
        // Allow rippling: tfClearNoRipple = 0x00040000
        const tx=attachMemos({
          TransactionType:'TrustSet',
          Account:state.account,
          LimitAmount:{ currency:XRBC_HEX, issuer:XRBC.issuer, value:"1000000000" },
          Flags: 0x00040000
        });
        __LS_CHALLENGE = newChallenge6(); announceChallenge();
        await state.adapter.signAndSubmit(tx);
        setStatus($buyStatus,'TrustSet submitted (rippling allowed). Wait for validation then retry buy.','ok');
      }catch(e){ setStatus($buyStatus,'TrustSet error: '+(e.message||e),'err'); }
    }
    async function pathFindBuy(acct,valueStr){
      const AMOUNT={currency:XRBC_HEX,issuer:XRBC.issuer,value:valueStr};
      const pfWrap=await xrplRequest({ method:'ripple_path_find', params:[{ source_account:acct, destination_account:acct, destination_amount:AMOUNT, source_currencies:[{currency:"XRP"}] }] }, {timeoutMs:15000});
      const pf=pfWrap?.result||{}; const alts=pf?.alternatives||[]; if(!alts.length) throw new Error('No path found for requested amount');
      let best=null;
      for(const a of alts){
        const sa=a.source_amount;
        const drops=typeof sa==='string'?N(sa):(sa && sa.currency==='XRP' ? Math.round(N(sa.value)*XRP_TO_DROPS) : Infinity);
        if(!isFinite(drops)) continue;
        if(!best || drops<best.drops) best={alt:a,drops};
      }
      if(!best) throw new Error('No XRP route available');
      const headroom = Math.ceil(best.drops * (1 + QUICK_BUY_SLIPPAGE_PCT / 100));
      return attachMemos({ TransactionType:'Payment', Account:acct, Destination:acct, Amount:AMOUNT, SendMax:String(headroom), Paths:best.alt.paths_computed||[] });
    }
    async function buyXRBC(units){
      if(!state.account || !state.adapter){ setStatus($buyStatus,'Connect wallet first.','err'); return; }
      try{
        setStatus($buyStatus,`Preparing to buy ${units} ${XRBC_CODE}…`);
        const exists=await hasXRBCTrustLine(state.account);
        if(!exists){ setStatus($buyStatus,'No XRBC trust line. Use “Add XRBC Trust Line” first.','err'); return; }
        const tx=await pathFindBuy(state.account,String(units));
        __LS_CHALLENGE = newChallenge6(); announceChallenge();
        const res=await state.adapter.signAndSubmit(tx);
        setStatus($buyStatus,`Buy submitted. Hash: ${(res && res.hash)?res.hash:'(pending)'}`,'ok');
      }catch(e){ setStatus($buyStatus,(e && e.message) || 'Buy failed','err'); }
    }

    /* ===== Wire UI ===== */
    document.getElementById('btnTrustXRBC')?.addEventListener('click',()=>addXRBCTrustLine());
    document.getElementById('buy1')?.addEventListener('click',()=>buyXRBC(1));
    document.getElementById('buy25')?.addEventListener('click',()=>buyXRBC(25));
    document.getElementById('buy50')?.addEventListener('click',()=>buyXRBC(50));
    document.getElementById('buy100')?.addEventListener('click',()=>buyXRBC(100));

    document.getElementById('btnXumm')?.addEventListener('click',()=>connectWith(XummAdapter));
    document.getElementById('btnDisconnect')?.addEventListener('click',()=>disconnect());
    document.getElementById('network')?.addEventListener('change',()=>{
      state.network = document.getElementById('network').value==='testnet' ? 'testnet' : 'mainnet';
      updateNetUI(); if(state.account) { refreshAll(); }
    });

    if ($btnHealthScan) $btnHealthScan.addEventListener('click', ()=>{ refreshHealth().catch(e=>setStatus($healthStatus, e?.message||'Health error','err')); });
    if ($riskOnly) $riskOnly.addEventListener('change', applyRiskFilter);
    if ($btnHealthRetry) $btnHealthRetry.addEventListener('click', ()=>{ refreshHealth().catch(e=>setStatus($healthStatus, e?.message||'Health error','err')); });

    if ($btnCopyChallenge) $btnCopyChallenge.addEventListener('click', async ()=>{
      if (!__LS_CHALLENGE){ setStatus($walletStatus,'No code yet — start a sign flow first.'); return; }
      try { await navigator.clipboard.writeText(__LS_CHALLENGE); setStatus($walletStatus,'Code copied','ok'); }
      catch { setStatus($walletStatus,'Copy failed (permissions)','err'); }
    });
    if ($btnClearLog) $btnClearLog.addEventListener('click', ()=>{
      if ($log) $log.textContent = '';
      setStatus($walletStatus,'Log cleared');
    });

    /* ===== Boot ===== */
    updateNetUI();
    if (BOOT.autoResume !== false) { tryResumeWallet().finally(()=>updateConnectButtons()); }
    if (BOOT.autoLoadData !== false) { setTimeout(()=>{ if(state.account){ refreshAll(); } }, 400); }
    if (BOOT.refreshOnFocus) {
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible' && state.account) refreshAll();
      });
      window.addEventListener('focus', () => { if (state.account) refreshAll(); });
    }

    /* ===== Footer year (optional) ===== */
    (function(){
      const y0 = FIRST_COMMIT_YEAR, y1 = new Date().getFullYear();
      const el = document.getElementById('copyrightYear');
      if (el) el.textContent = (y1 > y0) ? (y0 + '–' + y1) : String(y0);
    })();

  })();
  </script>
</body>
</html>
