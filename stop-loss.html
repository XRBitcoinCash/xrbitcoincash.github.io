<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="license" href="#license-proprietary">
  <meta charset="utf-8" />
  <title>Instant Stop Loss · XRPL · XRBitcoinCash</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="canonical" href="https://xrbitcoincash.com/stop-loss-legal.html" />
  <link rel="alternate" hreflang="en" href="https://xrbitcoincash.com/stop-loss-legal.html" />
  <meta name="description" content="Automatic & manual stop-loss for XRPL tokens, Sequential Panic Sell (tokens → XRP or stable), and XRBC Quick Buy. Xaman supported. Secure, non-custodial." />
  <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
  <meta name="theme-color" content="#0b0f14" />
  <meta name="referrer" content="strict-origin-when-cross-origin">
  <meta name="color-scheme" content="dark light">

  <link rel="icon" href="/favicon.ico?v=1" sizes="any">
  <link rel="icon" type="image/png" href="/xrbc-nft.png">
  <link rel="apple-touch-icon" href="/xrbc-nft.png">
  <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg?v=1" color="#0b0f14">
  <meta name="msapplication-TileColor" content="#0b0f14">

  <meta property="og:type" content="website">
  <meta property="og:site_name" content="XRBitcoinCash">
  <meta property="og:title" content="Instant Stop Loss · XRPL · XRBitcoinCash">
  <meta property="og:description" content="Automatic & manual stop-loss for XRPL tokens, Sequential Panic Sell, and XRBC Quick Buy. Xaman supported.">
  <meta property="og:url" content="https://xrbitcoincash.com/stop-loss-legal.html">
  <meta property="og:image" content="https://xrbitcoincash.com/xrbc-nft.png">
  <meta property="og:image:secure_url" content="https://xrbitcoincash.com/xrbc-nft.png">
  <meta property="og:image:alt" content="XRBitcoinCash — XRBC logo">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Instant Stop Loss · XRPL · XRBitcoinCash">
  <meta name="twitter:description" content="Automatic & manual stop-loss for XRPL tokens, Sequential Panic Sell, and XRBC Quick Buy. Xaman supported.">
  <meta name="twitter:image" content="https://xrbitcoincash.com/xrbc-nft.png">
  <meta name="twitter:image:alt" content="XRBitcoinCash — XRBC logo">

  <link rel="preconnect" href="https://xaman.app" crossorigin>
  <link rel="preconnect" href="https://xrbitcoincash-github-io.onrender.com" crossorigin>

  <style>
:root{
  --wrap:1100px;--bg:#0b0f14;--panel:#0e1520;--panel-2:#0c131c;--ink:#e7edf5;--muted:#9fb0c5;--line:#2b3a4b;
  --ok:#22c55e;--err:#ef4444;--blue:#2563eb;--yellow:#f59e0b
}
*{box-sizing:border-box}html,body{height:100%;max-width:100%;overflow-x:hidden}
body{background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;margin:0}
.container{max-width:var(--wrap);margin:16px auto;padding:0 max(16px, env(safe-area-inset-left))}
.card{background:linear-gradient(180deg,var(--panel),var(--panel-2));border:1px solid var(--line);border-radius:14px;padding:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);margin-top:10px}
h1,h2,h3{margin:.1em 0}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
.row-tight{display:flex;gap:6px;flex-wrap:wrap;align-items:center;justify-content:flex-end}
.center{justify-content:center}
.between{justify-content:space-between}
.col{display:flex;flex-direction:column;gap:10px;align-items:center}
.btn{appearance:none;border:1px solid var(--line);border-radius:12px;background:linear-gradient(180deg,#0e1520,#0c131c);color:var(--ink);padding:10px 14px;font-weight:800;cursor:pointer;min-height:44px;text-decoration:none;display:inline-flex;align-items:center;justify-content:center;text-align:center;white-space:normal;max-width:100%}
.btn.block{width:100%;max-width:360px}
.btn.small{font-weight:700;padding:6px 10px;min-height:32px;border-radius:10px}
.btn:disabled{opacity:.6;cursor:not-allowed}
.glow-green{box-shadow:0 0 0 2px rgba(34,197,94,.25), 0 0 20px rgba(34,197,94,.18)}
.glow-red{box-shadow:0 0 0 2px rgba(239,68,68,.25), 0 0 20px rgba(239,68,68,.18)}
.glow-yellow{box-shadow:0 0 0 2px rgba(245,158,11,.25), 0 0 20px rgba(245,158,11,.18)}
.glow-blue{box-shadow:0 0 0 2px rgba(37,99,235,.25), 0 0 20px rgba(37,99,235,.18)}
.status{font-size:13px;color:var(--muted)} .status.ok{color:var(--ok)} .status.err{color:var(--err)}
table{width:100%;border-collapse:collapse;margin-top:10px;font-size:14px}
th,td{padding:8px 10px;border-bottom:1px solid #1a2433;text-align:left;vertical-align:top}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
.hint{color:var(--muted);font-size:12.5px}
.warn{border-left:4px solid #d97706;background:linear-gradient(180deg,#231b0c,#1a140a);border:1px solid #3a2f18;border-radius:10px;padding:10px;color:#f3e8d0}
.footer{margin-top:16px;color:var(--muted);font-size:12px}
.badge{display:inline-block;padding:2px 8px;border:1px solid var(--line);border-radius:9999px;margin-left:8px}
.badge.testnet{background:#102018;color:#9fe29f;border-color:#2c4} .badge.mainnet{background:#181820;color:#cfd2ff;border-color:#44c}
.progress{height:6px;background:#112035;border-radius:9999px;overflow:hidden;margin-top:8px}
.progress>span{display:block;height:100%;background:var(--blue);width:0%}
.panel-note{border:1px dashed var(--line);border-radius:10px;padding:8px 10px;margin-top:8px}
.panel-note-green{border-color:#14532d;color:#22c55e}
.log{max-height:200px;overflow:auto;border:1px solid #1a2433;border-radius:10px;padding:8px;background:#0b111a;font-size:12px;white-space:pre-wrap}
.logo{display:flex;align-items:center;gap:10px}
.btn-green{ border-color:#14532d; background:linear-gradient(180deg,#0f1f16,#0b1510); }
.btn-blue{  border-color:#1e3a8a; background:linear-gradient(180deg,#0f172a,#0b1324); }
.btn-yellow{border-color:#713f12; background:linear-gradient(180deg,#1e1606,#191104); }
.btn-red{   border-color:#7f1d1d; background:linear-gradient(180deg,#1a0d0d,#140a0a); }
.text-red{ color: var(--err); font-weight: 800; }
.text-green{ color: var(--ok); font-weight: 700; }
body.embed .container{max-width:none}
body.embed .card{border-radius:0;box-shadow:none;border:none;margin-top:0}
body.embed header{display:none}
.container, .card, .row, .btn { min-width: 0; }
.card .row { justify-content: center; }

/* Responsive tweaks */
@media (max-width: 720px) {
  .card h1, .card h2, .card h3, .card p.hint { text-align: center; }
  #offersWrap { overflow-x: auto; }
  #offersWrap table { min-width: 520px; }
}
@media (max-width: 420px) { .btn { padding: 10px 12px; } }

/* Header grid */
.hero-top{display:grid;grid-template-columns:1fr auto 1fr;align-items:center}
.hero-top .left{justify-self:start}
.hero-top .center{justify-self:center}
.hero-top .right{justify-self:end;text-align:right}

/* === Stop-Loss Planner: visual emphasis === */
.hint-yellow { color: var(--yellow); font-weight: 700; }

/* Blue glow container for the per-token planner grid */
#slTokens{
  border: 1px solid var(--line);
  border-left: 4px solid #60a5fa;
  background: linear-gradient(180deg,#0e1520,#0c131c);
  box-shadow: 0 0 0 2px rgba(37,99,235,.25), 0 0 20px rgba(37,99,235,.18);
  border-radius: 10px;
  padding: 8px;
}

/* Keep table stable & shrinkable */
#slTokens table{ table-layout: fixed; width: 100%; }
#slTokens table th, #slTokens table td{
  min-width: 0;
  word-break: break-word;
  overflow-wrap: anywhere;
}

/* --- Column color mapping (assumes: 2=Hex, 3=Issuer, 4=Balance, 5=Amount) --- */
/* Token Hex → white */
#slTokens table thead th:nth-child(2),
#slTokens table tbody td:nth-child(2){
  color:#ffffff;
  font-weight:700;
}
/* Issuer → blue */
#slTokens table thead th:nth-child(3),
#slTokens table tbody td:nth-child(3){
  color:var(--blue);
  font-weight:700;
}
/* Balance → orange */
#slTokens table thead th:nth-child(4),
#slTokens table tbody td:nth-child(4){
  color:var(--yellow);
  font-weight:700;
}
/* Amount to protect → green (emphasis) */
#slTokens table thead th:nth-child(5),
#slTokens table tbody td:nth-child(5){
  color:var(--ok);
  font-weight:800;
}

/* Subtle widths to avoid overflow on phones (approximate) */
#slTokens table thead th:nth-child(2),
#slTokens table tbody td:nth-child(2){ width:34%; }
#slTokens table thead th:nth-child(3),
#slTokens table tbody td:nth-child(3){ width:22%; }
#slTokens table thead th:nth-child(4),
#slTokens table tbody td:nth-child(4){ width:22%; }
#slTokens table thead th:nth-child(5),
#slTokens table tbody td:nth-child(5){ width:22%; }

/* ===== Mobile-only refinements (desktop unchanged) ===== */
@media (max-width: 560px){
  /* Tighter monospace for long codes (Hex/Issuer lines) */
  #slTokens .mono{ font-size:12px; line-height:1.2; }

  /* Even smaller Hex on phones so it stays inside the hero card */
  #slTokens table thead th:nth-child(2),
  #slTokens table tbody td:nth-child(2){
    font-size:11px;
    line-height:1.15;
  }

  /* Ensure inputs/selects never push outside card */
  .row input, .row select, .row textarea{
    max-width:100%;
    min-width:0;
  }

  /* Re-order “orange explanations” to sit under headings, above controls */
  .row{ display:grid; grid-template-columns:1fr; align-items:start; row-gap:6px; }
  /* Headings first */
  .row > h1, .row > h2, .row > h3, .row > h4, .row > label{ order:0; }
  /* Then orange hint (Mode / Value / Exit instructions) */
  .row > .hint-yellow{ order:1; }
  /* Generic hint can also appear under title if present */
  .row > .hint{ order:1; }
  /* Controls/buttons after the hint */
  .row > button,
  .row > .btn,
  .row > input,
  .row > select,
  .row > textarea,
  .row > .controls,
  .row > .field,
  .row > .row{ order:2; }

  /* Panic/Sequential card: warnings should appear UNDER the action buttons */
  .row .warn{
    order:99;
    width:100%;
    margin-top:8px;
  }
}

  </style>

  <!-- Xaman SDK (keep) -->
  <script src="https://xaman.app/assets/cdn/xumm.min.js" crossorigin="anonymous"></script>
</head>
<body>
<noscript>
  <div class="card" style="max-width:var(--wrap);margin:16px auto;color:#fca5a5;border-color:#7f1d1d">
    This tool requires JavaScript to function. Please enable JavaScript to use wallet connect, previews, and signing.
  </div>
</noscript>

<main class="container" aria-live="polite">

  <!-- PRIMARY CARD -->
  <section class="card" id="primary" aria-labelledby="hero-title">
    <div class="hero-top">
      <div class="left logo">
        <img src="/xrbc-nft.png" alt="XRBC" width="32" height="32"
             style="border-radius:6px;border:1px solid var(--line)" loading="lazy" decoding="async">
      </div>
      <div class="center">
        <a class="btn glow-blue" href="/index.html" id="btnHome" title="Go to Home">Home</a>
      </div>
      <div class="right">
        <button id="btnNetBadge" class="btn small" type="button" disabled>Mainnet</button>
        <div class="row-tight" style="margin-top:6px">
          <label class="hint" for="network">Network</label>
          <select id="network" aria-label="Network">
            <option value="mainnet" selected>Mainnet</option>
            <option value="testnet">Testnet</option>
          </select>
        </div>
      </div>
    </div>

    <div class="col" style="margin-top:8px">
      <h1 id="hero-title" style="margin:0">Instant Stop Loss</h1>
      <p class="hint" style="margin:0">Automatic &amp; manual stop-loss for XRPL tokens + Sequential Panic Sell. Mobile-first. Desktop QR. Signing in Xaman.</p>
    </div>

    <div class="row center" style="margin-top:10px">
      <button id="btnXumm" class="btn glow-green" type="button" title="Connect with Xaman wallet">Connect Xaman</button>
      <button id="btnDisconnect" class="btn glow-red" type="button" disabled>Disconnect</button>
    </div>
    <p id="walletStatus" class="status">Status: Not connected</p>

    <div class="panel-note">
      <p class="hint" style="margin:0">Raw secret signing disabled. Use a wallet. No keys stored.</p>
    </div>

    <!-- Hero: red/green disclaimers for instant recognition -->
    <div class="panel-note" role="note" aria-live="polite">
      <p class="text-red" style="margin:0 0 6px 0">
        <strong>Liquidity safeguard is ON.</strong> Tokens with <em>no viable route</em> or below the <em>minimum-liquidity threshold</em> are
        <strong>automatically blocked</strong> (not submitted) — protecting liquidity during pool migrations, upgrades, or outages.
      </p>
      <p class="text-green" style="margin:0">
        <strong>Safety measures:</strong> Auto-skip low-liquidity · sequential one-signature flow · clear preview flags · your funds never leave your wallet unless you approve.
        Default threshold: <strong>2&nbsp;XRP</strong> (or <strong>2&nbsp;RLUSD</strong> when exiting to RLUSD).
      </p>
    </div>

    <div id="offersWrap" class="hint">No data yet.</div>
    <div class="progress" aria-hidden="true"><span id="progressBar"></span></div>
    <p id="offersStatus" class="status"></p>
  </section>

  <!-- STOP-LOSS PLANNER -->
  <section class="card" aria-labelledby="slp">
    <h2 id="slp">Stop-Loss Planner (per token)</h2>
    <p class="hint">Create on-ledger stop-limit sells that trigger at your level. No bots or custody.</p>

    <div id="slTokens" class="hint">Loading your token balances…</div>

    <!-- Yellow explanations moved here -->
    <div class="row center" style="margin-top:6px;gap:14px">
      <div class="hint hint-yellow" style="max-width:220px;text-align:center">
        <strong>Mode</strong> — choose “% below current” or “Exact stop price”.
      </div>
      <div class="hint hint-yellow" style="max-width:220px;text-align:center">
        <strong>Value</strong> — enter the percentage or the exact stop price.
      </div>
      <div class="hint hint-yellow" style="max-width:220px;text-align:center">
        <strong>Exit</strong> — the asset you’ll receive when it triggers (XRP or RLUSD).
      </div>
    </div>

    <div class="row center" style="margin-top:10px">
      <label class="hint" style="display:flex;gap:8px;align-items:center">
        Mode:
        <select id="slMode">
          <option value="pct" selected>% below current</option>
          <option value="price">Exact stop price</option>
        </select>
      </label>
      <label class="hint" style="display:flex;gap:8px;align-items:center">
        Value:
        <input id="slValue" type="number" step="0.000001" inputmode="decimal" autocomplete="off"
               placeholder="e.g., 10 for 10% or 0.123456" style="min-width:140px">
      </label>
      <label class="hint" style="display:flex;gap:8px;align-items:center">
        Exit to:
        <select id="slTarget">
          <option value="XRP" selected>XRP</option>
          <option value="RLUSD">RLUSD (stable)</option>
        </select>
      </label>
    </div>

    <div class="row center" style="margin-top:10px">
      <button id="btnPlanStops" class="btn glow-blue" type="button" title="Preview calculated stop prices and amounts">Preview Planned Stops</button>
      <button id="btnCreateStops" class="btn glow-green" type="button" title="Create and sign stop orders in Xaman" disabled>Create &amp; Sign Stops</button>
    </div>
    <div class="panel-note" style="margin-top:6px">
      <p class="hint" style="margin:0">Preview shows the stop price per token and amount to protect. “Create &amp; Sign” submits one Offer per selected token, signed sequentially in Xaman.</p>
    </div>
    <div id="slPlanOut" class="log" style="margin-top:10px"></div>
    <p id="slStatus" class="status"></p>
  </section>

  <!-- PANIC SELL -->
  <section class="card" aria-labelledby="panic">
    <h2 id="panic">Panic Sell — Sequential</h2>
    <div class="warn" style="margin-bottom:10px">
      <p class="text-red" style="margin:0 0 6px 0">
        <strong>Liquidity safeguard is ON.</strong> Tokens with <em>no viable route</em> or below the <em>minimum-liquidity threshold</em> are
        <strong>automatically blocked</strong> and will <strong>not</strong> be submitted for signing.
      </p>
      <p class="text-green" style="margin:0">
        <strong>Safety measures:</strong> Auto-skip low-liquidity · sequential one-signature flow (no “sell-all” spam) · preview lists order &amp; flags.
        Default threshold: <strong>2&nbsp;XRP</strong> (or <strong>2&nbsp;RLUSD</strong> when exiting to RLUSD). Transactions you do sign are final.
      </p>
    </div>

    <div class="row center">
      <label class="hint" style="display:flex;gap:8px;align-items:center">
        Exit to:
        <select id="panicTarget">
          <option value="XRP" selected>XRP</option>
          <option value="RLUSD">RLUSD (stable)</option>
        </select>
      </label>
      <label class="hint" style="display:flex;gap:8px;align-items:center">
        Slippage cap (%):
        <input id="panicSlip" type="number" step="0.1" value="2" inputmode="decimal" autocomplete="off" style="min-width:90px">
      </label>
      <label class="hint" style="display:flex;gap:8px;align-items:center">
        <input id="panicCancelFirst" type="checkbox" checked>
        Cancel all open orders first (frees reserve)
      </label>
    </div>

    <div class="row center" style="margin-top:10px">
      <button id="btnPanicPreview" class="btn glow-yellow" type="button" title="Check routes and sort by estimated proceeds">Preview Routes &amp; Order</button>
      <button id="btnPanicSell" class="btn glow-red" type="button" title="Submit sequentially; tokens with no route or below threshold are skipped">Sequential Panic Sell</button>
    </div>

    <div id="panicPlanOut" class="log" style="margin-top:10px"></div>
    <p id="panicStatus" class="status"></p>
  </section>

  <!-- QUICK BUY (XRBC) -->
  <section class="card" aria-labelledby="buyxrbc">
    <hr style="border:none;border-top:1px solid var(--line);margin:14px 0">
    <h2 id="buyxrbc">Quick Buy · XRBitcoinCash (XRBC)</h2>

    <div class="panel-note" style="margin-top:8px;border:1px solid var(--line);border-left:4px solid #60a5fa;border-radius:10px;padding:10px 12px;background:linear-gradient(180deg,#0e1520,#0c131c);">
      <p class="hint" style="margin:0;color:#60a5fa;font-weight:700;">
        Best available price at execution via XRPL pathfinding (AMM and/or order books) with a <strong>2% slippage cap</strong>.
        Review &amp; sign <strong>inside Xaman</strong> (desktop shows a QR). <strong>Trustline required.</strong>
      </p>
    </div>

    <div class="col" style="margin-top:8px">
      <button class="btn btn-green glow-green block"  id="buy1"   type="button" title="Cheapest">Buy 1 XRBC for XRP</button>
      <button class="btn btn-blue glow-blue block"    id="buy25"  type="button">Buy 25 XRBC for XRP</button>
      <button class="btn btn-yellow glow-yellow block"id="buy50"  type="button">Buy 50 XRBC for XRP</button>
      <button class="btn btn-red glow-red block"      id="buy100" type="button" title="Most expensive">Buy 100 XRBC for XRP</button>
    </div>

    <div class="col" style="margin-top:10px">
      <button id="btnTrustXRBC" class="btn block" type="button" title="Add XRBC Trust Line">Add XRBC Trust Line</button>
      <span class="hint">Issuer:
        <span class="mono" id="xrbcIssuerPill" style="display:inline-block;max-width:18ch;overflow-wrap:anywhere;word-break:break-all;vertical-align:top">
          rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw
        </span>
      </span>
    </div>

    <div class="panel-note panel-note-green" style="margin-top:10px">
      <div class="hint" style="color:#22c55e">Tip: Start small. Verify each wallet prompt. Routes and slippage can change.</div>
    </div>

    <p id="buyStatus" class="status"></p>
  </section>

  <!-- RESULTS -->
  <section class="card" aria-labelledby="res">
    <h2 id="res">Results</h2>
    <div id="resultBox" class="hint">Receipts and freed reserve will appear here.</div>
    <div class="panel-note" style="margin-top:10px">
      <div class="hint">Activity log</div>
      <pre id="log" class="log" aria-live="polite"></pre>
    </div>
  </section>

  <!-- EMBED -->
  <section class="card" aria-labelledby="embed">
    <h2 id="embed">Embed this tool on your site</h2>
    <p class="hint">Copy the snippet below. It renders an iframe in “embed mode.”</p>
    <div class="panel-note">
      <div class="row center" style="gap:8px">
        <button id="btnCopyIframe" class="btn glow-blue" type="button">Copy embed code</button>
        <a id="btnOpenDemo" class="btn" href="https://xrbitcoincash.com/stop-loss-legal.html?embed=1" target="_blank" rel="noopener">Open embed demo</a>
      </div>
<pre id="embedCode" class="log" style="user-select:all;white-space:pre-wrap">&lt;div id="xrbc-widget" style="width:100%;max-width:1100px;margin:auto"&gt;&lt;/div&gt;
&lt;script&gt;(function(w,d,c,u,h){var el=d.getElementById(c)||d.body.appendChild(Object.assign(d.createElement('div'),{id:c}));
var f=d.createElement('iframe');f.src=u;f.style.width='100%';f.style.minHeight=h;f.style.border='0';f.loading='lazy';el.appendChild(f);
})(window,document,'xrbc-widget','https://xrbitcoincash.com/stop-loss-legal.html?embed=1&amp;network=mainnet','980px');&lt;/script&gt;</pre>
    </div>
  </section>

  <!-- IMPORTANT + FULL LEGAL -->
  <section class="card" aria-labelledby="important">
    <h2 id="important">Important</h2>
    <div class="warn">
      <p><strong>No custody / no brokerage.</strong> XRBitcoinCash provides software that constructs XRPL transactions for you to review and sign <em>in your own wallet</em>. We do not take possession of funds, route orders on your behalf, execute trades, or provide brokerage, ATS, exchange, or advisory services.</p>
      <p><strong>Finality and risk.</strong> XRPL transactions are irreversible once validated. You are solely responsible for verifying asset, network, amounts, slippage, destinations, fees, and all details in your wallet before approval. Market conditions and routes may change between preview and signing.</p>
      <p><strong>“Panic Sell” function.</strong> Panic Sell attempts to liquidate multiple IOUs via XRPL pathfinding. Assets with no viable route or that fall below the minimum-liquidity threshold are <strong>automatically skipped</strong> and not submitted. For submitted transactions, partial fills and materially worse execution than previews can occur. Use at your own risk.</p>
      <p><strong>No guarantees / no warranties.</strong> The software is provided “AS IS” and “AS AVAILABLE” without warranties of any kind, express or implied, including merchantability, fitness for a particular purpose, non-infringement, uninterrupted availability, accuracy, or error-free operation.</p>
      <p><strong>Compliance is your responsibility.</strong> You are solely responsible for complying with all applicable laws (including sanctions, export controls, tax, securities/commodities, and consumer protection laws) in your jurisdiction(s). Access may be restricted where prohibited.</p>
      <p><strong>No investment advice / no solicitation.</strong> Nothing here constitutes investment, legal, accounting, or tax advice, or an offer or solicitation to buy or sell any asset. You should seek professional advice as needed.</p>
      <p><strong>Limitation of liability.</strong> To the maximum extent permitted by law, XRBitcoinCash and its contributors shall not be liable for any direct, indirect, incidental, special, consequential, exemplary, or punitive damages, or for any loss of profits, data, goodwill, or other losses, arising from or related to your use of, or inability to use, the software, even if advised of the possibility of such damages.</p>
      <p><strong>Assumption of risk.</strong> By using the software or embedding the widget, you acknowledge that digital assets are volatile and speculative, and you accept all risks associated with using XRPL and third-party wallets.</p>
    </div>

    <div id="license-proprietary" class="license" style="color:var(--muted);font-size:12px;white-space:pre-wrap;line-height:1.45;border-top:1px solid var(--line);padding-top:10px;margin-top:10px">
<strong>Proprietary License — Instant Stop Loss (XRPL)</strong>
Copyright (c) 2025 XRBitcoinCash. All rights reserved.
By accessing this page or embedding the widget, you accept the Important terms above and this License. You receive a limited, revocable, non-exclusive right to access the page and display the widget as provided, without modification of core functionality or removal of attribution. Access may be modified, throttled, or revoked at any time. No rights are granted to the trademarks “XRP” or “Xaman,” which are the property of their respective owners. XRBitcoinCash is not affiliated with Ripple, XRPL Labs, or Xaman.
    </div>
  </section>

</main>

<!-- App configuration (keep immediately before main script) -->
<script type="application/json" id="app-config">
{
  "proxyUrl": "https://xrbitcoincash-github-io.onrender.com",
  "xummApiKey": "2b433aaa-d2cc-4b75-a771-8a20433ac1c5",
  "networks": {
    "mainnet": { "label": "Mainnet" },
    "testnet": { "label": "Testnet" }
  },
  "xrbc": {
    "issuer": "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw",
    "currencyHex": "5852626974636F696E6361736800000000000000"
  },
  "boot": {
    "autoResume": true,
    "autoLoadData": true,
    "refreshOnFocus": true
  }
}
</script>

<!-- Main script (unchanged) -->
<script>
/* === JS kept exactly as your current version (no edits) === */
(function(){
  'use strict';

  const FIRST_COMMIT_YEAR = 2025;

  // ===== Embed mode
  (function initEmbedMode(){
    try { const q=new URLSearchParams(location.search); if (q.get('embed')==='1') document.body.classList.add('embed'); } catch {}
  })();

  // ===== Copy embed code
  (function initCopy(){
    const btn=document.getElementById('btnCopyIframe'); const pre=document.getElementById('embedCode');
    if(!btn||!pre) return;
    btn.addEventListener('click', async ()=>{
      try{ await navigator.clipboard.writeText(pre.textContent); btn.textContent='Copied';
        setTimeout(()=>btn.textContent='Copy embed code',1200);
      }catch{
        const r=document.createRange(); r.selectNode(pre); const sel=window.getSelection();
        sel.removeAllRanges(); sel.addRange(r); document.execCommand('copy'); sel.removeAllRanges();
        btn.textContent='Copied'; setTimeout(()=>btn.textContent='Copy embed code',1200);
      }
    });
  })();

  // ===== CONFIG
  const cfg = JSON.parse(document.getElementById('app-config').textContent || '{}');
  const PROXY_BASE   = cfg.proxyUrl || '';
  const XUMM_API_KEY = cfg.xummApiKey || '';
  const XRBC         = cfg.xrbc || {};
  const BOOT         = cfg.boot || {};
  const XRP_TO_DROPS = 1_000_000;

  // ===== STATE
  const state = { network:'mainnet', account:null, adapter:null, offers:[], lastAccountInfo:null };

  // ===== DOM
  const $ = id => document.getElementById(id);
  const $walletStatus = $('walletStatus');
  const $offersStatus = $('offersStatus');
  const $offersWrap   = $('offersWrap');
  const $resultBox    = $('resultBox');
  const $log          = $('log');
  const $btnXumm      = $('btnXumm');
  const $btnDisconnect= $('btnDisconnect');
  const $btnRefresh   = $('btnRefresh');
  const $btnCancelAll = $('btnCancelAll');
  const $networkSel   = $('network');
  const $btnNetBadge  = $('btnNetBadge');
  const $progress     = $('progressBar');
  const $buyStatus    = $('buyStatus'); // quick buy status

  // Stop-loss & Panic DOM
  const $slTokens = $('slTokens');
  const $slMode   = $('slMode');
  const $slValue  = $('slValue');
  const $slTarget = $('slTarget');
  const $slPlanOut= $('slPlanOut');
  const $slStatus = $('slStatus');

  const $panicTarget    = $('panicTarget');
  const $panicSlip      = $('panicSlip');
  const $panicCancelFirst = $('panicCancelFirst');
  const $panicPlanOut   = $('panicPlanOut');
  const $panicStatus    = $('panicStatus');
  const $btnPanicPreview= $('btnPanicPreview');
  const $btnPanicSell   = $('btnPanicSell');

  // ===== UTILS
  function log(s){ if($log){ $log.textContent += s + '\n'; $log.scrollTop = $log.scrollHeight; } }
  function setStatus(node,text,cls){
    if(!node) return; node.textContent=text; node.classList.remove('ok','err'); if(cls) node.classList.add(cls);
    if(node===$offersStatus) log('[offers] '+text); else if(node===$walletStatus) log('[wallet] '+text);
    else if(node===$slStatus) log('[stop] '+text); else if(node===$panicStatus) log('[panic] '+text);
  }
  const N=v=>Number.isFinite(Number(v))?Number(v):0;
  const isXRP=a=>typeof a==='string'||(a&&a.currency==='XRP');
  const fmtDrops=d=>(N(d)/XRP_TO_DROPS).toFixed(6)+' XRP';
  const amtStr=a=>isXRP(a)?fmtDrops(a):(Number(a.value).toFixed(6)+' '+(a.currency||'IOU'));
  const price=(gets,pays)=>{ const g=isXRP(gets)?N(gets)/XRP_TO_DROPS:N(gets.value); const p=isXRP(pays)?N(pays)/XRP_TO_DROPS:N(pays.value); return g>0?(p/g).toFixed(6):'—'; };
  function setProgress(pct){ if($progress) $progress.style.width=Math.max(0,Math.min(100,pct))+'%'; }
  function updateNetUI(){
    const s = state.network==='testnet'?'Testnet':'Mainnet';
    if($btnNetBadge){ $btnNetBadge.textContent=s; $btnNetBadge.className='btn small badge ' + (s==='Testnet'?'testnet':'mainnet'); }
  }
  function proxyUrl(){ return PROXY_BASE + (state.network==='testnet' ? '?network=testnet' : ''); }
  function updateConnectButtons(){
    const connected = Boolean(state.account && state.adapter);
    if($btnXumm){ $btnXumm.disabled = connected; $btnXumm.style.display = connected ? 'none' : ''; $btnXumm.textContent='Connect Xaman'; }
    if($btnDisconnect){ $btnDisconnect.disabled = !connected; $btnDisconnect.style.display = connected ? '' : 'none'; }
  }
  function hexToAscii(hex){
    try{
      const clean = hex.replace(/[^0-9A-F]/gi,'').toUpperCase();
      if(clean.length%2!==0 || clean.length<2) return null;
      let out=''; for(let i=0;i<clean.length;i+=2){ const b=parseInt(clean.slice(i,i+2),16); if(!b) break; if(b<32 || b>126) return null; out+=String.fromCharCode(b); }
      return out || null;
    }catch{ return null; }
  }
  function tokenDisplay(code){
    const isHex = /^[0-9A-F]{10,}$/.test(code);
    if(!isHex) return { ticker: code, hex: null, label: code };
    const ascii = hexToAscii(code);
    if(ascii) return { ticker: ascii, hex: code, label: `${ascii} (${code})` };
    return { ticker: null, hex: code, label: code };
  }

  // ===== XRPL PROXY
  async function xrplRequest(payload,{timeoutMs=12000}={}){
    if(!PROXY_BASE) throw new Error('Proxy URL missing');
    const ctrl=new AbortController(); const t=setTimeout(()=>ctrl.abort(),timeoutMs);
    try{
      const res=await fetch(proxyUrl(),{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload), signal:ctrl.signal, redirect:'error', cache:'no-store', credentials:'omit' });
      if(!res.ok) throw new Error('Proxy HTTP '+res.status);
      const data=await res.json(); if(data && data.error) throw new Error('XRPL '+(data.error?.message||'error')); return data;
    } finally { clearTimeout(t); }
  }
  async function call(method,params){ const r=await xrplRequest({method,params:[{...params,ledger_index:'validated'}]}); return r?.result; }

  // ===== DATA
  async function getAccountInfo(acct){ const r=await call('account_info',{account:acct}); return r?.account_data||{}; }
  async function fetchOffers(acct){
    setStatus($offersStatus,'Loading open orders…');
    try{
      const r=await call('account_offers',{account:acct,limit:500});
      state.offers=r?.offers||[]; renderOffers();
      setStatus($offersStatus,`Found ${state.offers.length} open offer(s).`,'ok');
    }catch(e){
      state.offers=[]; renderOffers();
      setStatus($offersStatus,'Error loading offers: '+(e.message||e),'err');
    }
  }
  function renderOffers(){
    $offersWrap.innerHTML='';
    if(!state.offers.length){
      const d=document.createElement('div'); d.className='hint'; d.textContent='No open offers found.'; $offersWrap.appendChild(d); return;
    }
    const wrap=document.createElement('div'); wrap.style.overflow='auto';
    const table=document.createElement('table'); const thead=document.createElement('thead'); const trh=document.createElement('tr');
    ['Offer Seq','Owner gets','Owner pays','Price','Action'].forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
    thead.appendChild(trh); table.appendChild(thead);
    const tbody=document.createElement('tbody');
    state.offers.forEach(o=>{
      const tr=document.createElement('tr');
      const tdSeq=document.createElement('td'); tdSeq.className='mono'; tdSeq.textContent=o.seq; tr.appendChild(tdSeq);
      const tdGets=document.createElement('td'); tdGets.textContent=amtStr(o.taker_gets); tr.appendChild(tdGets);
      const tdPays=document.createElement('td'); tdPays.textContent=amtStr(o.taker_pays); tr.appendChild(tdPays);
      const tdPx=document.createElement('td'); tdPx.textContent=price(o.taker_gets,o.taker_pays); tr.appendChild(tdPx);
      const tdAct=document.createElement('td'); const b=document.createElement('button'); b.className='btn'; b.type='button'; b.textContent='Cancel';
      b.addEventListener('click',()=>cancelOne(o.seq)); tdAct.appendChild(b); tr.appendChild(tdAct);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody); wrap.appendChild(table); $offersWrap.appendChild(wrap);
  }
  async function beforeAfterReserveReport(acct,prevInfo){
    try{
      const now=await getAccountInfo(acct);
      const prevBal=N(prevInfo?.Balance)/XRP_TO_DROPS; const nowBal=N(now?.Balance)/XRP_TO_DROPS;
      const prevOwn=N(prevInfo?.OwnerCount); const nowOwn=N(now?.OwnerCount);
      const freed=Math.max(0,prevOwn-nowOwn)*2; const delta=(nowBal-prevBal).toFixed(6);
      $resultBox.innerHTML = `<div>Freed reserve: <strong>${freed.toFixed(6)} XRP</strong>. Balance change: <strong>${delta} XRP</strong>.</div>`;
    }catch{}
  }

  // ===== ADAPTERS
  class WalletAdapter { name='Base'; async connect(){throw new Error('not implemented');} async signAndSubmit(_tx){throw new Error('not implemented');} async disconnect(){} }
  class XummAdapter extends WalletAdapter{
    constructor(){ super(); this.name='Xaman'; this.xumm=null; }
    async ensureSDK(){ if(typeof Xumm==='undefined') throw new Error('Xaman SDK not loaded'); if(!XUMM_API_KEY) throw new Error('Xaman API key missing'); if(!this.xumm) this.xumm=new Xumm(XUMM_API_KEY); }
    async resume(){
      await this.ensureSDK();
      const acct = await this.xumm.user.account;
      if(acct){ return { address: acct }; }
      return null;
    }
    async connect(){
      await this.ensureSDK();
      await this.xumm.authorize();
      const acct=await this.xumm.user.account;
      if(!acct) throw new Error('No account returned');
      return { address: acct };
    }
    async signAndSubmit(txjson){
      const { resolved, websocket, unsubscribe } = await this.xumm.payload.createAndSubscribe(
        { txjson, options:{ submit:true, expire:300 } },
        ev => {
          if (ev?.opened) setStatus($walletStatus,'Open Xaman to review & sign…');
          if (ev?.signed === false) setStatus($walletStatus,'Canceled in wallet.','err');
        }
      );
      const res = await resolved;
      try{ websocket?.close(); }catch{}
      try{ typeof unsubscribe==='function' && unsubscribe(); }catch{}
      if(!res?.signed) throw new Error('User rejected');
      return { hash: res?.txid || res?.id || '(pending)', result:'submitted' };
    }
    async disconnect(){ try{ await this.xumm?.logout(); }catch{} }
  }

  // ===== CONNECT HELPERS
  function setAdapter(ad){ state.adapter = ad; updateConnectButtons(); }
  async function refreshAll(){
    if(!state.account) return;
    updateNetUI();
    state.lastAccountInfo = await getAccountInfo(state.account);
    await Promise.allSettled([ fetchOffers(state.account), refreshSLTokens() ]);
  }
  async function connectWith(AdapterClass){
    try{
      setStatus($walletStatus,'Connecting…');
      const ad = new AdapterClass();
      const { address } = await ad.connect();
      state.account = address; setAdapter(ad);
      localStorage.setItem('xrbc.lastAccount', address);
      setStatus($walletStatus, ad.name+': '+address, 'ok');
      $btnDisconnect.disabled = false;
      await refreshAll();
    }catch(e){
      setStatus($walletStatus,(e && e.message) || 'Connect failed','err');
    } finally { updateConnectButtons(); }
  }
  async function tryResumeWallet(){
    try{
      const ad = new XummAdapter();
      const resumed = await ad.resume();
      if(resumed && resumed.address){
        state.account = resumed.address; setAdapter(ad);
        setStatus($walletStatus, ad.name+': '+resumed.address, 'ok');
        $btnDisconnect.disabled = false;
        await refreshAll();
      } else {
        const cached = localStorage.getItem('xrbc.lastAccount');
        if(cached){ state.account = cached; setStatus($walletStatus,'Previously connected: '+cached,'ok'); }
      }
    } catch(e){}
    finally{ updateConnectButtons(); }
  }
  async function disconnect(){
    try{ await state.adapter?.disconnect?.(); }catch{}
    state.account=null; state.adapter=null; state.offers=[]; setProgress(0);
    localStorage.removeItem('xrbc.lastAccount');
    $offersWrap.innerHTML='<div class="hint">No data yet.</div>';
    setStatus($walletStatus,'Status: Not connected');
    setStatus($offersStatus,''); setStatus($slStatus,''); setStatus($panicStatus,'');
    $btnDisconnect.disabled=true; updateConnectButtons();
    $slTokens.textContent='Connect wallet first.';
    $slPlanOut.textContent=''; $panicPlanOut.textContent='';
  }

  // ===== CANCEL
  async function cancelOne(seq){
    if(!state.account || !state.adapter){ setStatus($offersStatus,'Connect wallet first.','err'); return; }
    setStatus($offersStatus,'Preparing cancel '+seq+'…');
    try{
      const tx={TransactionType:'OfferCancel',Account:state.account,OfferSequence:Number(seq)};
      const res=await state.adapter.signAndSubmit(tx);
      setStatus($offersStatus,`Submitted cancel ${seq}.`,'ok');
      await fetchOffers(state.account); log(`tx hash: ${res.hash || '(unknown)'}`); return res;
    }catch(e){ setStatus($offersStatus,'Error: '+(e.message||e),'err'); throw e; }
  }
  async function cancelAll(){
    if(!state.account || !state.adapter){ setStatus($offersStatus,'Connect wallet first.','err'); return; }
    if(!state.offers.length){ setStatus($offersStatus,'No visible offers to cancel.'); return; }
    if(!confirm(`Cancel ${state.offers.length} offer(s)? You will approve each in your wallet.`)) return;
    const beforeInfo = state.lastAccountInfo || await getAccountInfo(state.account);
    let i=0; const total=state.offers.length;
    for(const o of state.offers){ i++; setProgress(Math.floor((i-1)/total*100)); try{ await cancelOne(o.seq); }catch{} }
    setProgress(100); await beforeAfterReserveReport(state.account,beforeInfo);
    setStatus($offersStatus,'Done.','ok');
  }

  // ===== Slippage caps
  const ST_DEFAULT_SLIPPAGE_PCT = 2;
  const QUICK_BUY_SLIPPAGE_PCT  = 2;

  const TARGETS = {
    XRP:   { kind: 'XRP' },
    RLUSD: {
      kind: 'IOU',
      issuer: 'rMxCKbEDwqr76QuheSUMdEGf4B9xJ8m5De',
      currencyHex: '524C555344000000000000000000000000000000'
    }
  };

  const MIN_PANIC_VALUE = { XRP: 2, RLUSD: 2 };
  function belowMin(estValue, tgt){
    const min = tgt === 'RLUSD' ? MIN_PANIC_VALUE.RLUSD : MIN_PANIC_VALUE.XRP;
    return Number(estValue) < Number(min);
  }

  // ===== Token discovery (positive balances)
  async function listUserTokens(acct){
    const out = [];
    try{
      const r = await call('account_lines', { account: acct, limit: 400 });
      for(const l of (r?.lines || [])){
        const bal = Number(l.balance || 0);
        if (bal > 0) out.push({
          code: (l.currency || '').toString().toUpperCase(),
          issuer: l.account || l.issuer || l.account,
          balance: bal
        });
      }
    }catch{}
    return out;
  }

  // ===== Price helpers
  async function refPriceIOUtoXRP(currencyCode, issuer){
    try{
      const a = await xrplRequest({ method:'amm_info', params:[{ asset:{currency:'XRP'}, asset2:{currency:currencyCode, issuer} }] });
      const amm = a?.result?.amm;
      if (amm){
        const rx = Number(amm.amount) / 1_000_000;
        const ry = Number(amm.amount2?.value || 0);
        if (rx > 0 && ry > 0) return rx / ry;
      }
    }catch{}
    try{
      const r = await xrplRequest({ method:'book_offers', params:[{ taker_gets:{currency:'XRP'}, taker_pays:{currency:currencyCode, issuer}, limit:1 }] });
      const of = r?.result?.offers?.[0];
      if (of){
        const gets = Number(of.TakerGets) / 1_000_000;
        const pays = Number(of.TakerPays?.value);
        if (pays > 0) return gets / pays;
      }
    }catch{}
    return null;
  }
  async function refPriceIOUtoRLUSD(currencyCode, issuer){
    const RL = TARGETS.RLUSD;
    try{
      const a = await xrplRequest({ method:'amm_info', params:[{ asset:{currency:RL.currencyHex, issuer:RL.issuer}, asset2:{currency:currencyCode, issuer} }] });
      const amm = a?.result?.amm;
      if (amm){
        const rL = Number(amm.amount?.value || 0);
        const rT = Number(amm.amount2?.value || 0);
        if (rL > 0 && rT > 0) return rL / rT;
      }
    }catch{}
    try{
      const r = await xrplRequest({ method:'book_offers', params:[{ taker_gets:{currency:RL.currencyHex, issuer:RL.issuer}, taker_pays:{currency:currencyCode, issuer}, limit:1 }] });
      const of = r?.result?.offers?.[0];
      if (of){
        const gets = Number(of.TakerGets?.value);
        const pays = Number(of.TakerPays?.value);
        if (pays > 0) return gets / pays;
      }
    }catch{}
    return null;
  }

  // ===== Build offers
  function buildStopOfferXRP({ acct, currencyCode, issuer, amountIOU, stopPriceXrpPerIOU }){
    const TF_SELL = 0x00080000;
    const xrpTotal = Math.max(0, Number(amountIOU) * Number(stopPriceXrpPerIOU));
    return {
      TransactionType: 'OfferCreate',
      Account: acct,
      TakerGets: { currency: currencyCode, issuer, value: String(amountIOU) },
      TakerPays: String(Math.ceil(xrpTotal * 1_000_000)),
      Flags: TF_SELL
    };
  }
  function buildStopOfferRLUSD({ acct, currencyCode, issuer, amountIOU, stopPriceRLUSDperIOU }){
    const RL = TARGETS.RLUSD;
    const rlTotal = Math.max(0, Number(amountIOU) * Number(stopPriceRLUSDperIOU));
    return {
      TransactionType: 'OfferCreate',
      Account: acct,
      TakerGets: { currency: currencyCode, issuer, value: String(amountIOU) },
      TakerPays: { currency: RL.currencyHex, issuer: RL.issuer, value: String(rlTotal) },
      Flags: 0x00080000
    };
  }

  // ===== Pathfind payments
  async function pathfindSellIOUtoXRP({ acct, currencyCode, issuer, amountIOU, slippagePct }){
    const estPx = (await refPriceIOUtoXRP(currencyCode, issuer)) || 0;
    if (!estPx) throw new Error('No price');
    const estXrp = amountIOU * estPx;
    const slip = Math.max(0, Number(slippagePct)/100);
    const minDrops = Math.floor(Math.max(1, estXrp * (1 - slip) * 1_000_000)).toString();

    const pf = await xrplRequest({
      method:'ripple_path_find',
      params:[{
        source_account: acct,
        destination_account: acct,
        destination_amount: minDrops,
        source_currencies: [{ currency: currencyCode, issuer }]
      }]
    });
    const alt = (pf?.result?.alternatives || [])[0];
    if (!alt) throw new Error('No path');

    return {
      TransactionType: 'Payment',
      Account: acct,
      Destination: acct,
      Amount: minDrops,
      SendMax: { currency: currencyCode, issuer, value: String(amountIOU) },
      Flags: 0x00020000,
      DeliverMin: minDrops,
      Paths: alt.paths_computed || alt.paths_canonical || []
    };
  }
  async function pathfindSellIOUtoRLUSD({ acct, currencyCode, issuer, amountIOU, slippagePct }){
    const RL = TARGETS.RLUSD;
    const estPx = (await refPriceIOUtoRLUSD(currencyCode, issuer)) || 0;
    if (!estPx) throw new Error('No price');
    const estRl = amountIOU * estPx;
    const slip = Math.max(0, Number(slippagePct)/100);
    const minObj = { currency: RL.currencyHex, issuer: RL.issuer, value: String(estRl * (1 - slip)) };

    const pf = await xrplRequest({
      method:'ripple_path_find',
      params:[{
        source_account: acct,
        destination_account: acct,
        destination_amount: minObj,
        source_currencies: [{ currency: currencyCode, issuer }]
      }]
    });
    const alt = (pf?.result?.alternatives || [])[0];
    if (!alt) throw new Error('No path');

    return {
      TransactionType: 'Payment',
      Account: acct,
      Destination: acct,
      Amount: minObj,
      SendMax: { currency: currencyCode, issuer, value: String(amountIOU) },
      Flags: 0x00020000,
      DeliverMin: minObj,
      Paths: alt.paths_computed || alt.paths_canonical || []
    };
  }

  // ===== Refresh planner tokens
  async function refreshSLTokens(){
    if (!state.account){ $slTokens.textContent='Connect wallet first.'; return; }
    const toks = await listUserTokens(state.account);
    if (!toks.length){ $slTokens.textContent='No positive IOU balances found.'; return; }

    const tbl = document.createElement('table');

    const thead = document.createElement('thead');
    thead.innerHTML = '<tr><th></th><th>Token / Hex</th><th>Issuer</th><th>Balance</th><th>Amt to protect</th></tr>';
    tbl.appendChild(thead);

    const tb = document.createElement('tbody');

    for (const t of toks){
      const tr = document.createElement('tr');

      const tdPick = document.createElement('td');
      const pick = document.createElement('input');
      pick.type = 'checkbox';
      pick.className = 'slPick';
      tdPick.appendChild(pick);
      tr.appendChild(tdPick);

      const tdLabel = document.createElement('td');
      tdLabel.className = 'mono';
      tdLabel.textContent = tokenDisplay(t.code).label;
      tr.appendChild(tdLabel);

      const tdIssuer = document.createElement('td');
      tdIssuer.className = 'mono';
      tdIssuer.style.wordBreak = 'anywhere';
      tdIssuer.textContent = t.issuer;
      tr.appendChild(tdIssuer);

      const tdBal = document.createElement('td');
      tdBal.textContent = t.balance.toFixed(6);
      tr.appendChild(tdBal);

      const tdAmt = document.createElement('td');
      const amtInput = document.createElement('input');
      amtInput.type = 'number';
      amtInput.className = 'slAmt';
      amtInput.step = '0.000001';
      amtInput.value = String(Math.max(0, t.balance).toFixed(6));
      tdAmt.appendChild(amtInput);
      tr.appendChild(tdAmt);

      tb.appendChild(tr);
    }

    tbl.appendChild(tb);
    $slTokens.replaceChildren(tbl);
  }

  // ===== Stop-Loss plan
  document.getElementById('btnPlanStops')?.addEventListener('click', async ()=>{
    if (!state.account) return ($slStatus.textContent='Connect wallet first.');
    const rows = [...($slTokens.querySelectorAll('tbody tr')||[])];
    const picks = rows.map(row=>{
      const ckb = row.querySelector('.slPick'); if(!ckb?.checked) return null;
      const codeLabel = row.children[1].textContent.trim();
      const hexMatch = codeLabel.match(/\(([0-9A-F]{10,})\)$/);
      const code = hexMatch ? hexMatch[1] : codeLabel.split(' ')[0];
      const issuer = row.children[2].textContent.trim();
      const bal = Number(row.children[3].textContent||0);
      const amt = Number(row.querySelector('.slAmt')?.value||0);
      return { code, issuer, bal, amt, label: codeLabel };
    }).filter(Boolean);
    if (!picks.length) return ($slStatus.textContent='Pick at least one token.');

    const mode = $slMode.value; const val = Number($slValue.value||0);
    if (!val || val <= 0) return ($slStatus.textContent='Enter a % or price.');
    const tgt = $slTarget.value;

    const lines = [];
    for (const p of picks){
      const basePx = (tgt === 'RLUSD') ? await refPriceIOUtoRLUSD(p.code, p.issuer)
                                       : await refPriceIOUtoXRP(p.code, p.issuer);
      if (!basePx){ lines.push(`❌ ${p.label}: no price`); continue; }
      const stopPx = (mode==='pct') ? (basePx * (1 - val/100)) : val;
      const unit = (tgt === 'RLUSD') ? 'RLUSD/IOU' : 'XRP/IOU';
      lines.push(`✅ ${p.label}: stop ${stopPx.toFixed(6)} ${unit} · amount ${p.amt.toFixed(6)} IOU`);
    }
    $slPlanOut.textContent = lines.join('\n');
    document.getElementById('btnCreateStops').disabled = !lines.some(l=>l.startsWith('✅'));
  });

  // ===== Stop-Loss create
  document.getElementById('btnCreateStops')?.addEventListener('click', async ()=>{
    if (!state.account || !state.adapter) return ($slStatus.textContent='Connect wallet first.');
    const rows = [...($slTokens.querySelectorAll('tbody tr')||[])];
    const mode = $slMode.value; const val = Number($slValue.value||0);
    const tgt  = $slTarget.value;

    $slStatus.textContent='Building stop orders…';
    let ok=0, fail=0;
    for (const row of rows){
      const ckb=row.querySelector('.slPick'); if(!ckb?.checked) continue;
      const codeLabel = row.children[1].textContent.trim();
      const hexMatch = codeLabel.match(/\(([0-9A-F]{10,})\)$/);
      const code = hexMatch ? hexMatch[1] : codeLabel.split(' ')[0];
      const issuer = row.children[2].textContent.trim();
      const amt = Number(row.querySelector('.slAmt')?.value||0);
      if (!amt || amt<=0) { fail++; continue; }

      try{
        const basePx = (tgt === 'RLUSD') ? await refPriceIOUtoRLUSD(code, issuer)
                                         : await refPriceIOUtoXRP(code, issuer);
        if (!basePx) throw new Error('no price');
        const stopPx = (mode==='pct') ? (basePx * (1 - val/100)) : val;

        const tx = (tgt === 'RLUSD')
          ? buildStopOfferRLUSD({ acct: state.account, currencyCode: code, issuer, amountIOU: amt, stopPriceRLUSDperIOU: stopPx })
          : buildStopOfferXRP({ acct: state.account, currencyCode: code, issuer, amountIOU: amt, stopPriceXrpPerIOU: stopPx });

        await state.adapter.signAndSubmit(tx);
        ok++;
      }catch(e){ fail++; }
    }
    $slStatus.textContent = `Submitted ${ok} stop(s). Failed ${fail}.`;
  });

  // ===== Panic preview
  $btnPanicPreview?.addEventListener('click', async ()=>{
    if (!state.account) return ($panicStatus.textContent='Connect wallet first.');
    const toks = await listUserTokens(state.account);
    if (!toks.length){ $panicPlanOut.textContent='No positive IOU balances.'; return; }
    const tgt = $panicTarget.value;

    const rows = [];
    for (const t of toks){
      const disp = tokenDisplay(t.code).label;
      const px = (tgt === 'RLUSD') ? await refPriceIOUtoRLUSD(t.code, t.issuer)
                                   : await refPriceIOUtoXRP(t.code, t.issuer);
      if (px){
        const est  = px * t.balance;
        const unit = (tgt === 'RLUSD') ? 'RLUSD' : 'XRP';
        const low  = belowMin(est, tgt);
        rows.push({ ...t, disp, px, est, unit, route: !low, low });
      } else {
        rows.push({ ...t, disp, px:null, est:0, unit:(tgt==='RLUSD'?'RLUSD':'XRP'), route:false, low:false });
      }
    }
    rows.sort((a,b)=>b.est-a.est);

    const lines = rows.map(r=>{
      if(!r.px) return `❌ ${r.disp}: no route`;
      const perUnit = (tgt === 'RLUSD') ? 'RLUSD/IOU' : 'XRP/IOU';
      const base = `✅ ${r.disp}: est ${r.px.toFixed(6)} ${perUnit} × ${r.balance.toFixed(6)} = ${r.est.toFixed(6)} ${r.unit}`;
      return r.low ? base + '  ⚠ low liquidity — will skip' : base;
    });
    $panicPlanOut.textContent = lines.join('\n');
  });

  // ===== Panic sell
  $btnPanicSell?.addEventListener('click', async ()=>{
    if (!state.account || !state.adapter) return ($panicStatus.textContent='Connect wallet first.');
    const slip = Number($panicSlip.value||ST_DEFAULT_SLIPPAGE_PCT);
    const tgt  = $panicTarget.value;

    if ($panicCancelFirst?.checked) {
      try { await cancelAll(); } catch {}
    }

    const toks = await listUserTokens(state.account);
    if (!toks.length){ $panicStatus.textContent='No positive IOU balances.'; return; }

    const scored = [];
    for (const t of toks){
      const px = (tgt === 'RLUSD') ? await refPriceIOUtoRLUSD(t.code, t.issuer)
                                   : await refPriceIOUtoXRP(t.code, t.issuer);
      if (px) scored.push({ ...t, est: px * t.balance });
    }
    scored.sort((a,b)=>b.est-a.est);

    const filtered = scored.filter(s => !belowMin(s.est, tgt));

    let ok=0, fail=0;
    for (const t of filtered){
      try{
        const tx = (tgt === 'RLUSD')
          ? await pathfindSellIOUtoRLUSD({ acct: state.account, currencyCode: t.code, issuer: t.issuer, amountIOU: t.balance, slippagePct: slip })
          : await pathfindSellIOUtoXRP  ({ acct: state.account, currencyCode: t.code, issuer: t.issuer, amountIOU: t.balance, slippagePct: slip });
        await state.adapter.signAndSubmit(tx);
        ok++;
      }catch(e){ fail++; }
    }
    const skipped = (toks.length - scored.length) + (scored.length - filtered.length);
    $panicStatus.textContent = `Submitted ${ok} swap(s). Failed ${fail}. Skipped ${skipped} (no route/low liquidity).`;
  });

  // ===== XRBC TRUST + BUY
  const XRBC_HEX=(XRBC.currencyHex||'').toUpperCase();
  function hexToAsciiLoose(hex){ try{ let out=''; for(let i=0;i<hex.length;i+=2){ const b=parseInt(hex.slice(i,i+2),16); if(!b) break; out+=String.fromCharCode(b);} return out||'XRBC'; }catch{ return 'XRBC'; } }
  const XRBC_CODE=hexToAsciiLoose(XRBC_HEX);

  async function hasXRBCTrustLine(acct){
    const r=await call('account_lines',{account:acct,peer:XRBC.issuer,limit:400});
    const lines=r?.lines||[]; return lines.some(l=>((l.currency||'').toUpperCase()===XRBC_CODE.toUpperCase())||((l.currency||'').toUpperCase()===XRBC_HEX));
  }
  async function addXRBCTrustLine(){
    if(!state.account || !state.adapter){ setStatus($buyStatus,'Connect wallet first.','err'); return; }
    setStatus($buyStatus,'Checking trust line…');
    try{
      const exists=await hasXRBCTrustLine(state.account);
      if(exists){ setStatus($buyStatus,'XRBC trust line already exists.','ok'); return; }
      const tx={ TransactionType:'TrustSet', Account:state.account, LimitAmount:{ currency:XRBC_HEX, issuer:XRBC.issuer, value:"1000000000" } };
      await state.adapter.signAndSubmit(tx);
      setStatus($buyStatus,'TrustSet submitted. Wait for validation then retry buy.','ok');
    }catch(e){ setStatus($buyStatus,'TrustSet error: '+(e.message||e),'err'); }
  }
  async function pathFindBuy(acct,valueStr){
    const AMOUNT={currency:XRBC_HEX,issuer:XRBC.issuer,value:valueStr};
    const pfWrap=await xrplRequest({ method:'ripple_path_find', params:[{ source_account:acct, destination_account:acct, destination_amount:AMOUNT, source_currencies:[{currency:"XRP"}] }] }, {timeoutMs:15000});
    const pf=pfWrap?.result||{}; const alts=pf?.alternatives||[]; if(!alts.length) throw new Error('No path found for requested amount');
    let best=null;
    for(const a of alts){
      const sa=a.source_amount;
      const drops=typeof sa==='string'?N(sa):(sa && sa.currency==='XRP' ? Math.round(N(sa.value)*XRP_TO_DROPS) : Infinity);
      if(!isFinite(drops)) continue;
      if(!best || drops<best.drops) best={alt:a,drops};
    }
    if(!best) throw new Error('No XRP route available');

    const headroom = Math.ceil(best.drops * (1 + QUICK_BUY_SLIPPAGE_PCT / 100));

    return { TransactionType:'Payment', Account:acct, Destination:acct, Amount:AMOUNT, SendMax:String(headroom), Paths:best.alt.paths_computed||[] };
  }
  async function buyXRBC(units){
    if(!state.account || !state.adapter){ setStatus($buyStatus,'Connect wallet first.','err'); return; }
    try{
      setStatus($buyStatus,`Preparing to buy ${units} ${XRBC_CODE}…`);
      const exists=await hasXRBCTrustLine(state.account);
      if(!exists){ setStatus($buyStatus,'No XRBC trust line. Use “Add XRBC Trust Line” first.','err'); return; }
      const tx=await pathFindBuy(state.account,String(units));
      const res=await state.adapter.signAndSubmit(tx);
      setStatus($buyStatus,`Buy submitted. Hash: ${(res && res.hash)?res.hash:'(pending)'}`,'ok');
    }catch(e){ setStatus($buyStatus,(e && e.message) || 'Buy failed','err'); }
  }

  // ===== Wire base UI
  document.getElementById('btnTrustXRBC')?.addEventListener('click',()=>addXRBCTrustLine());
  document.getElementById('buy1')?.addEventListener('click',()=>buyXRBC(1));
  document.getElementById('buy25')?.addEventListener('click',()=>buyXRBC(25));
  document.getElementById('buy50')?.addEventListener('click',()=>buyXRBC(50));
  document.getElementById('buy100')?.addEventListener('click',()=>buyXRBC(100));

  document.getElementById('btnXumm')?.addEventListener('click',()=>connectWith(XummAdapter));
  document.getElementById('btnDisconnect')?.addEventListener('click',()=>disconnect());
  document.getElementById('btnRefresh')?.addEventListener('click',()=> state.account ? refreshAll() : setStatus($walletStatus,'Connect first.','err'));
  document.getElementById('btnCancelAll')?.addEventListener('click',()=>cancelAll());
  document.getElementById('network')?.addEventListener('change',()=>{
    state.network = document.getElementById('network').value==='testnet' ? 'testnet' : 'mainnet';
    updateNetUI();
    if(state.account) { refreshAll(); }
  });

  // Boot
  updateNetUI();
  if (BOOT.autoResume !== false) { tryResumeWallet(); }
  if (BOOT.autoLoadData !== false) {
    setTimeout(()=>{ if(state.account){ refreshAll(); } }, 400);
  }
  if (BOOT.refreshOnFocus) {
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && state.account) refreshAll();
    });
    window.addEventListener('focus', () => { if (state.account) refreshAll(); });
  }

  (function setCopyrightYear(){
    const y0 = FIRST_COMMIT_YEAR, y1 = new Date().getFullYear();
    const el = document.getElementById('copyrightYear');
    if (el) el.textContent = (y1 > y0) ? (y0 + '–' + y1) : String(y0);
  })();

})();
</script>
</body>
</html>
