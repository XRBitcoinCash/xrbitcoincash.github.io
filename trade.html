<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Open Graph (Facebook, LinkedIn, Twitter will use if no twitter: tags) -->
<meta property="og:title" content="XRBitcoinCash · XRBC on XRPL">
<meta property="og:description" content="Trade XRBC on the XRP Ledger. Connect your wallet and explore the XRBC/XRP decentralized exchange.">
<meta property="og:image" content="https://xrbitcoincash.com/xrbc-nft.png">
<meta property="og:url" content="https://xrbitcoincash.com/trade.html">
<meta property="og:type" content="website">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="XRBitcoinCash · XRBC on XRPL">
<meta name="twitter:description" content="Decentralized XRBC/XRP trading on the XRP Ledger.">
<meta name="twitter:image" content="https://xrbitcoincash.com/xrbc-nft.png">

  <meta charset="utf-8" />
  <title>XRBitcoinCash · Proxy Wallet Test</title>
 <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Favicon for browsers -->
<link rel="icon" href="/xrbc-nft.png" type="image/png">

<!-- Fallback for older browsers -->
<link rel="shortcut icon" href="/xrbc-nft.png" type="image/png">



  <!-- Favicon for browsers -->
<link rel="icon" href="/xrbc-nft.png" type="image/png">

<!-- Fallback for older browsers -->
<link rel="shortcut icon" href="/xrbc-nft.png" type="image/png">

<!-- Apple/Android homescreen icons -->
<link rel="apple-touch-icon" href="/xrbc-nft.png">
<meta name="msapplication-TileImage" content="/xrbc-nft.png">


  <!-- Open Graph (Facebook, LinkedIn, etc.) -->
<meta property="og:title" content="XRBitcoinCash · XRBC on XRPL">
<meta property="og:description" content="Trade XRBC on the XRP Ledger. Connect your wallet and explore the XRBC/XRP decentralized exchange.">
<meta property="og:image" content="/xrbc-nft.png">
<meta property="og:type" content="website">
<meta property="og:url" content="https://xrbitcoincash.com/">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="XRBitcoinCash · XRBC on XRPL">
<meta name="twitter:description" content="Decentralized XRBC/XRP trading on the XRP Ledger.">
<meta name="twitter:image" content="/xrbc-nft.png">

  
  <style>
   /* === XRBitcoinCash Wallet Connect · Enhanced Dark UI === */
:root {
  --bg: #0b0f14;
  --panel: #121821;
  --panel-2: #141b25;
  --text: #e7edf5;
  --muted: #9fb0c5;
  --accent: #60a5fa;
  --accent-2: #22d3ee;
  --warn: #f59e0b;
  --err: #ef4444;
  --ok: #22c55e;
  --border: #1f2937;
  --ring: #1d4ed8;
  --shadow: 0 10px 30px rgba(0,0,0,.35);
}
* { box-sizing: border-box; margin:0; padding:0; }

html, body {
  height: 100%;
  background: var(--bg);
  color: var(--text);
  font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  overflow-x: hidden;
}



/* Layout */
.container {
  max-width: 900px;
  margin: 0 auto;
  padding: 20px 16px;
  position: relative;
  z-index: 5;
}
.row-flex {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  align-items: flex-start;
}

/* Card */
.card {
  background: linear-gradient(180deg, var(--panel), var(--panel-2));
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 16px;
  box-shadow: var(--shadow);
  flex: 1;
  min-width: 260px;
}
.card.glow {
  border-color: var(--accent-2);
  box-shadow: 0 0 20px rgba(34,211,238,.3);
}

/* Buttons */
.btn {
  appearance: none;
  border: 1px solid var(--border);
  background: linear-gradient(180deg, #0e1520, #0c131c);
  color: var(--text);
  padding: 10px 14px;
  border-radius: 12px;
  font-weight: 600;
  cursor: pointer;
  box-shadow: var(--shadow);
  transition: transform .06s ease, border-color .2s ease, box-shadow .2s ease;
  min-width: 120px;
  text-align: center;
}
.btn:hover { transform: translateY(-1px); border-color: #2a3a51; }
.btn:active { transform: translateY(0); }
.btn[disabled] { opacity: .6; cursor: not-allowed; }
.btn-primary {
  background: linear-gradient(180deg, rgba(37,99,235,.25), rgba(37,99,235,.15));
  border-color: rgba(37,99,235,.45);
}
.btn-secondary {
  background: linear-gradient(180deg, rgba(34,211,238,.22), rgba(34,211,238,.12));
  border-color: rgba(34,211,238,.45);
}

/* Status */
.status-text {
  font-size: 13px;
  color: var(--muted);
  margin-left: 12px;
}
.status-text.ok { color: var(--ok); }
.status-text.err { color: var(--err); }

/* Ledger info shrink */
pre {
  background: #0c131c;
  border: 1px solid #1c2736;
  border-radius: 10px;
  padding: 8px;
  max-height: 200px;
  overflow: auto;
  font-size: 12px;
  color: #a3e4ff;
}

/* Tables */
.table { width:100%; border-collapse:collapse; font-size:14px; }
.table th, .table td { padding: 8px 10px; border-bottom: 1px solid #1a2433; }
.table thead th { background:#0f1722; color:#cfe2ff; }

/* Responsive */
@media (max-width: 600px) {
  .row-flex { flex-direction: column; }
  .btn { width: 100%; }
}

  .brand {
  display: flex;
  align-items: center;
  justify-content: center; /* center horizontally */
  gap: 12px;
  text-align: center;
  width: 100%; /* ensures centering spans full width */
}


.brand img {
  max-height: 40px; /* keeps logo from being oversized */
}
  

/* --- Trade UI polish (does not affect logic) --- */
.trade-card { display: grid; gap: 12px; text-align: left; }

.tabset { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
.tab {
  padding: 10px 12px;
  border: 1px solid var(--border);
  background: linear-gradient(180deg, #0e1520, #0c131c);
  border-radius: 10px;
  font-weight: 700;
  cursor: pointer;
  text-align: center;
}

/* Force text color */
.tab.buy  { color: #22c55e; }   /* green text */
.tab.sell { color: #ef4444; }   /* red text */

.tab.buy.active {
  border-color: rgba(34,197,94,.5);
  box-shadow: 0 0 0 2px rgba(34,197,94,.15) inset;
}

.tab.sell.active {
  border-color: rgba(239,68,68,.5);
  box-shadow: 0 0 0 2px rgba(239,68,68,.15) inset;
}


.field { display: grid; gap: 6px; }
.field label { font-size: 13px; color: var(--muted); }
.field input {
  width: 100%;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid var(--border);
  background: #0c131c;
  color: var(--text);
}
.field .row { display: grid; grid-template-columns: 1fr auto; gap: 8px; }

.inline-hint { font-size: 12px; color: var(--muted); }

.total-line {
  display: flex; align-items: center; justify-content: space-between;
  padding: 10px 12px;
  border: 1px dashed var(--border);
  border-radius: 10px;
  background: linear-gradient(180deg, #0b1119, #0a0f15);
}
.amount-row {
  display: flex;
  align-items: center;
  gap: 6px;
}

.amount-row img {
  max-height: 22px;
}

.button-row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
@media (max-width: 600px) { .button-row { grid-template-columns: 1fr; } }

    
  </style>
</head>

<header class="site-header">
  <div class="brand" style="flex-direction: column; justify-content: center; text-align: center;">
    <img src="/xrbc-nft.png" alt="XRBC logo" />
    <h1>XRBitcoinCash</h1>
    <a href="https://xrbitcoincash.com/" class="btn btn-secondary" style="margin-top: 12px;">Home</a>
  </div>
</header>




  <div class="container" style="max-width:800px;margin:0 auto;padding:20px;text-align:center;">

    <!-- Header -->
    <h1 style="margin-bottom:24px;">XRBitcoinCash · XRBC/XRP Trading & Ledger Portal</h1>

    <!-- Wallet Section -->
    <div class="card glow" style="margin-bottom:24px;">
      <h2 style="margin-top:0;">Wallet</h2>
      <div style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin:16px 0;">
        <button id="connectWalletBtn" class="btn btn-primary glow-btn">Connect Wallet</button>
        <button id="disconnectWalletBtn" class="btn btn-secondary glow-btn" disabled>Disconnect</button>
      </div>
      <p id="walletStatus" class="status-text">Status: Not connected</p>
    </div>


<button id="setTrustlineBtn" class="btn btn-primary">Set XRBC Trustline</button>

    
    <div id="trustlineMsg" class="status-text" style="margin-bottom:20px;">—</div>

    
    <!-- Ledger Info -->
    <div class="card" style="margin-bottom:24px;">
      <h2 style="margin-top:0;">Ledger Info</h2>
      <button id="fetchLedgerBtn" class="btn glow-btn" style="margin-bottom:12px;">Fetch Ledger Info</button>
      <pre id="ledgerOutput" style="text-align:left;">—</pre>
    </div>

  <div class="card" style="margin-bottom:24px;">
  <h2 style="margin-top:0;">Trade XRBC ↔ XRP</h2>

  <div class="trade-card" id="tradeCard">
    <!-- Tabs -->
    <div class="tabset">
      <button id="buyTab" class="tab buy active" type="button">Buy XRBC</button>
      <button id="sellTab" class="tab sell" type="button">Sell XRBC</button>
    </div>

<!-- Amount -->
<div class="field">
  <label for="amount">Amount (XRBC)</label>
  <div class="amount-row">
    <img src="/xrbc-nft.png" alt="XRBC logo">
    <input id="amount" type="number" step="0.000001" inputmode="decimal" placeholder="0.000000">
  </div>
  <div class="inline-hint">How many XRBC you want to <span id="actionWord">collect</span>.</div>
</div>



    <!-- Price -->
    <div class="field" id="priceField">
      <label for="price">Price (XRP per XRBC)</label>
      <div class="row">
        <input id="price" type="number" step="0.000001" inputmode="decimal" placeholder="e.g., 0.500000">
        <button class="btn btn-secondary" id="suggestPriceBtn" type="button">Best Price</button>
      </div>
      <div class="inline-hint">Limit price. Use <em>Market Order</em> to execute at best available price.</div>
    </div>

    <!-- Total -->
    <div class="total-line">
      <span>Total</span>
      <strong id="totalXrp">0.000000 XRP</strong>
    </div>

    <!-- Actions -->
    <div class="button-row">
      <button id="placeOfferBtn" class="btn btn-primary" type="button">Place Limit Order</button>
     
    </div>

    <p id="tradeMsg" class="status-text">—</p>

    <!-- Keep 'side' for existing JS logic (hidden) -->
    <select id="side" style="display:none">
      <option value="buy" selected>Buy</option>
      <option value="sell">Sell</option>
    </select>
  </div>
</div>


    <!-- Order Book -->
    <div class="card" style="margin-bottom:24px;">
      <h2 style="margin-top:0;">XRBC/XRP Order Book</h2>
      <button id="fetchPriceBtn" class="btn glow-btn" style="margin-bottom:12px;">Get Order Book</button>
      <p id="priceOutput">—</p>
    </div>

  </div>
<!-- AMM Pool Info -->
<div class="card" style="margin-bottom:24px;">
  <h2 style="margin-top:0;">XRBC/XRP AMM Pool</h2>
  <div id="ammPoolOutput">—</div>
</div>

<!-- Config -->
<script type="application/json" id="app-config">
{
  "xummApiKey": "2abde023-0df1-49a2-a4dc-86d776f6318d",
  "proxyUrl": "https://xrbitcoincash-github-io.onrender.com"
}
</script>

<!-- Libraries -->
<script src="https://xaman.app/assets/cdn/xumm.min.js"></script>
<script>
  // === Config ===
  const cfg = JSON.parse(document.getElementById("app-config").textContent);
  const PROXY_URL = cfg.proxyUrl;

  // === XRBC constants ===
  const XRBC = {
    currency: "5852626974636F696E6361736800000000000000",
    issuer: "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw"
  };
  const XRP_TO_DROPS = 1_000_000;

  // === Proxy bridge ===
  async function xrplRequest(payload) {
    const res = await fetch(PROXY_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    if (!res.ok) throw new Error("Proxy error: " + res.status);
    const data = await res.json();
    if (data.error) throw new Error("XRPL error: " + JSON.stringify(data.error));
    return data;
  }


// Drops utils

const toDrops = (xrp) => Math.round(Number(xrp) * XRP_TO_DROPS).toString();

// Guard: ensure wallet is connected
function requireWallet() {
  if (!window.__xrbcWallet) throw new Error("Connect your wallet first.");
  return window.__xrbcWallet;
}

    
  // === Helpers ===
  async function getLedgerInfo() {
    return await xrplRequest({ method: "ledger", params: [{ ledger_index: "validated" }] });
  }

  // === Order Book (dual-sided) ===
  async function getXrbcOrderBook() {
    async function fetchSide(taker_gets, taker_pays, sideName) {
      const rows = [];
      try {
        const data = await xrplRequest({
          method: "book_offers",
          params: [{ taker_gets, taker_pays, limit: 5 }]
        });
        if (data.result?.offers?.length) {
          for (const offer of data.result.offers) {
            const gets = offer.TakerGets.value
              ? parseFloat(offer.TakerGets.value)
              : parseFloat(offer.TakerGets) / XRP_TO_DROPS;
            const pays = offer.TakerPays.value
              ? parseFloat(offer.TakerPays.value)
              : parseFloat(offer.TakerPays) / XRP_TO_DROPS;
            const price = pays / gets;
            rows.push(`<tr><td>${sideName}</td><td>${price.toFixed(6)}</td><td>${gets.toFixed(2)}</td></tr>`);
          }
        } else {
          rows.push(`<tr><td>${sideName}</td><td>No offers</td><td>-</td></tr>`);
        }
      } catch (err) {
        rows.push(`<tr><td>${sideName}</td><td>Error</td><td>${err.message}</td></tr>`);
      }
      return rows;
    }
    const asks = await fetchSide(XRBC, { currency: "XRP" }, "Ask");
    const bids = await fetchSide({ currency: "XRP" }, XRBC, "Bid");
    return `
      <table class="table">
        <thead><tr><th>Side</th><th>Price (XRP/XRBC)</th><th>Amount</th></tr></thead>
        <tbody>${asks.join("")}${bids.join("")}</tbody>
      </table>
    `;
  }

  // === Main logic ===
  (async function(){
    // Wallet connect
    const xumm = new Xumm(cfg.xummApiKey);
    const btn = document.getElementById("connectWalletBtn");
    const statusEl = document.getElementById("walletStatus");
   
    
    const disconnectBtn = document.getElementById("disconnectWalletBtn");

let hasSavedAcct = false;  // tracks if we restored a prior session

    // Restore persisted connection on refresh (if present)
const savedAcct = localStorage.getItem("xrbcWallet");
if (savedAcct) {
  hasSavedAcct = true;
  window.__xrbcWallet = savedAcct;
  statusEl.textContent = "Connected: " + savedAcct;
  disconnectBtn.disabled = false;
  btn.disabled = true; // keep "Connect" disabled while connected
}


    
   xumm.on("ready", () => { if (!hasSavedAcct) btn.disabled = false; });


    
    btn.addEventListener("click", async () => {
      try {
      await xumm.authorize();

        
        
        const acct = await xumm.user.account;
   
        
    statusEl.textContent = "Connected: " + acct;
window.__xrbcWallet = acct;
localStorage.setItem("xrbcWallet", acct);  // <-- persist to browser

// update buttons
disconnectBtn.disabled = false;
btn.disabled = true;

      
      } catch (err) {
        statusEl.textContent = "Failed to connect wallet";
      }
    });
// Disconnect wallet
disconnectBtn.addEventListener("click", () => {

  // Clear local + persistent account
window.__xrbcWallet = null;
localStorage.removeItem("xrbcWallet");

  // Kill Xumm session so it doesn’t auto-connect
  xumm.logout();

  // Reset UI
  statusEl.textContent = "Status: Disconnected";
  disconnectBtn.disabled = true;
  btn.disabled = false;
});

 // Ledger fetch
document.getElementById("fetchLedgerBtn").addEventListener("click", async () => {
  const ledgerOut = document.getElementById("ledgerOutput");
  let seconds = 0;
  const maxSeconds = 30;

  const messages = [
    "Initializing secure connection…",
    "Establishing proxy communication…",
    "Synchronizing with XRPL Ledger…",
    "Validating ledger data integrity…",
    "Establishing secure connection to digital environment…",
    "Finalizing ledger response…"
  ];

  // Initial message
  ledgerOut.textContent = messages[0];
  ledgerOut.style.color = "#9fb0c5";

  // Cycle through messages
  const interval = setInterval(() => {
    seconds++;
    const msgIndex = Math.floor((seconds / 2) % messages.length); 
    ledgerOut.textContent = messages[msgIndex] + ` (${seconds}s)`;
  }, 2000);

  try {
    const info = await getLedgerInfo();
    clearInterval(interval);
    ledgerOut.style.color = "#a3e4ff";
    ledgerOut.textContent = JSON.stringify(info, null, 2);
  } catch (err) {
    clearInterval(interval);
    ledgerOut.style.color = "#ef4444";
    ledgerOut.textContent = "Error: " + err.message;
  }
});


    // Order book
    document.getElementById("fetchPriceBtn").addEventListener("click", async () => {
      const priceOut = document.getElementById("priceOutput");
      priceOut.textContent = "Loading XRBC/XRP order book…";
      try {
        const html = await getXrbcOrderBook();
        priceOut.innerHTML = html;
      } catch (err) {
        priceOut.textContent = "Error: " + err.message;
      }
    });
 
// === Trading UI ===
const placeOfferBtn = document.getElementById("placeOfferBtn");
const sideEl   = document.getElementById("side");
const amountEl = document.getElementById("amount");
const priceEl  = document.getElementById("price");
const tradeMsg = document.getElementById("tradeMsg");

// --- UX helpers (do not change your order logic) ---
const tradeCard   = document.getElementById("tradeCard");
const buyTab      = document.getElementById("buyTab");
const sellTab     = document.getElementById("sellTab");
const totalXrpEl  = document.getElementById("totalXrp");
const suggestBtn  = document.getElementById("suggestPriceBtn");
const actionWordEl= document.getElementById("actionWord");

// Color/labels + side switcher
function setSide(side) {
  sideEl.value = side;
  buyTab.classList.toggle("active", side === "buy");
  sellTab.classList.toggle("active", side === "sell");
  if (actionWordEl) actionWordEl.textContent = side;
  recalcTotals();
}

// Live total calculator
function recalcTotals() {
  const amt = Number(amountEl.value) || 0;
  const px  = Number(priceEl.value)  || 0;
  const total = amt * px;
  totalXrpEl.textContent = (isFinite(total) ? total : 0).toFixed(6) + " XRP";
}
[amountEl, priceEl].forEach(el => el.addEventListener("input", recalcTotals));

// === Best Price from AMM pool ===
async function fillBestPrice() {
  try {
    const side   = sideEl.value; // "buy" or "sell"
    const amount = Number(amountEl.value);
    if (!amount || amount <= 0) throw new Error("Enter a valid XRBC amount");

    // Query AMM pool info
    const data = await xrplRequest({
      method: "amm_info",
      params: [
        {
          asset: { currency: "XRP" },
          asset2: { currency: XRBC.currency, issuer: XRBC.issuer }
        }
      ]
    });

    const amm = data.result?.amm;
    if (!amm) throw new Error("No AMM found for XRBC/XRP");

    // ✅ FIXED: convert drops → XRP
    const reserveXrp  = parseFloat(amm.amount) / XRP_TO_DROPS;
    const reserveXrbc = parseFloat(amm.amount2.value);
    const feeRate     = amm.trading_fee / 1_000_000;

    const k = reserveXrp * reserveXrbc;
    let effectivePrice;

    if (side === "buy") {
      const newReserveY = reserveXrbc - amount;
      if (newReserveY <= 0) throw new Error("Not enough XRBC liquidity");
      const newReserveX = k / newReserveY;
      let xrpIn = newReserveX - reserveXrp;
      const fee = xrpIn * feeRate;
      xrpIn += fee;
      effectivePrice = xrpIn / amount;
    } else {
      const newReserveY = reserveXrbc + amount;
      const newReserveX = k / newReserveY;
      let xrpOut = reserveXrp - newReserveX;
      const fee = xrpOut * feeRate;
      xrpOut -= fee;
      if (xrpOut <= 0) throw new Error("Not enough XRP liquidity");
      effectivePrice = xrpOut / amount;
    }

    priceEl.value = Number(effectivePrice).toFixed(6);
    recalcTotals();

    tradeMsg.textContent = `Best price calculated from AMM pool (${side}).`;
    tradeMsg.classList.remove("err");
    tradeMsg.classList.add("ok");

    updateAmmPool(amm);

  } catch (e) {
    tradeMsg.textContent = "Could not fetch AMM price: " + e.message;
    tradeMsg.classList.remove("ok");
    tradeMsg.classList.add("err");
  }
}




  
// Wire up tabs + default state
buyTab.addEventListener("click", () => setSide("buy"));
sellTab.addEventListener("click", () => setSide("sell"));
if (suggestBtn) suggestBtn.addEventListener("click", fillBestPrice);
setSide(sideEl.value || "buy"); // initialize
recalcTotals();

// === Auto-refresh Best Price every 10s ===
setInterval(() => {
  // only refresh if user entered a valid amount
  const amt = Number(amountEl.value);
  if (amt > 0) {
    fillBestPrice().catch(err => console.error("Auto-refresh error:", err));
  }
}, 10000);


    
    
placeOfferBtn.addEventListener("click", async () => {
  try {
    const account = requireWallet();
    const side   = sideEl.value;
    const amt    = Number(amountEl.value);
    const price  = Number(priceEl.value);

    if (!amt || !price || amt <= 0 || price <= 0) {
      throw new Error("Enter valid Amount & Price.");
    }

    let txjson;
    if (side === "sell") {
      const xrpTotal = price * amt;
      txjson = {
        TransactionType: "OfferCreate",
        Account: account,
        TakerGets: { currency: XRBC.currency, issuer: XRBC.issuer, value: String(amt) },
        TakerPays: toDrops(xrpTotal),
        Flags: 0x00080000 // tfSell
      };
    } else {
      const xrpTotal = price * amt;
      txjson = {
        TransactionType: "OfferCreate",
        Account: account,
        TakerGets: toDrops(xrpTotal),
        TakerPays: { currency: XRBC.currency, issuer: XRBC.issuer, value: String(amt) }
      };
    }

    tradeMsg.textContent = "Open Xaman to review & sign…";

    const { resolved } = await xumm.payload.createAndSubscribe({ txjson }, (ev) => {
      if (ev?.opened) tradeMsg.textContent = "Payload opened in Xaman…";
      if (ev?.signed === false) tradeMsg.textContent = "Offer rejected.";
    });

    const result = await resolved;
    if (!result.signed) {
      tradeMsg.textContent = "Offer not signed.";
      return;
    }

    tradeMsg.textContent = "Offer submitted. Refreshing order book…";
    const html = await getXrbcOrderBook();
    document.getElementById("priceOutput").innerHTML = html;

  } catch (err) {
    tradeMsg.textContent = "Error: " + err.message;
  }
});

// === Market Order ===
const marketOrderBtn = document.getElementById("marketOrderBtn");
marketOrderBtn.addEventListener("click", async () => {
  try {
    const account = requireWallet();
    const side   = sideEl.value; // "buy" or "sell"
    const amt    = Number(amountEl.value);

    if (!amt || amt <= 0) throw new Error("Enter valid Amount.");

    let txjson;
    if (side === "sell") {
      // Sell XRBC at market
      txjson = {
        TransactionType: "OfferCreate",
        Account: account,
        TakerGets: { currency: XRBC.currency, issuer: XRBC.issuer, value: String(amt) },
        TakerPays: "100000000000000000", // huge XRP max
        Flags: 0x00020000 | 0x00080000 // tfImmediateOrCancel + tfSell
      };
    } else {
      // Buy XRBC at market
      txjson = {
        TransactionType: "OfferCreate",
        Account: account,
        TakerGets: "100000000000000000", // huge XRP max
        TakerPays: { currency: XRBC.currency, issuer: XRBC.issuer, value: String(amt) },
        Flags: 0x00020000 // tfImmediateOrCancel
      };
    }

    tradeMsg.textContent = "Open Xaman to review & sign (Market Order)…";

    const { resolved } = await xumm.payload.createAndSubscribe({ txjson }, (ev) => {
      if (ev?.opened) tradeMsg.textContent = "Payload opened in Xaman…";
      if (ev?.signed === false) tradeMsg.textContent = "Order rejected.";
    });

    const result = await resolved;
    if (!result.signed) {
      tradeMsg.textContent = "Market order not signed.";
      return;
    }

    tradeMsg.textContent = "Market order executed. Refreshing order book…";
    const html = await getXrbcOrderBook();
    document.getElementById("priceOutput").innerHTML = html;

  } catch (err) {
    tradeMsg.textContent = "Error: " + err.message;
  }
});

// === Trustline Setup (Local) ===
const setTrustlineBtn = document.getElementById("setTrustlineBtn");
const trustlineMsg = document.getElementById("trustlineMsg");

setTrustlineBtn.addEventListener("click", async () => {
  trustlineMsg.textContent = "Preparing trustline request…";

  try {
    const account = requireWallet(); // ensure wallet is connected

    const txjson = {
      TransactionType: "TrustSet",
      Account: account,
      LimitAmount: {
        currency: XRBC.currency,   // ✅ use your hex code
        issuer: XRBC.issuer,       // ✅ use your issuer
        value: "1000000"           // trustline limit (adjust if needed)
      }
    };

    trustlineMsg.textContent = "Open Xaman to review & sign…";

    const payload = await xumm.payload.createAndSubscribe({ txjson }, (ev) => {
      if (ev?.opened) trustlineMsg.textContent = "Payload opened in Xaman…";
      if (ev?.signed === false) trustlineMsg.textContent = "Trustline rejected.";
    });

// === QR code (desktop) OR Link (mobile) ===
if (payload?.created?.refs?.qr_png) {
  const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

  if (isMobile) {
    // 📱 Mobile → link to external trustline page
    const link = document.createElement("a");
    link.href = "https://xrpl.services/?issuer=rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw&currency=5852626974636F696E6361736800000000000000&limit=20999999.999999996";
    link.textContent = "👉 Tap here to set XRBC Trustline";
    link.target = "_blank";
    link.rel = "noopener noreferrer";
    link.style.display = "inline-block";
    link.style.marginTop = "12px";
    link.style.color = "#60a5fa";
    link.style.fontWeight = "600";

    trustlineMsg.innerHTML = "Open the link below to set XRBC trustline:<br/>";
    trustlineMsg.appendChild(link);
  } else {
    // 🖥️ Desktop → show QR code
    const qr = document.createElement("img");
    qr.src = payload.created.refs.qr_png;
    qr.alt = "Scan with Xaman to set XRBC trustline";
    qr.style.maxWidth = "240px";
    qr.style.marginTop = "12px";

    trustlineMsg.innerHTML = "Scan to sign trustline:<br/>";
    trustlineMsg.appendChild(qr);
  }
}

// === Wait for user resolution ===
const result = await payload.resolved;
if (!result.signed) {
  trustlineMsg.textContent = "Trustline not signed.";
  return;
}

trustlineMsg.textContent = "✅ Trustline set successfully!";

    
})();   // closes the main async IIFE
</script>
</body>
</html>
