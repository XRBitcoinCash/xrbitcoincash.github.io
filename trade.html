<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Open Graph (Facebook, LinkedIn, Twitter will use if no twitter: tags) -->
<meta property="og:title" content="XRBitcoinCash Â· XRBC on XRPL">
<meta property="og:description" content="Trade XRBC on the XRP Ledger. Connect your wallet and explore the XRBC/XRP decentralized exchange.">
<meta property="og:image" content="https://xrbitcoincash.com/xrbc-nft.png">
<meta property="og:url" content="https://xrbitcoincash.com/trade.html">
<meta property="og:type" content="website">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="XRBitcoinCash Â· XRBC on XRPL">
<meta name="twitter:description" content="Decentralized XRBC/XRP trading on the XRP Ledger.">
<meta name="twitter:image" content="https://xrbitcoincash.com/xrbc-nft.png">

  <meta charset="utf-8" />
  <title>XRBitcoinCash Â· Proxy Wallet Test</title>
 <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Favicon for browsers -->
<link rel="icon" href="/xrbc-nft.png" type="image/png">

<!-- Fallback for older browsers -->
<link rel="shortcut icon" href="/xrbc-nft.png" type="image/png">



  <!-- Favicon for browsers -->
<link rel="icon" href="/xrbc-nft.png" type="image/png">

<!-- Fallback for older browsers -->
<link rel="shortcut icon" href="/xrbc-nft.png" type="image/png">

<!-- Apple/Android homescreen icons -->
<link rel="apple-touch-icon" href="/xrbc-nft.png">
<meta name="msapplication-TileImage" content="/xrbc-nft.png">


  <!-- Open Graph (Facebook, LinkedIn, etc.) -->
<meta property="og:title" content="XRBitcoinCash Â· XRBC on XRPL">
<meta property="og:description" content="Trade XRBC on the XRP Ledger. Connect your wallet and explore the XRBC/XRP decentralized exchange.">
<meta property="og:image" content="/xrbc-nft.png">
<meta property="og:type" content="website">
<meta property="og:url" content="https://xrbitcoincash.com/">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="XRBitcoinCash Â· XRBC on XRPL">
<meta name="twitter:description" content="Decentralized XRBC/XRP trading on the XRP Ledger.">
<meta name="twitter:image" content="/xrbc-nft.png">

  <link rel="stylesheet" href="/css/xrbc-trade.css?v=1">


</head>

<header class="site-header">
  <div class="brand" style="flex-direction: column; justify-content: center; text-align: center;">
    <img src="/xrbc-nft.png" alt="XRBC logo" />
    <h1>XRBitcoinCash</h1>
    <a href="https://xrbitcoincash.com/" class="btn btn-secondary" style="margin-top: 12px;">Home</a>
  </div>
</header>





  <div class="container" style="max-width:800px;margin:0 auto;padding:20px;text-align:center;">

    <!-- Header -->
    <h1 style="margin-bottom:24px;">XRBitcoinCash Â· XRBC/XRP Trading & Ledger Portal</h1>

    <!-- Wallet Section -->
    <div class="card glow" style="margin-bottom:24px;">
      <h2 style="margin-top:0;">Wallet</h2>
      <div style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin:16px 0;">
        <button id="connectWalletBtn" class="btn btn-primary glow-btn">Connect Wallet</button>
        <button id="disconnectWalletBtn" class="btn btn-secondary glow-btn" disabled>Disconnect</button>
      </div>
      <p id="walletStatus" class="status-text">Status: Not connected</p>
    </div>


<button id="setTrustlineBtn" class="btn btn-primary">Set XRBC Trustline</button>

    
    <div id="trustlineMsg" class="status-text" style="margin-bottom:20px;">â€”</div>

    
    <!-- Ledger Info -->
    <div class="card" style="margin-bottom:24px;">
      <h2 style="margin-top:0;">Ledger Info</h2>
      <button id="fetchLedgerBtn" class="btn glow-btn" style="margin-bottom:12px;">Fetch Ledger Info</button>
      <pre id="ledgerOutput" style="text-align:left;">â€”</pre>
    </div>

  <div class="card" style="margin-bottom:24px;">
  <h2 style="margin-top:0;">Trade XRBC â†” XRP</h2>

  <div class="trade-card" id="tradeCard">
    <!-- Tabs -->
    <div class="tabset">
      <button id="buyTab" class="tab buy active" type="button">Buy XRBC</button>
      <button id="sellTab" class="tab sell" type="button">Sell XRBC</button>
    </div>

<!-- Amount -->
<div class="field">
  <label for="amount">Amount (XRBC)</label>
  <div class="amount-row">
    <img src="/xrbc-nft.png" alt="XRBC logo">
    <input id="amount" type="number" step="0.000001" inputmode="decimal" placeholder="0.000000">
  </div>
  <div class="inline-hint">How many XRBC you want to <span id="actionWord">collect</span>.</div>
</div>



    <!-- Price -->
    <div class="field" id="priceField">
      <label for="price">Price (XRP per XRBC)</label>
      <div class="row">
        <input id="price" type="number" step="0.000001" inputmode="decimal" placeholder="e.g., 0.500000">
        <button class="btn btn-secondary" id="suggestPriceBtn" type="button">Best Price</button>
      </div>
      <div class="inline-hint">Limit price. Use <em>Market Order</em> to execute at best available price.</div>
    </div>

    <!-- Total -->
    <div class="total-line">
      <span>Total</span>
      <strong id="totalXrp">0.000000 XRP</strong>
    </div>

<div class="button-row">
  <button id="placeOfferBtn" class="btn btn-primary" type="button">Place Limit Order</button>
  
  <!-- Refresh clock indicator -->
  <div class="refresh-indicator">
    <div class="clock"></div>
    <span class="refresh-text">Auto-refreshes every 10s</span>
  </div>
</div>


    <p id="tradeMsg" class="status-text">â€”</p>

    <!-- Keep 'side' for existing JS logic (hidden) -->
    <select id="side" style="display:none">
      <option value="buy" selected>Buy</option>
      <option value="sell">Sell</option>
    </select>
  </div>
</div>


    <!-- Order Book -->
    <div class="card" style="margin-bottom:24px;">
      <h2 style="margin-top:0;">XRBC/XRP Order Book</h2>
      <button id="fetchPriceBtn" class="btn glow-btn" style="margin-bottom:12px;">Get Order Book</button>
      <p id="priceOutput">â€”</p>
    </div>

  </div>
<!-- AMM Pool Info -->
<div class="card" style="margin-bottom:24px;">
  <h2 style="margin-top:0;">XRBC/XRP AMM Pool</h2>
  <div id="ammPoolOutput">Loading pool infoâ€¦</div>
</div>


<!-- Config -->
<script type="application/json" id="app-config">
{
  "xummApiKey": "2abde023-0df1-49a2-a4dc-86d776f6318d",
  "proxyUrl": "https://xrbitcoincash-github-io.onrender.com"
}
</script>

<!-- Libraries -->
<script src="https://xaman.app/assets/cdn/xumm.min.js"></script>
<script>
  // === Config ===
  const cfg = JSON.parse(document.getElementById("app-config").textContent);
  const PROXY_URL = cfg.proxyUrl;

  // === XRBC constants ===
  const XRBC = {
    currency: "5852626974636F696E6361736800000000000000",
    issuer: "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw"
  };
  const XRP_TO_DROPS = 1_000_000;

  // === Proxy bridge ===
  async function xrplRequest(payload) {
    const res = await fetch(PROXY_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    if (!res.ok) throw new Error("Proxy error: " + res.status);
    const data = await res.json();
    if (data.error) throw new Error("XRPL error: " + JSON.stringify(data.error));
    return data;
  }


// Drops utils

const toDrops = (xrp) => Math.round(Number(xrp) * XRP_TO_DROPS).toString();

// Guard: ensure wallet is connected
function requireWallet() {
  if (!window.__xrbcWallet) throw new Error("Connect your wallet first.");
  return window.__xrbcWallet;
}

    
  // === Helpers ===
  async function getLedgerInfo() {
    return await xrplRequest({ method: "ledger", params: [{ ledger_index: "validated" }] });
  }

  // === Order Book (dual-sided) ===
  async function getXrbcOrderBook() {
    async function fetchSide(taker_gets, taker_pays, sideName) {
      const rows = [];
      try {
        const data = await xrplRequest({
          method: "book_offers",
          params: [{ taker_gets, taker_pays, limit: 5 }]
        });
        if (data.result?.offers?.length) {
          for (const offer of data.result.offers) {
            const gets = offer.TakerGets.value
              ? parseFloat(offer.TakerGets.value)
              : parseFloat(offer.TakerGets) / XRP_TO_DROPS;
            const pays = offer.TakerPays.value
              ? parseFloat(offer.TakerPays.value)
              : parseFloat(offer.TakerPays) / XRP_TO_DROPS;
            const price = pays / gets;
            rows.push(`<tr><td>${sideName}</td><td>${price.toFixed(6)}</td><td>${gets.toFixed(2)}</td></tr>`);
          }
        } else {
          rows.push(`<tr><td>${sideName}</td><td>No offers</td><td>-</td></tr>`);
        }
      } catch (err) {
        rows.push(`<tr><td>${sideName}</td><td>Error</td><td>${err.message}</td></tr>`);
      }
      return rows;
    }
    const asks = await fetchSide(XRBC, { currency: "XRP" }, "Ask");
    const bids = await fetchSide({ currency: "XRP" }, XRBC, "Bid");
    return `
      <table class="table">
        <thead><tr><th>Side</th><th>Price (XRP/XRBC)</th><th>Amount</th></tr></thead>
        <tbody>${asks.join("")}${bids.join("")}</tbody>
      </table>
    `;
  }

  // === Main logic ===
  (async function(){
    // Wallet connect
    const xumm = new Xumm(cfg.xummApiKey);
    const btn = document.getElementById("connectWalletBtn");
    const statusEl = document.getElementById("walletStatus");
   
    
    const disconnectBtn = document.getElementById("disconnectWalletBtn");

let hasSavedAcct = false;  // tracks if we restored a prior session

    // Restore persisted connection on refresh (if present)
const savedAcct = localStorage.getItem("xrbcWallet");
if (savedAcct) {
  hasSavedAcct = true;
  window.__xrbcWallet = savedAcct;
  statusEl.textContent = "Connected: " + savedAcct;
  disconnectBtn.disabled = false;
  btn.disabled = true; // keep "Connect" disabled while connected
}


    
   xumm.on("ready", () => { if (!hasSavedAcct) btn.disabled = false; });


    
    btn.addEventListener("click", async () => {
      try {
      await xumm.authorize();

        
        
        const acct = await xumm.user.account;
   
        
    statusEl.textContent = "Connected: " + acct;
window.__xrbcWallet = acct;
localStorage.setItem("xrbcWallet", acct);  // <-- persist to browser

// update buttons
disconnectBtn.disabled = false;
btn.disabled = true;

      
      } catch (err) {
        statusEl.textContent = "Failed to connect wallet";
      }
    });
// Disconnect wallet
disconnectBtn.addEventListener("click", () => {

  // Clear local + persistent account
window.__xrbcWallet = null;
localStorage.removeItem("xrbcWallet");

  // Kill Xumm session so it doesnâ€™t auto-connect
  xumm.logout();

  // Reset UI
  statusEl.textContent = "Status: Disconnected";
  disconnectBtn.disabled = true;
  btn.disabled = false;
});

 // Ledger fetch
document.getElementById("fetchLedgerBtn").addEventListener("click", async () => {
  const ledgerOut = document.getElementById("ledgerOutput");
  let seconds = 0;
  const maxSeconds = 30;

  const messages = [
    "Initializing secure connectionâ€¦",
    "Establishing proxy communicationâ€¦",
    "Synchronizing with XRPL Ledgerâ€¦",
    "Validating ledger data integrityâ€¦",
    "Establishing secure connection to digital environmentâ€¦",
    "Finalizing ledger responseâ€¦"
  ];

  // Initial message
  ledgerOut.textContent = messages[0];
  ledgerOut.style.color = "#9fb0c5";

  // Cycle through messages
  const interval = setInterval(() => {
    seconds++;
    const msgIndex = Math.floor((seconds / 2) % messages.length); 
    ledgerOut.textContent = messages[msgIndex] + ` (${seconds}s)`;
  }, 2000);

  try {
    const info = await getLedgerInfo();
    clearInterval(interval);
    ledgerOut.style.color = "#a3e4ff";
    ledgerOut.textContent = JSON.stringify(info, null, 2);
  } catch (err) {
    clearInterval(interval);
    ledgerOut.style.color = "#ef4444";
    ledgerOut.textContent = "Error: " + err.message;
  }
});


    // Order book
    document.getElementById("fetchPriceBtn").addEventListener("click", async () => {
      const priceOut = document.getElementById("priceOutput");
      priceOut.textContent = "Loading XRBC/XRP order bookâ€¦";
      try {
        const html = await getXrbcOrderBook();
        priceOut.innerHTML = html;
      } catch (err) {
        priceOut.textContent = "Error: " + err.message;
      }
    });
 
// === Trading UI ===
const placeOfferBtn = document.getElementById("placeOfferBtn");
const sideEl   = document.getElementById("side");
const amountEl = document.getElementById("amount");
const priceEl  = document.getElementById("price");
const tradeMsg = document.getElementById("tradeMsg");

// --- UX helpers (do not change your order logic) ---
const tradeCard   = document.getElementById("tradeCard");
const buyTab      = document.getElementById("buyTab");
const sellTab     = document.getElementById("sellTab");
const totalXrpEl  = document.getElementById("totalXrp");
const suggestBtn  = document.getElementById("suggestPriceBtn");
const actionWordEl= document.getElementById("actionWord");

// Color/labels + side switcher
function setSide(side) {
  sideEl.value = side;
  buyTab.classList.toggle("active", side === "buy");
  sellTab.classList.toggle("active", side === "sell");
  if (actionWordEl) actionWordEl.textContent = side;
  recalcTotals();
}

// Live total calculator
function recalcTotals() {
  const amt = Number(amountEl.value) || 0;
  const px  = Number(priceEl.value)  || 0;
  const total = amt * px;
  totalXrpEl.textContent = (isFinite(total) ? total : 0).toFixed(6) + " XRP";
}
[amountEl, priceEl].forEach(el => el.addEventListener("input", recalcTotals));

// === Best Price from AMM pool (with flashing + pool info) ===
async function fillBestPrice() {
  const side = sideEl.value;
  const amount = Number(amountEl.value);

  if (!amount || amount <= 0) {
    tradeMsg.textContent = "Enter a valid XRBC amount.";
    tradeMsg.classList.remove("ok", "err");
    return;
  }

  // ðŸ” Show flashing "connecting" message
  tradeMsg.textContent = "ðŸ” Connecting to XRPL for secure best priceâ€¦";
  tradeMsg.classList.remove("ok", "err");
  tradeMsg.classList.add("connecting");
  tradeMsg.style.animation = "flashText 1.6s infinite alternate";
  tradeMsg.style.color = "#00E5FF";
  tradeMsg.style.fontWeight = "700";

  try {
    // Query AMM pool info
    const data = await xrplRequest({
      method: "amm_info",
      params: [
        {
          asset: { currency: "XRP" },
          asset2: { currency: XRBC.currency, issuer: XRBC.issuer }
        }
      ]
    });

    const amm = data.result?.amm;
    if (!amm) throw new Error("No AMM found for XRBC/XRP");

    // Convert reserves
    const reserveXrp  = parseFloat(amm.amount) / XRP_TO_DROPS;
    const reserveXrbc = parseFloat(amm.amount2.value);
    const feeRate     = amm.trading_fee / 1_000_000;
    const k           = reserveXrp * reserveXrbc;

    let effectivePrice;
    if (side === "buy") {
      const newReserveY = reserveXrbc - amount;
      const newReserveX = k / newReserveY;
      let xrpIn = newReserveX - reserveXrp;
      const fee = xrpIn * feeRate;
      xrpIn += fee;
      effectivePrice = xrpIn / amount;
    } else {
      const newReserveY = reserveXrbc + amount;
      const newReserveX = k / newReserveY;
      let xrpOut = reserveXrp - newReserveX;
      const fee = xrpOut * feeRate;
      xrpOut -= fee;
      effectivePrice = xrpOut / amount;
    }

    // âœ… Update price field + tradeMsg
    priceEl.value = Number(effectivePrice).toFixed(6);
    recalcTotals();
    tradeMsg.textContent = `Best price calculated from AMM pool (${side}).`;
    tradeMsg.classList.remove("connecting");
    tradeMsg.classList.add("ok");
    tradeMsg.style.animation = "none";
    tradeMsg.style.color = "#22c55e";
    tradeMsg.style.fontWeight = "600";

    // âœ… Also update AMM Pool Info section
    const poolOut = document.getElementById("ammPoolOutput");
    poolOut.innerHTML = `
      <table class="table">
        <thead><tr><th>Reserve</th><th>Value</th></tr></thead>
        <tbody>
          <tr><td>XRP</td><td>${reserveXrp.toFixed(2)} XRP</td></tr>
          <tr><td>XRBC</td><td>${reserveXrbc.toFixed(2)} XRBC</td></tr>
          <tr><td>Trading Fee</td><td>${(feeRate*100).toFixed(3)}%</td></tr>
        </tbody>
      </table>
    `;

  } catch (e) {
    // Instead of error, just keep showing flashing message
    tradeMsg.textContent = "ðŸ” Still connecting securely to XRPLâ€¦";
    tradeMsg.classList.add("connecting");
  }
}




  
// Wire up tabs + default state
buyTab.addEventListener("click", () => setSide("buy"));
sellTab.addEventListener("click", () => setSide("sell"));
if (suggestBtn) suggestBtn.addEventListener("click", fillBestPrice);
setSide(sideEl.value || "buy"); // initialize
recalcTotals();

// === Auto-refresh Best Price every 10s ===
setInterval(() => {
  // only refresh if user entered a valid amount
  const amt = Number(amountEl.value);
  if (amt > 0) {
    fillBestPrice().catch(err => console.error("Auto-refresh error:", err));
  }
}, 10000);


    
    
placeOfferBtn.addEventListener("click", async () => {
  try {
    const account = requireWallet();
    const side   = sideEl.value;
    const amt    = Number(amountEl.value);
    const price  = Number(priceEl.value);

    if (!amt || !price || amt <= 0 || price <= 0) {
      throw new Error("Enter valid Amount & Price.");
    }

    let txjson;
    if (side === "sell") {
      const xrpTotal = price * amt;
      txjson = {
        TransactionType: "OfferCreate",
        Account: account,
        TakerGets: { currency: XRBC.currency, issuer: XRBC.issuer, value: String(amt) },
        TakerPays: toDrops(xrpTotal),
        Flags: 0x00080000 // tfSell
      };
    } else {
      const xrpTotal = price * amt;
      txjson = {
        TransactionType: "OfferCreate",
        Account: account,
        TakerGets: toDrops(xrpTotal),
        TakerPays: { currency: XRBC.currency, issuer: XRBC.issuer, value: String(amt) }
      };
    }

    tradeMsg.textContent = "Open Xaman to review & signâ€¦";

    const { resolved } = await xumm.payload.createAndSubscribe({ txjson }, (ev) => {
      if (ev?.opened) tradeMsg.textContent = "Payload opened in Xamanâ€¦";
      if (ev?.signed === false) tradeMsg.textContent = "Offer rejected.";
    });

    const result = await resolved;
    if (!result.signed) {
      tradeMsg.textContent = "Offer not signed.";
      return;
    }

    tradeMsg.textContent = "Offer submitted. Refreshing order bookâ€¦";
    const html = await getXrbcOrderBook();
    document.getElementById("priceOutput").innerHTML = html;

  } catch (err) {
    tradeMsg.textContent = "Error: " + err.message;
  }
});


// === Trustline Setup (Local) ===
const setTrustlineBtn = document.getElementById("setTrustlineBtn");
const trustlineMsg = document.getElementById("trustlineMsg");

setTrustlineBtn.addEventListener("click", async () => {
  trustlineMsg.textContent = "Preparing trustline requestâ€¦";

  try {
    const account = requireWallet(); // ensure wallet is connected
    const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

    if (isMobile) {
      // ðŸ“± Mobile â†’ skip payload, just show link
      const link = document.createElement("a");
      link.href = "https://xrpl.services/?issuer=rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw&currency=5852626974636F696E6361736800000000000000&limit=20999999.999999996";
      link.textContent = "ðŸ‘‰ Tap here to set XRBC Trustline";
      link.target = "_blank";
      link.rel = "noopener noreferrer";
      link.style.display = "inline-block";
      link.style.marginTop = "12px";
      link.style.color = "#60a5fa";
      link.style.fontWeight = "600";

      trustlineMsg.innerHTML = "Open the link below to set XRBC trustline:<br/>";
      trustlineMsg.appendChild(link);
      return; // âœ… nothing else to do on mobile
    }

    // ðŸ–¥ï¸ Desktop â†’ Xumm payload + QR
    const txjson = {
      TransactionType: "TrustSet",
      Account: account,
      LimitAmount: {
        currency: XRBC.currency,
        issuer: XRBC.issuer,
        value: "1000000"
      }
    };

    const payload = await xumm.payload.createAndSubscribe({ txjson }, (ev) => {
      if (ev?.opened) trustlineMsg.textContent = "Payload opened in Xamanâ€¦";
      if (ev?.signed === false) trustlineMsg.textContent = "Trustline rejected.";
    });

    if (payload?.created?.refs?.qr_png) {
      const qr = document.createElement("img");
      qr.src = payload.created.refs.qr_png;
      qr.alt = "Scan with Xaman to set XRBC trustline";
      qr.style.maxWidth = "240px";
      qr.style.marginTop = "12px";

      trustlineMsg.innerHTML = "Scan to sign trustline:<br/>";
      trustlineMsg.appendChild(qr);
    }

    // Wait for resolution
    const result = await payload.resolved;
    if (!result.signed) {
      trustlineMsg.textContent = "Trustline not signed.";
      return;
    }

    trustlineMsg.textContent = "âœ… Trustline set successfully!";
  } catch (err) {
    trustlineMsg.textContent = "Error: " + err.message;
  }
});

// === Dedicated AMM Pool updater ===
async function updateAmmPool() {
  try {
    const data = await xrplRequest({
      method: "amm_info",
      params: [
        {
          asset: { currency: "XRP" },
          asset2: { currency: XRBC.currency, issuer: XRBC.issuer }
        }
      ]
    });

    const amm = data.result?.amm;
    if (!amm) {
      document.getElementById("ammPoolOutput").textContent = "No AMM pool exists yet.";
      return;
    }

    const reserveXrp  = (parseFloat(amm.amount) / XRP_TO_DROPS).toFixed(6);
    const reserveXrbc = parseFloat(amm.amount2.value).toFixed(6);
    const feeRate     = (amm.trading_fee / 10000).toFixed(2); // %

    document.getElementById("ammPoolOutput").innerHTML = `
      <table class="table">
        <thead><tr><th>Reserve XRP</th><th>Reserve XRBC</th><th>Trading Fee</th></tr></thead>
        <tbody>
          <tr>
            <td>${reserveXrp}</td>
            <td>${reserveXrbc}</td>
            <td>${feeRate}%</td>
          </tr>
        </tbody>
      </table>
    `;
  } catch (err) {
    document.getElementById("ammPoolOutput").textContent = "Error fetching AMM pool: " + err.message;
  }
}

// refresh initially + every 15s
updateAmmPool();
setInterval(updateAmmPool, 15000);

    
})();   // closes the main async IIFE
</script>
</body>
</html>
