<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>XRBC Coin Toss</title>
<style>
  body { margin: 0; overflow: hidden; background: #222; }
  canvas { display: block; margin: 0 auto; background: #87CEEB; }
  #score { position: absolute; top: 10px; left: 10px; color: white; font-family: sans-serif; font-size: 20px; }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<canvas id="gameCanvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
const { Engine, Render, World, Bodies, Body, Events, Constraint, Vector } = Matter;

// --- Setup engine & renderer ---
const engine = Engine.create();
const world = engine.world;

const canvas = document.getElementById('gameCanvas');
const width = window.innerWidth;
const height = window.innerHeight;

const render = Render.create({
    canvas: canvas,
    engine: engine,
    options: { width: width, height: height, wireframes: false, background: '#87CEEB' }
});

// --- Score ---
let score = 0;
const updateScore = (points) => {
    score += points;
    document.getElementById('score').textContent = `Score: ${score}`;
}

// --- Boundaries ---
const ground = Bodies.rectangle(width/2, height+10, width, 20, { isStatic: true });
const leftWall = Bodies.rectangle(-10, height/2, 20, height, { isStatic: true });
const rightWall = Bodies.rectangle(width+10, height/2, 20, height, { isStatic: true });
const ceiling = Bodies.rectangle(width/2, -10, width, 20, { isStatic: true });
World.add(world, [ground, leftWall, rightWall, ceiling]);

// --- Platforms ---
const platforms = [
    Bodies.rectangle(width/2, height/2, 300, 20, { isStatic: true }),
    Bodies.rectangle(width/3, height/3, 200, 20, { isStatic: true }),
    Bodies.rectangle(2*width/3, height/3 + 100, 250, 20, { isStatic: true })
];
World.add(world, platforms);

// --- Human Ragdoll Class ---
class Human {
    constructor(x, y, scale = 1) {
        this.scale = scale;
        const s = scale;

        this.hp = 100;

        // Torso
        this.torso = Bodies.rectangle(x, y, 20*s, 50*s, { label: 'torso', render: { fillStyle: '#8d5524' } });
        // Head
        this.head = Bodies.circle(x, y - 35*s, 12*s, { label: 'head', render: { fillStyle: '#ffdbac' } });
        // Arms
        this.leftArm = Bodies.rectangle(x - 20*s, y - 10*s, 10*s, 40*s, { label: 'arm', render: { fillStyle: '#ffdbac' } });
        this.rightArm = Bodies.rectangle(x + 20*s, y - 10*s, 10*s, 40*s, { label: 'arm', render: { fillStyle: '#ffdbac' } });
        // Legs
        this.leftLeg = Bodies.rectangle(x - 8*s, y + 40*s, 10*s, 40*s, { label: 'leg', render: { fillStyle: '#0000ff' } });
        this.rightLeg = Bodies.rectangle(x + 8*s, y + 40*s, 10*s, 40*s, { label: 'leg', render: { fillStyle: '#0000ff' } });

        // Constraints
        this.constraints = [
            Constraint.create({ bodyA: this.head, bodyB: this.torso, length: 20*s, stiffness: 0.8 }),
            Constraint.create({ bodyA: this.leftArm, bodyB: this.torso, length: 25*s, stiffness: 0.6 }),
            Constraint.create({ bodyA: this.rightArm, bodyB: this.torso, length: 25*s, stiffness: 0.6 }),
            Constraint.create({ bodyA: this.leftLeg, bodyB: this.torso, length: 35*s, stiffness: 0.7 }),
            Constraint.create({ bodyA: this.rightLeg, bodyB: this.torso, length: 35*s, stiffness: 0.7 })
        ];

        this.parts = [this.head, this.torso, this.leftArm, this.rightArm, this.leftLeg, this.rightLeg];

        this.parts.forEach(part => part.restitution = 0.5);

        World.add(world, this.parts.concat(this.constraints));
    }

    swat(coin) {
        const distLeft = Vector.magnitude(Vector.sub(this.leftArm.position, coin.position));
        const distRight = Vector.magnitude(Vector.sub(this.rightArm.position, coin.position));
        const forceMagnitude = 0.05;

        if(distLeft < distRight) {
            Body.applyForce(coin, coin.position, { 
                x: (coin.position.x - this.leftArm.position.x) * forceMagnitude, 
                y: (coin.position.y - this.leftArm.position.y) * forceMagnitude 
            });
        } else {
            Body.applyForce(coin, coin.position, { 
                x: (coin.position.x - this.rightArm.position.x) * forceMagnitude, 
                y: (coin.position.y - this.rightArm.position.y) * forceMagnitude 
            });
        }
    }

    takeDamage(amount) {
        this.hp -= amount;
        if(this.hp <= 0) {
            updateScore(50);
            this.parts.forEach(p => World.remove(world, p));
            this.constraints.forEach(c => World.remove(world, c));
            const index = characters.indexOf(this);
            if(index > -1) characters.splice(index, 1);
        }
    }
}

// --- Create Characters ---
const characters = [
    new Human(width/2, height/2 - 50),
    new Human(width/3, height/3 - 50),
    new Human(2*width/3, height/3 + 50)
];

// --- Coin Throwing ---
const coins = [];
canvas.addEventListener('mousedown', (e) => {
    const coin = Bodies.circle(100, height - 100, 15, { restitution: 0.9, label: 'coin' });
    World.add(world, coin);
    coins.push(coin);

    const mouseMove = (moveEvent) => {
        Body.setPosition(coin, { x: moveEvent.clientX, y: moveEvent.clientY });
    };
    const mouseUp = (upEvent) => {
        const forceX = (coin.position.x - upEvent.clientX) * -0.002;
        const forceY = (coin.position.y - upEvent.clientY) * -0.002;
        Body.applyForce(coin, coin.position, { x: forceX, y: forceY });
        window.removeEventListener('mousemove', mouseMove);
        window.removeEventListener('mouseup', mouseUp);
    };
    window.addEventListener('mousemove', mouseMove);
    window.addEventListener('mouseup', mouseUp);
});

// --- Collision Events ---
Events.on(engine, 'collisionStart', (event) => {
    event.pairs.forEach(pair => {
        const coin = pair.bodyA.label === 'coin' ? pair.bodyA : (pair.bodyB.label === 'coin' ? pair.bodyB : null);
        if(!coin) return;

        const human = characters.find(h => h.parts.includes(pair.bodyA) || h.parts.includes(pair.bodyB));
        if(!human) return;

        if(pair.bodyA.label === 'arm' || pair.bodyB.label === 'arm') {
            human.takeDamage(10);
            updateScore(-5);
        } else if(pair.bodyA.label === 'torso' || pair.bodyB.label === 'torso' || pair.bodyA.label === 'head' || pair.bodyB.label === 'head') {
            updateScore(10);
        }
    });
});

// --- Game Loop ---
Engine.run(engine);
Render.run(render);

// --- Character AI ---
setInterval(() => {
    coins.forEach(coin => {
        characters.forEach(c => {
            const torsoPos = c.torso.position;
            const dist = Vector.magnitude(Vector.sub(torsoPos, coin.position));
            if(dist < 100) {
                c.swat(coin);
            }
        });
    });
}, 500);

</script>
</body>
</html>
