<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>XRBC Coin Toss</title>
<style>
  body { margin: 0; overflow: hidden; background: #222; }
  canvas { display: block; margin: 0 auto; background: #87CEEB; }
  #score { position: absolute; top: 10px; left: 10px; color: white; font-family: sans-serif; font-size: 20px; }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<canvas id="gameCanvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
const { Engine, Render, World, Bodies, Body, Events, Constraint, Vector } = Matter;

// --- Setup engine & renderer ---
const engine = Engine.create();
const world = engine.world;

const canvas = document.getElementById('gameCanvas');
const width = window.innerWidth;
const height = window.innerHeight;

const render = Render.create({
    canvas: canvas,
    engine: engine,
    options: { width: width, height: height, wireframes: false, background: '#87CEEB' }
});

// --- Score ---
let score = 0;
const updateScore = (points) => {
    score += points;
    document.getElementById('score').textContent = `Score: ${score}`;
}

// --- Boundaries ---
const ground = Bodies.rectangle(width/2, height+10, width, 20, { isStatic: true });
const leftWall = Bodies.rectangle(-10, height/2, 20, height, { isStatic: true });
const rightWall = Bodies.rectangle(width+10, height/2, 20, height, { isStatic: true });
const ceiling = Bodies.rectangle(width/2, -10, width, 20, { isStatic: true });
World.add(world, [ground, leftWall, rightWall, ceiling]);

// --- Platforms ---
const platforms = [
    Bodies.rectangle(width/2, height/2, 300, 20, { isStatic: true }),
    Bodies.rectangle(width/3, height/3, 200, 20, { isStatic: true }),
    Bodies.rectangle(2*width/3, height/3 + 100, 250, 20, { isStatic: true })
];
World.add(world, platforms);
// --- Catapult ---
const catapultBase = Bodies.rectangle(150, height - 100, 100, 20, { isStatic: true });
World.add(world, catapultBase);

const catapultArm = Bodies.rectangle(150, height - 120, 100, 20, { density: 0.002 });
World.add(world, catapultArm);

const catapultConstraint = Constraint.create({
    bodyA: catapultArm,
    pointB: { x: 150, y: height - 120 },
    length: 0,
    stiffness: 1
});
World.add(world, catapultConstraint);

let dragging = false;
let dragStart = null;

// Mouse/Touch down
const startDrag = (e) => {
    e.preventDefault();
    const x = e.clientX || e.touches[0].clientX;
    const y = e.clientY || e.touches[0].clientY;

    const dist = Math.hypot(x - catapultArm.position.x, y - catapultArm.position.y);
    if (dist < 50) {  // Only start drag if near arm
        dragging = true;
        dragStart = { x, y };
    }
};

// Mouse/Touch move
const duringDrag = (e) => {
    if(!dragging) return;
    const x = e.clientX || e.touches[0].clientX;
    const y = e.clientY || e.touches[0].clientY;

    Body.setPosition(catapultArm, { x, y });
};

// Mouse/Touch up
const endDrag = (e) => {
    if(!dragging) return;
    dragging = false;
    const x = e.clientX || e.changedTouches[0].clientX;
    const y = e.clientY || e.changedTouches[0].clientY;

    const dx = dragStart.x - x;
    const dy = dragStart.y - y;
    const forceMultiplier = 0.002;  // Adjust strength
    const coin = Bodies.circle(catapultArm.position.x, catapultArm.position.y, 15, { restitution: 0.9, label: 'coin' });
    World.add(world, coin);
    coins.push(coin);

    Body.applyForce(coin, coin.position, { x: dx * forceMultiplier, y: dy * forceMultiplier });

    // Reset arm to original position
    Body.setPosition(catapultArm, { x: 150, y: height - 120 });
};

canvas.addEventListener('mousedown', startDrag);
canvas.addEventListener('mousemove', duringDrag);
canvas.addEventListener('mouseup', endDrag);

canvas.addEventListener('touchstart', startDrag);
canvas.addEventListener('touchmove', duringDrag);
canvas.addEventListener('touchend', endDrag);

// --- Human Ragdoll Class ---
class Human {
    constructor(x, y, scale = 1) {
        this.scale = scale;
        const s = scale;

        this.hp = 100;

        // Torso
        this.torso = Bodies.rectangle(x, y, 20*s, 50*s, { label: 'torso', render: { fillStyle: '#8d5524' } });
        // Head
        this.head = Bodies.circle(x, y - 35*s, 12*s, { label: 'head', render: { fillStyle: '#ffdbac' } });
        // Arms
        this.leftArm = Bodies.rectangle(x - 20*s, y - 10*s, 10*s, 40*s, { label: 'arm', render: { fillStyle: '#ffdbac' } });
        this.rightArm = Bodies.rectangle(x + 20*s, y - 10*s, 10*s, 40*s, { label: 'arm', render: { fillStyle: '#ffdbac' } });
        // Legs
        this.leftLeg = Bodies.rectangle(x - 8*s, y + 40*s, 10*s, 40*s, { label: 'leg', render: { fillStyle: '#0000ff' } });
        this.rightLeg = Bodies.rectangle(x + 8*s, y + 40*s, 10*s, 40*s, { label: 'leg', render: { fillStyle: '#0000ff' } });

        // Constraints
        this.constraints = [
            Constraint.create({ bodyA: this.head, bodyB: this.torso, length: 20*s, stiffness: 0.8 }),
            Constraint.create({ bodyA: this.leftArm, bodyB: this.torso, length: 25*s, stiffness: 0.6 }),
            Constraint.create({ bodyA: this.rightArm, bodyB: this.torso, length: 25*s, stiffness: 0.6 }),
            Constraint.create({ bodyA: this.leftLeg, bodyB: this.torso, length: 35*s, stiffness: 0.7 }),
            Constraint.create({ bodyA: this.rightLeg, bodyB: this.torso, length: 35*s, stiffness: 0.7 })
        ];

        this.parts = [this.head, this.torso, this.leftArm, this.rightArm, this.leftLeg, this.rightLeg];

        this.parts.forEach(part => part.restitution = 0.5);

        World.add(world, this.parts.concat(this.constraints));
    }

    swat(coin) {
        const distLeft = Vector.magnitude(Vector.sub(this.leftArm.position, coin.position));
        const distRight = Vector.magnitude(Vector.sub(this.rightArm.position, coin.position));
        const forceMagnitude = 0.05;

        if(distLeft < distRight) {
            Body.applyForce(coin, coin.position, { 
                x: (coin.position.x - this.leftArm.position.x) * forceMagnitude, 
                y: (coin.position.y - this.leftArm.position.y) * forceMagnitude 
            });
        } else {
            Body.applyForce(coin, coin.position, { 
                x: (coin.position.x - this.rightArm.position.x) * forceMagnitude, 
                y: (coin.position.y - this.rightArm.position.y) * forceMagnitude 
            });
        }
    }

    takeDamage(amount) {
        this.hp -= amount;
        if(this.hp <= 0) {
            updateScore(50);
            this.parts.forEach(p => World.remove(world, p));
            this.constraints.forEach(c => World.remove(world, c));
            const index = characters.indexOf(this);
            if(index > -1) characters.splice(index, 1);
        }
    }
}

// --- Create Characters ---
const characters = [
    new Human(width/2, height/2 - 50),
    new Human(width/3, height/3 - 50),
    new Human(2*width/3, height/3 + 50)
];



// --- Collision Events ---
Events.on(engine, 'collisionStart', (event) => {
    event.pairs.forEach(pair => {
        const coin = pair.bodyA.label === 'coin' ? pair.bodyA : (pair.bodyB.label === 'coin' ? pair.bodyB : null);
        if(!coin) return;

        const human = characters.find(h => h.parts.includes(pair.bodyA) || h.parts.includes(pair.bodyB));
        if(!human) return;

        if(pair.bodyA.label === 'arm' || pair.bodyB.label === 'arm') {
            human.takeDamage(10);
            updateScore(-5);
        } else if(pair.bodyA.label === 'torso' || pair.bodyB.label === 'torso' || pair.bodyA.label === 'head' || pair.bodyB.label === 'head') {
            updateScore(10);
        }
    });
});

// --- Game Loop ---
Engine.run(engine);
Render.run(render);

// --- Character AI ---
setInterval(() => {
    coins.forEach(coin => {
        characters.forEach(c => {
            const torsoPos = c.torso.position;
            const dist = Vector.magnitude(Vector.sub(torsoPos, coin.position));
            if(dist < 100) {
                c.swat(coin);
            }
        });
    });
}, 500);

</script>
</body>
</html>
