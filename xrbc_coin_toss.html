<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>XRBC Coin Slingshot</title>
<style>
  body { margin:0; overflow:hidden; background:#222; }
  canvas { display:block; margin:0 auto; background:#87CEEB; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
const { Engine, Render, World, Bodies, Body, Constraint, Vector, Events } = Matter;

// --- Engine & Renderer ---
const engine = Engine.create();
const world = engine.world;
const canvas = document.getElementById('gameCanvas');
const width = window.innerWidth;
const height = window.innerHeight;

const render = Render.create({
    canvas: canvas,
    engine: engine,
    options: { width, height, wireframes: false, background: '#87CEEB' }
});

// --- Borders ---
const wallThickness = 50;
const walls = [
    Bodies.rectangle(width/2, -wallThickness/2, width, wallThickness, { isStatic:true }),
    Bodies.rectangle(width/2, height+wallThickness/2, width, wallThickness, { isStatic:true }),
    Bodies.rectangle(-wallThickness/2, height/2, wallThickness, height, { isStatic:true }),
    Bodies.rectangle(width+wallThickness/2, height/2, wallThickness, height, { isStatic:true })
];
World.add(world, walls);

// --- Catapult base ---
const base = Bodies.rectangle(200, height-100, 40, 20, { isStatic:true });
World.add(world, base);

// --- Coin & Slingshot ---
let coin = null;
let slingshot = null;
let isDragging = false;
let dragStart = null;
const maxPullback = 150;

// --- Create new coin ---
function placeCoin(){
    coin = Bodies.circle(base.position.x, base.position.y - 50, 20, {
        restitution:0.8,
        render:{
            sprite:{
                texture:"xrbc-nft.png",
                xScale:0.15,
                yScale:0.15
            }
        }
    });
    World.add(world, coin);

    slingshot = Constraint.create({
        pointA:{ x: base.position.x, y: base.position.y - 50 },
        bodyB: coin,
        stiffness:0.02,
        length:0
    });
    World.add(world, slingshot);
}
placeCoin();

// --- Drag Controls ---
canvas.addEventListener('mousedown', startDrag);
canvas.addEventListener('mousemove', duringDrag);
canvas.addEventListener('mouseup', endDrag);
canvas.addEventListener('touchstart', startDrag);
canvas.addEventListener('touchmove', duringDrag);
canvas.addEventListener('touchend', endDrag);

function getMousePos(e){
    return { x:e.clientX || e.touches[0].clientX, y:e.clientY || e.touches[0].clientY };
}

function startDrag(e){
    if(!coin) return;
    const pos = getMousePos(e);
    const dist = Vector.magnitude(Vector.sub(pos, coin.position));
    if(dist < 30){
        isDragging = true;
        dragStart = pos;
    }
}

function duringDrag(e){
    if(!isDragging) return;
    const pos = getMousePos(e);
    // restrict drag to backward (left) only
    let dx = pos.x - slingshot.pointA.x;
    if(dx > 0) dx = 0; // cannot drag forward
    // clamp maximum pullback
    if(dx < -maxPullback) dx = -maxPullback;
    const dy = pos.y - slingshot.pointA.y;
    Body.setPosition(coin, { x: slingshot.pointA.x + dx, y: slingshot.pointA.y + dy });
}

function endDrag(e){
    if(!isDragging) return;
    isDragging = false;
    // calculate force based on distance
    const dx = slingshot.pointA.x - coin.position.x;
    const dy = slingshot.pointA.y - coin.position.y;
    const forceMultiplier = 0.002;
    Body.applyForce(coin, coin.position, { x: dx*forceMultiplier, y: dy*forceMultiplier });
    // remove slingshot
    World.remove(world, slingshot);
    slingshot = null;
    coin = null;
    setTimeout(placeCoin, 3000);
}

// --- Render slingshot visual and guide line ---
Events.on(render, 'afterRender', ()=>{
    const ctx = render.context;
    if(coin && isDragging){
        // draw slingshot bands
        ctx.beginPath();
        ctx.strokeStyle = "#654321";
        ctx.lineWidth = 6;
        ctx.moveTo(base.position.x-15, base.position.y-10);
        ctx.lineTo(coin.position.x, coin.position.y);
        ctx.moveTo(base.position.x+15, base.position.y-10);
        ctx.lineTo(coin.position.x, coin.position.y);
        ctx.stroke();

        // draw dotted guide line for trajectory
        ctx.beginPath();
        ctx.setLineDash([5,5]);
        ctx.strokeStyle = "#ffffff";
        ctx.moveTo(coin.position.x, coin.position.y);
        const dx = slingshot.pointA.x - coin.position.x;
        const dy = slingshot.pointA.y - coin.position.y;
        ctx.lineTo(coin.position.x + dx*5, coin.position.y + dy*5);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // draw slingshot base
    ctx.fillStyle = "#654321";
    ctx.fillRect(base.position.x-20, base.position.y-10, 40, 20);
});

// --- Run engine ---
Engine.run(engine);
Render.run(render);
</script>
</body>
</html>
