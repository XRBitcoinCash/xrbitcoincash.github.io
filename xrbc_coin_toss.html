<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>XRBC Coin Slingshot</title>
<style>
  body { margin:0; overflow:hidden; background:#222; }
  canvas { display:block; margin:0 auto; background:#87CEEB; }
  #score { position:absolute; top:10px; left:10px; color:white; font-family:sans-serif; font-size:24px; }
  #level { position:absolute; top:40px; left:10px; color:white; font-family:sans-serif; font-size:20px; }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<div id="level">Level: 1</div>
<canvas id="gameCanvas"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
const { Engine, Render, World, Bodies, Body, Constraint, Events, Vector } = Matter;

// --- Engine & Renderer ---
const engine = Engine.create();
const world = engine.world;
const canvas = document.getElementById('gameCanvas');
const width = window.innerWidth;
const height = window.innerHeight;

const render = Render.create({
    canvas: canvas,
    engine: engine,
    options: { width, height, wireframes: false, background: '#87CEEB' }
});
Engine.run(engine);
Render.run(render);

// --- Score & Level ---
let score = 0;
let level = 1;
const scoreDiv = document.getElementById('score');
const levelDiv = document.getElementById('level');
function addScore(points){ score += points; scoreDiv.textContent = `Score: ${score}`; }
function setLevel(l){ level = l; levelDiv.textContent = `Level: ${l}`; level=l; }

// --- Borders ---
const wallThickness = 50;
const walls = [
    Bodies.rectangle(width/2, -wallThickness/2, width, wallThickness, { isStatic:true }),
    Bodies.rectangle(width/2, height+wallThickness/2, width, wallThickness, { isStatic:true }),
    Bodies.rectangle(-wallThickness/2, height/2, wallThickness, height, { isStatic:true }),
    Bodies.rectangle(width+wallThickness/2, height/2, wallThickness, height, { isStatic:true })
];
World.add(world, walls);

// --- Slingshot ---
const slingBase = Bodies.rectangle(150, height-150, 40, 20, { isStatic:true });
World.add(world, slingBase);

let coin = null;
let slingshotConstraint = null;
let isDragging = false;
const maxPullback = 150;
const colors = ["#FFD700","#FF0000","#00FF00","#0000FF","#FF69B4"];
let meltedCoins = [];
let fallingBalls = [];
let groundRiseSpeed = 0.05;
let groundHeight = 30;

// --- Ground ---
const ground = Bodies.rectangle(width/2, height-groundHeight/2, width, groundHeight, { isStatic:true, render:{ fillStyle:"#ff4500" } });
World.add(world, ground);

// --- Place coin in slingshot ---
function spawnCoin(){
    const color = colors[Math.floor(Math.random()*colors.length)];
    coin = Bodies.circle(slingBase.position.x, slingBase.position.y - 50, 20, {
        restitution:0.8,
        render:{ fillStyle: color }
    });
    World.add(world, coin);
    slingshotConstraint = Constraint.create({
        pointA: { x: slingBase.position.x, y: slingBase.position.y - 50 },
        bodyB: coin,
        stiffness: 0.02,
        length: 0
    });
    World.add(world, slingshotConstraint);
}
spawnCoin();

// --- Drag controls ---
canvas.addEventListener('mousedown', startDrag);
canvas.addEventListener('mousemove', duringDrag);
canvas.addEventListener('mouseup', endDrag);
canvas.addEventListener('touchstart', startDrag);
canvas.addEventListener('touchmove', duringDrag);
canvas.addEventListener('touchend', endDrag);

function getMousePos(e){ return { x:e.clientX || e.touches[0].clientX, y:e.clientY || e.touches[0].clientY }; }
function startDrag(e){
    if(!coin) return;
    const pos = getMousePos(e);
    const dist = Vector.magnitude(Vector.sub(pos, coin.position));
    if(dist < 30) isDragging = true;
}
function duringDrag(e){
    if(!isDragging) return;
    const pos = getMousePos(e);
    let dx = pos.x - slingshotConstraint.pointA.x;
    if(dx > 0) dx = 0;
    if(dx < -maxPullback) dx = -maxPullback;
    const dy = pos.y - slingshotConstraint.pointA.y;
    Body.setPosition(coin, { x: slingshotConstraint.pointA.x + dx, y: slingshotConstraint.pointA.y + dy });
}
function endDrag(e){
    if(!isDragging) return;
    isDragging = false;
    const dx = slingshotConstraint.pointA.x - coin.position.x;
    const dy = slingshotConstraint.pointA.y - coin.position.y;
    Body.applyForce(coin, coin.position, { x: dx*0.003, y: dy*0.003 });
    World.remove(world, slingshotConstraint);
    slingshotConstraint = null;
    coin = null;
    setTimeout(spawnCoin, 3000);
}

// --- Falling balls ---
function spawnFallingBalls(count){
    for(let i=0;i<count;i++){
        const x = Math.random()*width;
        const color = colors[Math.floor(Math.random()*colors.length)];
        const ball = Bodies.circle(x, -50, 15, { restitution:0.5, render:{ fillStyle: color } });
        fallingBalls.push(ball);
        World.add(world, ball);
    }
}
spawnFallingBalls(level);

// --- Ground rise & melt handling ---
Events.on(engine, 'beforeUpdate', ()=>{
    Body.translate(ground, { x:0, y:-groundRiseSpeed });
    if(ground.position.y - groundHeight/2 <= 0){
        alert("Game Over! Final Score: "+score);
        window.location.reload();
    }
    meltedCoins.forEach((mc,i)=>{
        if(mc.melted){
            Body.translate(ground, { x:0, y:1 });
            meltedCoins.splice(i,1);
        }
    });
});

// --- Collision detection ---
Events.on(engine, 'collisionStart', (event)=>{
    event.pairs.forEach(pair=>{
        [pair.bodyA, pair.bodyB].forEach(body=>{
            if(body!==ground && body.circleRadius && !body.melted){
                if(body.position.y + body.circleRadius >= ground.position.y - groundHeight/2){
                    body.melted = true;
                    meltedCoins.push(body);
                    World.remove(world, body);
                    addScore(5);
                }
            }
        });
    });
});

// --- Level progression ---
let levelTimer = 0;
Events.on(engine, 'afterUpdate', ()=>{
    levelTimer += engine.timing.delta;
    if(levelTimer>10000){
        levelTimer=0;
        if(level<100){
            setLevel(level+1);
            spawnFallingBalls(level+1);
            groundRiseSpeed += 0.002;
        }
    }
});

// --- Slingshot render ---
Events.on(render, 'afterRender', ()=>{
    const ctx = render.context;
    if(coin && isDragging){
        ctx.beginPath();
        ctx.strokeStyle = "#654321";
        ctx.lineWidth = 6;
        ctx.moveTo(slingBase.position.x-15, slingBase.position.y-10);
        ctx.lineTo(coin.position.x, coin.position.y);
        ctx.moveTo(slingBase.position.x+15, slingBase.position.y-10);
        ctx.lineTo(coin.position.x, coin.position.y);
        ctx.stroke();

        ctx.beginPath();
        ctx.setLineDash([5,5]);
        ctx.strokeStyle = "#ffffff";
        const dx = slingshotConstraint.pointA.x - coin.position.x;
        const dy = slingshotConstraint.pointA.y - coin.position.y;
        ctx.moveTo(coin.position.x, coin.position.y);
        ctx.lineTo(coin.position.x + dx*5, coin.position.y + dy*5);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    ctx.fillStyle = "#654321";
    ctx.fillRect(slingBase.position.x-20, slingBase.position.y-10, 40, 20);
});
</script>
</body>
</html>
