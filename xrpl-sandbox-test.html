<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Instant Limit Order Extraction · XRPL</title>
  <link rel="canonical" href="about:blank" />
  <!-- Security headers to set at the server:
       Content-Security-Policy: default-src 'none'; base-uri 'self'; frame-ancestors 'none'; object-src 'none'; block-all-mixed-content; upgrade-insecure-requests; img-src 'self' data:; font-src 'self'; connect-src 'self' https://xaman.app https://xumm.app https://YOUR_PROXY_DOMAIN; script-src 'self' https://xaman.app sha256-1Z8s+Kc5oD8l8WnDquXJg2jAMt2n0YlTrv8gFWhstRc=; style-src 'self' sha256-dn1iKAZ5pO0lMhCoutebFgRPJX/MAqgrXkNAq5XbQdk=; form-action 'self';
       Referrer-Policy: no-referrer
       Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
       X-Content-Type-Options: nosniff
       Cross-Origin-Opener-Policy: same-origin
       Cross-Origin-Embedder-Policy: require-corp
       Permissions-Policy: geolocation=(), camera=(), microphone=(), usb=(), payment=()
  -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; base-uri 'self'; frame-ancestors 'none'; object-src 'none'; block-all-mixed-content; upgrade-insecure-requests; img-src 'self' data:; font-src 'self'; connect-src 'self' https://xaman.app https://xumm.app https://YOUR_PROXY_DOMAIN; script-src 'self' https://xaman.app sha256-1Z8s+Kc5oD8l8WnDquXJg2jAMt2n0YlTrv8gFWhstRc=; style-src 'self' sha256-dn1iKAZ5pO0lMhCoutebFgRPJX/MAqgrXkNAq5XbQdk=; form-action 'self'">
  <meta http-equiv="Referrer-Policy" content="no-referrer">
  <meta name="color-scheme" content="dark light">
  <link rel="preconnect" href="https://xaman.app" crossorigin>
  <link rel="preconnect" href="https://xumm.app" crossorigin>
  <link rel="preconnect" href="https://YOUR_PROXY_DOMAIN">
  <style>
:root{--wrap:980px;--bg:#0b0f14;--panel:#0e1520;--panel-2:#0c131c;--ink:#e7edf5;--muted:#9fb0c5;--line:#2b3a4b;--ok:#22c55e;--err:#ef4444;--accent:#60a5fa}
*{box-sizing:border-box}html,body{height:100%;max-width:100%;overflow-x:hidden}body{background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;margin:0}
.container{max-width:var(--wrap);margin:16px auto;padding:0 16px}
.card{background:linear-gradient(180deg,var(--panel),var(--panel-2));border:1px solid var(--line);border-radius:14px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);margin-top:12px}
h1,h2{margin:.2em 0}
.btn{appearance:none;border:1px solid var(--line);border-radius:10px;background:linear-gradient(180deg,#0e1520,#0c131c);color:var(--ink);padding:10px 14px;font-weight:800;cursor:pointer;min-height:44px}
.btn:disabled{opacity:.6;cursor:not-allowed}
.btn-row{display:flex;gap:10px;flex-wrap:wrap;margin:8px 0 10px}
.status{font-size:13px;color:var(--muted)}
.status.ok{color:var(--ok)} .status.err{color:var(--err)}
table{width:100%;border-collapse:collapse;margin-top:10px;font-size:14px}
th,td{padding:8px 10px;border-bottom:1px solid #1a2433;text-align:left;vertical-align:top}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
.hint{color:var(--muted);font-size:12px}
.pill{display:inline-block;border:1px solid var(--line);border-radius:9999px;padding:2px 8px;font-weight:800}
.warn{border-left:4px solid #d97706;background:linear-gradient(180deg,#231b0c,#1a140a);border:1px solid #3a2f18;border-radius:10px;padding:10px;color:#f3e8d0}
.footer{margin-top:20px;color:#9fb0c5;font-size:12px}
.badge{display:inline-block;padding:2px 8px;border:1px solid var(--line);border-radius:9999px;margin-left:8px}
.progress{height:6px;background:#112035;border-radius:9999px;overflow:hidden}
.progress>span{display:block;height:100%;background:#2563eb;width:0%}
.banner{padding:8px 12px;border:1px solid #244; border-radius:10px; margin-top:8px}
.banner.testnet{background:#102018;color:#9fe29f;border-color:#2c4}
.banner.mainnet{background:#181820;color:#cfd2ff;border-color:#44c}
kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;padding:2px 4px;border:1px solid var(--line);border-radius:4px;background:#0a111a}
  </style>
</head>
<body>
  <main class="container" aria-live="polite">
    <h1>Instant Limit Order Extraction</h1>
    <div class="banner mainnet"><strong>Network</strong>:
      <select id="network" aria-label="Network">
        <option value="mainnet" selected>Mainnet</option>
        <option value="testnet">Testnet</option>
      </select>
      <span id="netBadge" class="badge mainnet">Mainnet</span>
    </div>

    <section class="card" aria-labelledby="wlt">
      <h2 id="wlt">Wallet</h2>
      <div class="btn-row">
        <button id="btnConnect" class="btn" type="button">Connect Xumm (Xaman)</button>
        <button id="btnDisconnect" class="btn" type="button" disabled>Disconnect</button>
        <button id="btnRefresh" class="btn" type="button">Refresh Offers</button>
        <button id="btnCancelAll" class="btn" type="button" title="Cancel all visible open offers">Cancel All Visible</button>
      </div>
      <p id="walletStatus" class="status">Status: Not connected</p>
      <div class="hint">Keys never requested. All signing happens in your wallet.</div>
    </section>

    <section class="card" aria-labelledby="orders">
      <h2 id="orders">Open Orders</h2>
      <div id="offersWrap" class="hint">No data yet.</div>
      <div class="progress" aria-hidden="true"><span id="progressBar"></span></div>
      <p id="offersStatus" class="status"></p>
    </section>

    <section class="card" aria-labelledby="important">
      <h2 id="important">Important</h2>
      <div class="warn">
        This utility cancels open XRPL orders using OfferCancel. Verify details in your wallet before approving. Transactions are irreversible and fees apply.
      </div>
      <p class="footer">
        Tip: Keep this page and your wallet on the same network. If results look stale, switch servers or refresh and retry.
      </p>
    </section>
  </main>

  <!-- App configuration -->
  <script type="application/json" id="app-config">
  {
    "xummApiKey": "REPLACE_WITH_XUMM_API_KEY",
    "proxyUrl": "https://YOUR_PROXY_DOMAIN/api",
    "networks": {
      "mainnet": { "label": "Mainnet" },
      "testnet": { "label": "Testnet" }
    }
  }
  </script>

  <!-- Xumm SDK (pin with SRI in production) -->
  <script src="https://xaman.app/assets/cdn/xumm.min.js" crossorigin="anonymous" integrity="REPLACE_WITH_KNOWN_SRI_HASH"></script>

  <!-- App script -->
  <script>
(function(){
  'use strict';
  // Config
  const cfgEl = document.getElementById('app-config');
  const cfg = cfgEl ? JSON.parse(cfgEl.textContent || '{}') : {};
  const PROXY_URL = cfg.proxyUrl || '';
  const NETWORKS = cfg.networks || { mainnet: { label:'Mainnet' }, testnet: { label:'Testnet' } };
  const XUMM_API_KEY = cfg.xummApiKey || '';
  const XRP_TO_DROPS = 1000000;

  // State
  let state = {
    account: null,
    network: 'mainnet',
    offers: [],
    xumm: null,
    isBusy: false
  };

  // Elements
  const el = (id)=>document.getElementById(id);
  const $statusWallet = el('walletStatus');
  const $statusOffers = el('offersStatus');
  const $offersWrap = el('offersWrap');
  const $btnConnect = el('btnConnect');
  const $btnDisconnect = el('btnDisconnect');
  const $btnRefresh = el('btnRefresh');
  const $btnCancelAll = el('btnCancelAll');
  const $network = el('network');
  const $progress = el('progressBar');
  const $netBadge = el('netBadge');

  // Security: defensive helpers
  const asText = (v)=>document.createTextNode(String(v));
  const safeNum = (v)=>Number.isFinite(Number(v)) ? Number(v) : 0;

  function setStatus(node, text, cls){
    if(!node) return;
    node.textContent = text;
    node.classList.remove('ok','err');
    if (cls) node.classList.add(cls);
  }

  function setBusy(flag){
    state.isBusy = !!flag;
    [$btnConnect,$btnDisconnect,$btnRefresh,$btnCancelAll].forEach(b=>{ if(b) b.disabled = flag; });
  }

  function updateNetBadge(){
    const n = state.network;
    if (!$netBadge) return;
    $netBadge.textContent = n === 'testnet' ? 'Testnet' : 'Mainnet';
    $netBadge.className = 'badge ' + (n==='testnet'?'testnet':'mainnet');
  }

  // Network switch
  if ($network){
    $network.addEventListener('change', ()=>{
      state.network = $network.value;
      updateNetBadge();
      if (state.account) fetchOffers(state.account);
    });
  }

  // Fetch via proxy with timeout and pinned methods
  async function xrplRequest(method, params, {timeoutMs=8000}={}){
    if (!PROXY_URL) throw new Error('Proxy URL missing');
    const ctrl = new AbortController();
    const timer = setTimeout(()=>ctrl.abort(), timeoutMs);
    try{
      const res = await fetch(PROXY_URL, {
        method:'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ method, params:[{...params, ledger_index:'validated'}], network: state.network }),
        mode:'cors',
        redirect:'error',
        signal: ctrl.signal,
        cache: 'no-store'
      });
      if (!res.ok) throw new Error('Proxy HTTP '+res.status);
      const data = await res.json();
      if (data && data.error) throw new Error('XRPL '+(data.error?.message||'error'));
      return data?.result || data;
    } finally {
      clearTimeout(timer);
    }
  }

  function fmtXRPdrops(drops){
    const n = safeNum(drops);
    return (n / XRP_TO_DROPS).toFixed(6) + ' XRP';
  }
  function isXRP(amt){ return typeof amt === 'string' || (amt && amt.currency === 'XRP'); }
  function amountStr(amt){
    if (typeof amt === 'string') return fmtXRPdrops(amt);
    if (!amt || typeof amt.value === 'undefined') return '—';
    const code = amt.currency === 'XRP' ? 'XRP' : (amt.currency || '').slice(0,160);
    return Number(amt.value).toFixed(6) + ' ' + code;
  }
  function calcPrice(gets, pays){
    const g = isXRP(gets) ? safeNum(gets)/XRP_TO_DROPS : safeNum(gets.value);
    const p = isXRP(pays) ? safeNum(pays)/XRP_TO_DROPS : safeNum(pays.value);
    if (g <= 0) return '—';
    return (p/g).toFixed(6);
  }

  function renderOffers(list){
    state.offers = Array.isArray(list) ? list : [];
    $offersWrap.innerHTML = '';
    const wrap = document.createElement('div');
    wrap.style.overflow = 'auto';
    const table = document.createElement('table');
    const thead = document.createElement('thead');
    const trh = document.createElement('tr');
    ['Offer Seq','Owner gets','Owner pays','Price','Action'].forEach(h=>{
      const th = document.createElement('th'); th.appendChild(asText(h)); trh.appendChild(th);
    });
    thead.appendChild(trh);
    table.appendChild(thead);
    const tbody = document.createElement('tbody');
    if (!state.offers.length){
      const empty = document.createElement('div');
      empty.className = 'hint';
      empty.appendChild(asText('No open offers found.'));
      $offersWrap.appendChild(empty);
      return;
    }
    state.offers.forEach(o=>{
      const tr = document.createElement('tr');
      const tdSeq = document.createElement('td'); tdSeq.className='mono'; tdSeq.appendChild(asText(o.seq)); tr.appendChild(tdSeq);
      const tdGets = document.createElement('td'); tdGets.appendChild(asText(amountStr(o.taker_gets))); tr.appendChild(tdGets);
      const tdPays = document.createElement('td'); tdPays.appendChild(asText(amountStr(o.taker_pays))); tr.appendChild(tdPays);
      const tdPx = document.createElement('td'); tdPx.appendChild(asText(calcPrice(o.taker_gets,o.taker_pays))); tr.appendChild(tdPx);
      const tdAct = document.createElement('td');
      const btn = document.createElement('button'); btn.className='btn'; btn.type='button'; btn.appendChild(asText('Cancel'));
      btn.addEventListener('click', ()=> cancelOne(o.seq));
      tdAct.appendChild(btn);
      tr.appendChild(tdAct);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    wrap.appendChild(table);
    $offersWrap.appendChild(wrap);
  }

  async function fetchOffers(acct){
    setStatus($offersStatus, 'Loading open offers…');
    try{
      const r = await xrplRequest('account_offers', { account: acct, limit: 400 });
      const offers = r.offers || [];
      renderOffers(offers);
      setStatus($offersStatus, `Found ${offers.length} open offer(s).`,'ok');
    }catch(e){
      renderOffers([]);
      setStatus($offersStatus, 'Error loading offers: '+(e.message||e),'err');
    }
  }

  async function cancelOne(seq){
    if (!state.account) { setStatus($offersStatus,'Connect wallet first.','err'); return; }
    setStatus($offersStatus, 'Preparing cancel '+seq+'…');
    try{
      const txjson = { TransactionType:'OfferCancel', Account: state.account, OfferSequence: Number(seq) };
      if (!state.xumm) throw new Error('Xumm not ready');
      const { resolved } = await state.xumm.payload.createAndSubscribe({ txjson, options: { submit: true, expire: 300 } }, ev => {
        if (ev?.opened) setStatus($offersStatus, 'Open Xaman to review & sign…');
        if (ev?.signed === false) setStatus($offersStatus, 'Canceled in wallet.','err');
      });
      const res = await resolved;
      if (!res?.signed){
        setStatus($offersStatus, 'Offer not canceled.','err'); 
        return;
      }
      setStatus($offersStatus, `Submitted cancel ${seq}. Waiting for validation…`);
      // Small delay then refresh
      await new Promise(r=>setTimeout(r, 1500));
      await fetchOffers(state.account);
      setStatus($offersStatus, `✅ Offer ${seq} cancel submitted.`,'ok');
    }catch(e){
      setStatus($offersStatus, 'Error: '+(e.message||e),'err');
    }
  }

  async function cancelAll(){
    if (!state.account) { setStatus($offersStatus,'Connect wallet first.','err'); return; }
    if (!state.offers.length){ setStatus($offersStatus,'No visible offers to cancel.'); return; }
    if (!confirm(`Cancel ${state.offers.length} offer(s)? You will sign each transaction in your wallet.`)) return;
    setBusy(true);
    const total = state.offers.length;
    let i = 0;
    for (const o of state.offers){
      i++;
      const pct = Math.floor((i-1)/total*100);
      if ($progress) $progress.style.width = pct+'%';
      await cancelOne(o.seq);
    }
    if ($progress) $progress.style.width = '100%';
    setBusy(false);
    setStatus($offersStatus,'Done.','ok');
  }

  // Xumm init
  function setupXumm(){
    if (typeof Xumm === 'undefined'){ setStatus($statusWallet,'Xumm SDK not loaded.','err'); return; }
    state.xumm = new Xumm(XUMM_API_KEY);
    $btnConnect.addEventListener('click', async ()=>{
      try{
        setBusy(true);
        setStatus($statusWallet,'Waiting for Xaman…');
        await state.xumm.authorize();
        const acct = await state.xumm.user.account;
        if (!acct) throw new Error('No account returned');
        state.account = acct;
        setStatus($statusWallet, 'Connected: '+acct, 'ok');
        $btnDisconnect.disabled = false;
        updateNetBadge();
        await fetchOffers(acct);
      } catch(e){
        setStatus($statusWallet, 'Connect canceled or failed. '+(e.message||e), 'err');
      } finally { setBusy(false); }
    });
    $btnDisconnect.addEventListener('click', ()=>{
      try{ state.xumm?.logout(); }catch{}
      state.account = null;
      $btnDisconnect.disabled = true;
      $offersWrap.textContent = '';
      setStatus($statusWallet,'Status: Not connected');
      setStatus($offersStatus,'');
      if ($progress) $progress.style.width = '0%';
    });
  }

  // Wire UI
  if ($btnRefresh) $btnRefresh.addEventListener('click', ()=>{
    if (!state.account){ setStatus($statusWallet,'Connect first.','err'); return; }
    fetchOffers(state.account);
  });
  if ($btnCancelAll) $btnCancelAll.addEventListener('click', cancelAll);

  // Boot
  document.addEventListener('DOMContentLoaded', ()=>{
    updateNetBadge();
    setupXumm();
  });
})();
  </script>
</body>
</html>
