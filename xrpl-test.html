<!DOCTYPE html>
<!-- ===== Page Script (single block) ===== -->
<script>
(function(){
'use strict';


/* ===== Utilities / Config ===== */
const cfgNode = document.getElementById("app-config");
const cfg = cfgNode ? JSON.parse(cfgNode.textContent || "{}") : {};
const PROXY_URL = cfg.proxyUrl || "";
const XRP_TO_DROPS = 1_000_000;
const XRBC = { currency: (cfg.xrbc && cfg.xrbc.currencyHex) || "5852626974636F696E6361736800000000000000", issuer: (cfg.xrbc && cfg.xrbc.issuer) || "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw" };
const normalizeHexCurrency = (s) => (s || '').toUpperCase().replace(/0+$/,'');
const XRBC_HEX_NORM = normalizeHexCurrency(XRBC.currency);


async function xrplRequest(payload){
if (!PROXY_URL) throw new Error("Proxy URL missing");
const res = await fetch(PROXY_URL, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify(payload) });
if (!res.ok) throw new Error("Proxy HTTP " + res.status);
const data = await res.json();
if (data && data.error) throw new Error("XRPL: " + JSON.stringify(data.error));
return data;
}
const toDrops = (xrp) => Math.round(Number(xrp) * XRP_TO_DROPS).toString();


/* ===== Theme toggle ===== */
(function themeInit(){
const btn = document.getElementById('themeToggle');
const saved = localStorage.getItem('xrbc-theme');
if (saved === 'light') document.body.classList.add('light-mode');
const sync = () => btn && btn.setAttribute('aria-pressed', document.body.classList.contains('light-mode') ? 'true' : 'false');
sync();
btn && btn.addEventListener('click', () => {
document.body.classList.toggle('light-mode');
localStorage.setItem('xrbc-theme', document.body.classList.contains('light-mode') ? 'light' : 'dark');
sync();
});
})();


/* ===== Download Xaman popover ===== */
(function initDownloadPopover(){
const wrap = document.querySelector(".dl-wrap");
if (!wrap) return;
const DOWNLOAD_URL = "https://xaman.app/download";
const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
const downloadBtn = document.getElementById("btnDownloadXaman");
const pop = document.getElementById("downloadPopover");
const qrImg = document.getElementById("downloadQr");


if (!downloadBtn || !pop) return;
if (qrImg && !qrImg.src){ qrImg.src = "https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=" + encodeURIComponent(DOWNLOAD_URL); }


function openPopover(){ pop.hidden = false; pop.classList.add("open"); pop.setAttribute("aria-hidden","false"); downloadBtn.setAttribute("aria-expanded","true"); }
function closePopover(){ pop.classList.remove("open"); pop.setAttribute("aria-hidden","true"); downloadBtn.setAttribute("aria-expanded","false"); setTimeout(() => { if (!pop.classList.contains("open")) pop.hidden = true; }, 300); }


downloadBtn.addEventListener("click", (e) => { if (isMobile) { window.location.href = DOWNLOAD_URL; return; } e.preventDefault(); (pop.classList.contains("open") ? closePopover : openPopover)(); });
document.addEventListener("click", (e) => { if (pop.hidden) return; if (!wrap.contains(e.target)) closePopover(); });
document.addEventListener("keydown", (e) => { if (e.key === "Escape" && !pop.hidden) closePopover(); });
})();


/* ===== Sentinel v1 helpers (6‑digit code in memo) ===== */
const SENTINEL_VERSION = 'v1';
let __signInFlight = false;
function genCode(){ const n = Math.floor(Math.random()*1_000_000); return String(n).padStart(6,'0'); }
function asciiToHex(str){ let out=''; for(let i=0;i<str.length;i++){ const h = str.charCodeAt(i).toString(16).toUpperCase(); out += (h.length===1?'0':'') + h; } return out; }
function nowIso(){ try{ return new Date().toISOString(); }catch{ return ''; } }
function appIdFromPath(p){ try{ const name=(p||location.pathname).split('/').filter(Boolean).pop()||'index.html'; return 'XRBC:'+name; }catch{ return 'XRBC:unknown'; } }
function originForMemo(){ try{ return location.origin + location.pathname; }catch{ return ''; } }
function buildPayloadWithSentinel(txjson, ctx){
const memos = Array.isArray(txjson.Memos) ? txjson.Memos.slice() : [];
memos.push({ Memo: { MemoType: asciiToHex('XRBC-SENT'), MemoData: asciiToHex(ctx.code) }});
memos.push({ Memo: { MemoType: asciiToHex('XRBC-CTX'), MemoData: asciiToHex(JSON.stringify({ v:SENTINEL_VERSION, ts:ctx.ts, origin:ctx.origin, app_id:ctx.app_id })) }});
return { ...txjson, Memos: memos };
}

/* ===== Xumm SDK: connect / disconnect / trustline (with gating + Sentinel 6-digit verification) ===== */
let xumm = null;
const walletStatus  = document.getElementById("walletStatus");
const trustlineMsg  = document.getElementById("trustlineMsg");
const connectBtn    = document.getElementById("connectWalletBtn");
const disconnectBtn = document.getElementById("disconnectWalletBtn");
const setTrustBtn   = document.getElementById("setTrustlineBtn");

// Prereq state
let HAS_TRUSTLINE = false;

// ===== Sentinel v1 (6-digit verification memos) =====
const SENTINEL_VERSION = "v1";
function genCode(){
  const n = Math.floor(Math.random()*1_000_000);
  return String(n).padStart(6,"0");
}
function asciiToHex(str){
  let out = "";
  for (let i=0;i<str.length;i++){
    const h = str.charCodeAt(i).toString(16).toUpperCase();
    out += (h.length===1?"0":"") + h;
  }
  return out;
}
function buildTxWithSentinelMemos(txjson, ctx){
  const memos = Array.isArray(txjson.Memos) ? txjson.Memos.slice() : [];
  memos.push({ Memo:{ MemoType: asciiToHex("XRBC-SENT"), MemoData: asciiToHex(ctx.code) }});
  memos.push({ Memo:{ MemoType: asciiToHex("XRBC-CTX"),  MemoData: asciiToHex(JSON.stringify({
    v:SENTINEL_VERSION, ts:ctx.ts, origin:ctx.origin, app:"XRBC:index.html"
  })) }});
  return { ...txjson, Memos: memos };
}
async function signWithSentinel(txjson, { statusEl = walletStatus } = {}){
  if (!xumm) throw new Error("Wallet SDK not available.");
  const code = genCode();
  const ctx  = { code, ts:new Date().toISOString(), origin: location.origin + location.pathname };
  statusEl && (statusEl.textContent = `Verify code: ${code} — it must match the memo in Xaman.`);

  const tx = buildTxWithSentinelMemos(txjson, ctx);
  const { resolved } = await xumm.payload.createAndSubscribe(
    {
      txjson: tx,
      options:{ submit: true, expire: 300 },
      custom_meta: {
        instruction: `Verify code ${code} and all details before signing.`,
        identifier:  `xrbc:index:${code}`,
        blob: { sentinel:"v1", code, when:ctx.ts, origin:ctx.origin }
      }
    },
    (ev) => {
      if (ev?.opened && statusEl) statusEl.textContent = "Open Xaman (or scan QR) to review…";
      if (ev?.signed === false && statusEl) statusEl.textContent = "Canceled in wallet.";
    }
  );

  const res = await resolved;
  if (!res?.signed) throw new Error("User rejected");
  statusEl && (statusEl.textContent = `Submitted. Code ${code} recorded in memo.`);
  return res;
}

// ===== Trustline helpers =====
const normalizeHexCurrency = (s) => (s || "").toUpperCase().replace(/0+$/,"");
const XRBC_HEX_NORM = normalizeHexCurrency(XRBC.currency);

async function checkTrustline(acct){
  try{
    if (!acct) return false;
    const lines = await xrplRequest({
      method: "account_lines",
      params: [{ account: acct, peer: XRBC.issuer, ledger_index: "validated" }]
    });
    const tl = (lines?.result?.lines || []).find(l => normalizeHexCurrency(l.currency) === XRBC_HEX_NORM);
    return !!tl;
  }catch{ return false; }
}

function togglePrereqsUI(){
  const connected = !!window.__xrbcWallet;

  if (connectBtn)    connectBtn.disabled    = connected;
  if (disconnectBtn) disconnectBtn.disabled = !connected;

  if (setTrustBtn){
    setTrustBtn.hidden   = !connected;
    setTrustBtn.disabled = !connected || HAS_TRUSTLINE;
  }

  const allowTrade   = connected && HAS_TRUSTLINE;
  const placeOfferBtn= document.getElementById("placeOfferBtn");
  const marketBtn    = document.getElementById("marketTradeBtn");
  if (placeOfferBtn) placeOfferBtn.disabled = !allowTrade;
  if (marketBtn)     marketBtn.disabled     = !allowTrade;
}

async function updateTrustline(acct){
  HAS_TRUSTLINE = await checkTrustline(acct);
  if (trustlineMsg) trustlineMsg.textContent = HAS_TRUSTLINE
    ? "✅ XRBC trustline present."
    : "XRBC trustline not found. Click “Set XRBC Trustline”.";
  togglePrereqsUI();
}

function setConnectedUI(acct){
  walletStatus && (walletStatus.textContent = "Connected: " + acct);
  window.__xrbcWallet = acct;
  localStorage.setItem("xrbcWallet", acct);
  disconnectBtn && (disconnectBtn.disabled = false);
  connectBtn    && (connectBtn.disabled = true);
  updateTrustline(acct).catch(()=>{});
}
function setDisconnectedUI(){
  walletStatus && (walletStatus.textContent = "Status: Not connected");
  window.__xrbcWallet = null;
  localStorage.removeItem("xrbcWallet");
  HAS_TRUSTLINE = false;
  togglePrereqsUI();
}

// Boot Xumm
if (typeof Xumm !== "undefined"){
  xumm = new Xumm(cfg.xummApiKey);

  const savedAcct = localStorage.getItem("xrbcWallet");
  if (savedAcct) setConnectedUI(savedAcct); else togglePrereqsUI();

  xumm.on("ready", async () => {
    try{
      const acct = await xumm.user.account;
      if (acct) setConnectedUI(acct);
      else togglePrereqsUI();
    } catch { togglePrereqsUI(); }
  });

  window.addEventListener("visibilitychange", () => {
    if (!document.hidden) { xumm.user.account.then(a => a && setConnectedUI(a)).catch(()=>{}); }
  });
  window.addEventListener("focus", () => {
    xumm.user.account.then(a => a && setConnectedUI(a)).catch(()=>{});
  });

  connectBtn && connectBtn.addEventListener("click", async () => {
    try {
      if (window.__xrbcWallet){
        walletStatus && (walletStatus.textContent = "Already connected: " + window.__xrbcWallet);
        return;
      }
      walletStatus && (walletStatus.textContent = "Waiting for Xaman… (scan QR if shown)");
      await xumm.authorize();
      const acct = await xumm.user.account;
      if (acct) setConnectedUI(acct);
      else walletStatus && (walletStatus.textContent = "Still waiting for Xaman…");
    } catch {
      walletStatus && (walletStatus.textContent = "Wallet connect canceled or timed out. Ensure Xaman is installed and try again.");
    }
  });

  disconnectBtn && disconnectBtn.addEventListener("click", () => {
    setDisconnectedUI();
    try { xumm.logout(); } catch {}
  });

  setTrustBtn && setTrustBtn.addEventListener("click", async () => {
    try {
      const acct = window.__xrbcWallet || (xumm && await xumm.user.account);
      if (!acct) {
        trustlineMsg && (trustlineMsg.textContent = "Please connect your wallet first, then try again.");
        connectBtn?.focus();
        return;
      }
      trustlineMsg && (trustlineMsg.textContent = "Preparing trustline request…");
      setTrustBtn.disabled = true;

      const txjson = {
        TransactionType: "TrustSet",
        Account: acct,
        LimitAmount: { currency: XRBC.currency, issuer: XRBC.issuer, value: "21000000" }
      };

      await signWithSentinel(txjson, { statusEl: trustlineMsg });
      trustlineMsg && (trustlineMsg.textContent = "✅ Trustline set successfully!");
      HAS_TRUSTLINE = true;
      togglePrereqsUI();
      refreshAll?.(); // soft refresh UI if available
    } catch (err) {
      trustlineMsg && (trustlineMsg.textContent = "Error: " + (err?.message || err));
    } finally {
      setTrustBtn.disabled = false;
    }
  });
} else {
  console.warn("Xumm SDK not loaded — wallet actions disabled.");
  connectBtn   && (connectBtn.disabled = true);
  setTrustBtn  && (setTrustBtn.disabled = true);
  trustlineMsg && (trustlineMsg.textContent = "Wallet features unavailable: Xaman SDK not loaded.");
  togglePrereqsUI();
}

/* ===== Trading UI (Buy/Sell, Best Price, Limit Order, AMM Swap) ===== */
const sideEl        = document.getElementById("side");
const tradeCard     = document.getElementById("tradeCard");
const buyTab        = document.getElementById("buyTab");
const sellTab       = document.getElementById("sellTab");
const amountEl      = document.getElementById("amount");
const priceEl       = document.getElementById("price");
const priceField    = document.getElementById("priceField");
const totalXrpEl    = document.getElementById("totalXrp");
const suggestBtn    = document.getElementById("suggestPriceBtn");
const placeOfferBtn = document.getElementById("placeOfferBtn");
const marketBtn     = document.getElementById("marketTradeBtn");
const tradeMsg      = document.getElementById("tradeMsg");

// XRP icon URL fix (guard)
(() => {
  const GOOD = 'https://xrbitcoincash.github.io/assetsxrp.svg';
  document.querySelectorAll('img[alt="XRP"]').forEach(img => {
    const src = String(img.src || '');
    if (src.endsWith('assetsxrp.svg.svg') || src.includes('assetsxrp.svg.svg')) {
      img.src = GOOD;
      img.decoding = 'async';
      img.loading  = 'eager';
    }
  });
})();

function updateExplainer(side){
  const wrap = document.getElementById("sideExplain");
  if (!wrap) return;

  const buyNote  = wrap.querySelector('.note.buy');
  const sellNote = wrap.querySelector('.note.sell');
  const showBuy = (side === 'buy');

  if (buyNote){
    buyNote.hidden = !showBuy;
    buyNote.classList.toggle('active', showBuy);
    buyNote.setAttribute('aria-hidden', (!showBuy).toString());
  }
  if (sellNote){
    sellNote.hidden = showBuy;
    sellNote.classList.toggle('active', !showBuy);
    sellNote.setAttribute('aria-hidden', (showBuy).toString());
  }

  const hint  = document.getElementById('amountHint');
  const label = document.getElementById('amountLabel');
  if (label) label.textContent = 'Amount (XRBC)';

  if (hint){
    const XRP_ICON = 'https://xrbitcoincash.github.io/assetsxrp.svg';
    hint.innerHTML = (side === 'buy')
      ? `How many XRBC you want to <span id="actionWord">buy</span>. <span class="nowrap">You’re trading <span class="asset-chip asset-xrp"><img src="${XRP_ICON}" alt="XRP" style="height:1.05em;width:auto;vertical-align:-.2em;background:#fff;border-radius:3px;padding:1px"> XRP</span> to receive <span class="asset-chip asset-xrbc"><img src="/xrbc-nft.png" alt="XRBC" style="height:1.05em;width:auto;vertical-align:-.2em;border-radius:3px"> XRBC</span>.</span>`
      : `How many XRBC you want to <span id="actionWord">sell</span>. <span class="nowrap">You’re trading <span class="asset-chip asset-xrbc"><img src="/xrbc-nft.png" alt="XRBC" style="height:1.05em;width:auto;vertical-align:-.2em;border-radius:3px"> XRBC</span> to receive <span class="asset-chip asset-xrp"><img src="${XRP_ICON}" alt="XRP" style="height:1.05em;width:auto;vertical-align:-.2em;background:#fff;border-radius:3px;padding:1px"> XRP</span>.</span>`;
  }
}

function setSide(side){
  if (sideEl) sideEl.value = side;
  if (buyTab)  { buyTab.classList.toggle("active", side==='buy');  buyTab.setAttribute('aria-selected', side==='buy' ? 'true':'false'); }
  if (sellTab) { sellTab.classList.toggle("active", side==='sell'); sellTab.setAttribute('aria-selected', side==='sell' ? 'true':'false'); }
  if (tradeCard){
    tradeCard.classList.toggle('buy', side==='buy');
    tradeCard.classList.toggle('sell', side==='sell');
  }
  updateExplainer(side);
  recalcTotals();
}
buyTab  && buyTab.addEventListener('click', () => setSide('buy'));
sellTab && sellTab.addEventListener('click', () => setSide('sell'));
setSide(sideEl?.value || 'buy');

function recalcTotals(){
  if (!totalXrpEl) return;
  const amt = Number(amountEl?.value) || 0;
  const px  = Number(priceEl?.value)  || 0;
  const total = (px || 0) * amt;
  totalXrpEl.textContent = (isFinite(total) ? total : 0).toFixed(6) + " XRP";
}
amountEl && amountEl.addEventListener("input", recalcTotals);
priceEl  && priceEl.addEventListener("input", recalcTotals);

// Wallet-aware balances for % chips
const BAL = { xrp: 0, xrbc: 0 };
const RESERVE_BUFFER_XRP = 1.0;

async function fetchBalances(){
  const acct = window.__xrbcWallet;
  if (!acct) { BAL.xrp = 0; BAL.xrbc = 0; return BAL; }

  try {
    const info = await xrplRequest({
      method: "account_info",
      params: [{ account: acct, ledger_index: "validated" }]
    });
    BAL.xrp = Number(info?.result?.account_data?.Balance || 0) / XRP_TO_DROPS;
  } catch { BAL.xrp = 0; }

  try {
    const lines = await xrplRequest({
      method: "account_lines",
      params: [{ account: acct, peer: XRBC.issuer, ledger_index: "validated" }]
    });
    const tl = (lines?.result?.lines || []).find(l => normalizeHexCurrency(l.currency) === XRBC_HEX_NORM);
    BAL.xrbc = tl ? Math.max(0, Number(tl.balance || 0)) : 0;
  } catch { BAL.xrbc = 0; }

  return BAL;
}

// % chips wire-up
(function initPercentChips(){
  const chips = document.querySelectorAll('.quick-amounts .qa');
  if (!chips.length) return;

  async function applyPercent(pct){
    const side = sideEl?.value || 'buy';
    await fetchBalances();

    if (side === 'sell'){
      const amt = Math.max(0, BAL.xrbc * (pct/100));
      if (amountEl){
        amountEl.value = amt.toFixed(6);
        amountEl.dispatchEvent(new Event('input'));
      }
      return;
    }

    let price = Number(priceEl?.value) || 0;
    if (!price) { await fillBestPrice(); price = Number(priceEl?.value) || 0; }
    if (!price || price <= 0) return;

    const spendable = Math.max(0, (BAL.xrp - RESERVE_BUFFER_XRP)) * (pct/100);
    const amt = spendable > 0 ? (spendable / price) : 0;

    if (amountEl){
      amountEl.value = amt.toFixed(6);
      amountEl.dispatchEvent(new Event('input'));
    }
  }

  chips.forEach(btn => btn.addEventListener('click', async () => {
    const pct = Number(btn.dataset.q || 0);
    if (!pct) return;
    btn.disabled = true;
    try { await applyPercent(pct); }
    finally { btn.disabled = false; }
  }));
})();

// Pricing helpers
async function getTopOfBook(){
  const [askRes, bidRes] = await Promise.all([
    xrplRequest({ method:"book_offers", params:[{ taker_gets: XRBC,             taker_pays: { currency:"XRP" }, limit:1 }] }),
    xrplRequest({ method:"book_offers", params:[{ taker_gets: { currency:"XRP"}, taker_pays: XRBC,             limit:1 }] })
  ]);
  const priceFrom = (of) => {
    if (!of) return null;
    const gets = of.TakerGets?.value ? parseFloat(of.TakerGets.value) : parseFloat(of.TakerGets) / XRP_TO_DROPS;
    const pays = of.TakerPays?.value ? parseFloat(of.TakerPays.value) : parseFloat(of.TakerPays) / XRP_TO_DROPS;
    if (!isFinite(gets) || gets <= 0 || !isFinite(pays)) return null;
    return pays / gets; // XRP per XRBC
  };
  return {
    bestAsk: priceFrom(askRes?.result?.offers?.[0]) || null, // price you pay to buy XRBC
    bestBid: priceFrom(bidRes?.result?.offers?.[0]) || null  // price you receive when selling XRBC
  };
}

async function getMarketPrice(side){
  // Try AMM first
  try {
    const data = await xrplRequest({
      method: "amm_info",
      params: [{ asset:{currency:"XRP"}, asset2:{currency:XRBC.currency, issuer:XRBC.issuer} }]
    });
    const amm = data?.result?.amm;
    if (amm && amountEl){
      const amt = Number(amountEl.value);
      if (amt > 0){
        const reserveXrp  = parseFloat(amm.amount) / XRP_TO_DROPS;
        const reserveXrbc = parseFloat(amm.amount2.value);
        const feeRate     = amm.trading_fee / 1_000_000;
        const k = reserveXrp * reserveXrbc;
        if (side === "buy"){
          const newY = reserveXrbc - amt;
          if (newY > 0){
            const newX = k / newY;
            let xrpIn = newX - reserveXrp;
            xrpIn += xrpIn * feeRate;
            return xrpIn / amt;
          }
        } else {
          const newY = reserveXrbc + amt;
          const newX = k / newY;
          let xrpOut = reserveXrp - newX;
          xrpOut -= xrpOut * feeRate;
          return xrpOut / amt;
        }
      }
    }
  } catch {}

  // Fallback: top of book
  const { bestAsk, bestBid } = await getTopOfBook();
  return side === "buy" ? bestAsk : bestBid;
}

// AMM-based price helper for the visible Price field
async function fillBestPrice() {
  if (!sideEl || !amountEl || !priceEl) return;
  const side = sideEl.value;
  const amount = Number(amountEl.value);
  if (!amount || amount <= 0) return; // quiet when no amount

  if (tradeMsg){ tradeMsg.textContent = "🔐 Connecting to XRPL for secure best price…"; tradeMsg.classList.remove("ok","err"); tradeMsg.classList.add("connecting"); }

  try {
    const px = await getMarketPrice(side);
    if (!px || px <= 0) throw new Error("No price available");
    priceEl.value = Number(px).toFixed(6);
    recalcTotals();
    if (tradeMsg){ tradeMsg.textContent = `Best price calculated from AMM/top-of-book (${side}).`; tradeMsg.classList.remove("connecting"); tradeMsg.classList.add("ok"); }
  } catch (err) {
    if (tradeMsg){ tradeMsg.textContent = "Price helper error: " + (err?.message || err); tradeMsg.classList.remove("connecting"); tradeMsg.classList.add("err"); }
  }
}
suggestBtn && suggestBtn.addEventListener("click", fillBestPrice);
setInterval(() => {
  const amt = Number(amountEl?.value);
  if (amt > 0) fillBestPrice().catch(()=>{});
}, 10000);

// Place Limit Order (gated w/ Sentinel)
placeOfferBtn && placeOfferBtn.addEventListener("click", async () => {
  try {
    if (!xumm) throw new Error("Wallet SDK not available.");
    const account = window.__xrbcWallet;
    if (!account) throw new Error("Connect your wallet first.");
    if (!HAS_TRUSTLINE){ tradeMsg.textContent = "Set the XRBC trustline first."; tradeMsg.classList.add("err"); setTrustBtn?.focus(); return; }

    const side   = sideEl?.value;
    const amt    = Number(amountEl?.value);
    const priceV = Number(priceEl?.value);

    if (!amt || !priceV || amt <= 0 || priceV <= 0) throw new Error("Enter valid Amount & Price.");

    const xrpTotal = priceV * amt;
    const TF_SELL = 0x00080000;

    let txjson;
    if (side === "sell") {
      txjson = {
        TransactionType: "OfferCreate",
        Account: account,
        TakerGets: { currency: XRBC.currency, issuer: XRBC.issuer, value: String(amt) },
        TakerPays: toDrops(xrpTotal),
        Flags: TF_SELL
      };
    } else {
      txjson = {
        TransactionType: "OfferCreate",
        Account: account,
        TakerGets: toDrops(xrpTotal),
        TakerPays: { currency: XRBC.currency, issuer: XRBC.issuer, value: String(amt) },
        Flags: 0
      };
    }

    tradeMsg && (tradeMsg.textContent = "Open Xaman to review & sign…");
    await signWithSentinel(txjson, { statusEl: tradeMsg });

    tradeMsg && (tradeMsg.textContent = "Order submitted. Refreshing order book…");
    await refreshOrderBook();
    await refreshLedger();
  } catch (err) {
    tradeMsg && (tradeMsg.textContent = "Error: " + (err?.message || err));
  }
});

// Market Swap (AMM path Payment, gated w/ Sentinel)
marketBtn && marketBtn.addEventListener("click", async () => {
  const SLIPPAGE_PCT = 2; // protective cap
  try {
    if (!xumm) throw new Error("Wallet SDK not available.");
    const account = window.__xrbcWallet;
    if (!account) throw new Error("Connect your wallet first.");
    if (!HAS_TRUSTLINE){ tradeMsg.textContent = "Set the XRBC trustline first."; tradeMsg.classList.add("err"); setTrustBtn?.focus(); return; }

    const side = sideEl?.value || "buy";
    const amt  = Number(amountEl?.value);
    if (!amt || amt <= 0) throw new Error("Enter valid Amount.");

    // Get a reference price to compute slippage bounds
    const basePx = await getMarketPrice(side);
    if (!basePx || basePx <= 0) throw new Error("No market price available.");
    const slip = SLIPPAGE_PCT / 100;

    // Helpers
    const TF_PARTIAL = 0x00020000; // tfPartialPayment
    const ceilDrops  = (xrp) => Math.ceil(Number(xrp) * XRP_TO_DROPS).toString();
    const floorDrops = (xrp) => Math.floor(Number(xrp) * XRP_TO_DROPS).toString();

    // === Path-find ===
    async function ripplePathFind(params){
      const r = await xrplRequest({ method: "ripple_path_find", params: [params] });
      const alts = r?.result?.alternatives || [];
      if (!alts.length) throw new Error("No AMM/paths available for this amount.");
      return alts;
    }
    function pickCheapestXrp(alts){
      // Choose alternative with lowest XRP cost
      let best = null, bestCostDrops = Infinity;
      for (const alt of alts){
        const sa = alt.source_amount;
        let costDrops = Infinity;
        if (typeof sa === "string"){
          costDrops = Number(sa); // XRP drops
        } else if (sa && sa.currency === "XRP"){
          costDrops = Number(ceilDrops(sa.value));
        }
        if (Number.isFinite(costDrops) && costDrops < bestCostDrops){
          best = alt; bestCostDrops = costDrops;
        }
      }
      if (!best) throw new Error("Could not price a path with XRP.");
      return { best, costDrops: bestCostDrops.toString() };
    }
    function pickCheapestIou(alts, iouCurrencyHex, iouIssuer){
      // Choose alternative with lowest IOU cost (for selling XRBC)
      let best = null, bestCost = Infinity;
      for (const alt of alts){
        const sa = alt.source_amount;
        if (sa && typeof sa === "object" && sa.currency && sa.issuer){
          const isXRBC = (sa.issuer === iouIssuer) &&
            (String(sa.currency).toUpperCase() === String(iouCurrencyHex).toUpperCase());
          if (isXRBC){
            const v = Number(sa.value);
            if (Number.isFinite(v) && v < bestCost){ best = alt; bestCost = v; }
          }
        }
      }
      if (!best) throw new Error("Could not price a path with XRBC as source.");
      return { best, cost: bestCost };
    }

    let txjson;

    if (side === "buy"){
      // Buy XRBC using XRP → set Amount in XRBC, cap SendMax in XRP, allow partial with DeliverMin
      const destAmt = { currency: XRBC.currency, issuer: XRBC.issuer, value: String(amt) };
      const alts = await ripplePathFind({
        source_account: account,
        destination_account: account,
        destination_amount: destAmt,
        source_currencies: [{ currency: "XRP" }]
      });
      const { best, costDrops } = pickCheapestXrp(alts);
      const maxSpendDrops = Math.ceil(Number(costDrops) * (1 + slip)).toString();

      txjson = {
        TransactionType: "Payment",
        Account: account,
        Destination: account,
        Amount: destAmt,
        SendMax: maxSpendDrops, // XRP in drops
        Flags: TF_PARTIAL,
        DeliverMin: { currency: XRBC.currency, issuer: XRBC.issuer, value: (amt * (1 - slip)).toFixed(6) },
        Paths: best.paths_computed || best.paths_canonical || []
      };
    } else {
      // Sell XRBC to receive XRP → set Amount in XRP, cap SendMax in XRBC, require DeliverMin
      const estXrp = amt * basePx;
      const minXrpDrops = floorDrops(estXrp * (1 - slip));

      // Guard against 0-drop rounding
      let _min = Number(minXrpDrops);
      if (_min < 1) throw new Error("Amount too small after slippage. Increase amount.");
      const minDrops = String(_min);

      const alts = await ripplePathFind({
        source_account: account,
        destination_account: account,
        destination_amount: minDrops, // XRP drops as target
        source_currencies: [{ currency: XRBC.currency, issuer: XRBC.issuer }]
      });
      const { best, cost } = pickCheapestIou(alts, XRBC.currency, XRBC.issuer);
      if (cost > amt) throw new Error("Amount too small for slippage cap. Increase amount or relax slippage.");

      txjson = {
        TransactionType: "Payment",
        Account: account,
        Destination: account,
        Amount: minDrops, // XRP in drops
        SendMax: { currency: XRBC.currency, issuer: XRBC.issuer, value: String(amt) },
        Flags: TF_PARTIAL,
        DeliverMin: minDrops,
        Paths: best.paths_computed || best.paths_canonical || []
      };
    }

    tradeMsg && (tradeMsg.textContent = "Open Xaman to review & sign AMM swap…");
    await signWithSentinel(txjson, { statusEl: tradeMsg });

    tradeMsg && (tradeMsg.textContent = "Swap submitted. Refreshing…");
    await refreshOrderBook();
    await refreshLedger();
  } catch (err) {
    tradeMsg && (tradeMsg.textContent = "Error: " + (err?.message || err));
  }
});

/* ===== Live Metrics: Ledger + Order Book (compact) ===== */
const ledgerOut = document.getElementById("ledgerOutput");
const bookOut   = document.getElementById("priceOutput");

async function getLedgerSummary(){
  const res = await xrplRequest({ method: "ledger", params: [{ ledger_index: "validated" }] });
  const r = res?.result || {};
  const idx   = r.ledger_index || r.validated_ledger_index || r.ledger?.ledger_index;
  const hash  = r.ledger_hash  || r.ledger?.ledger_hash;
  const close = r.ledger?.close_time_human || r.closed?.close_time_human;
  return {
    ledger_index: idx ?? "(unknown)",
    ledger_hash : hash ?? "(unknown)",
    close_time  : close || "(not expanded)",
    validated   : r.validated === undefined ? true : !!r.validated
  };
}

async function getOrderBookHtml(){
  async function side(taker_gets, taker_pays, label){
    const rows = [];
    try{
      const r = await xrplRequest({ method:"book_offers", params:[{ taker_gets, taker_pays, limit:5 }] });
      const offers = r?.result?.offers || [];
      if (!offers.length){
        rows.push(`<tr><td>${label}</td><td>No offers</td><td>-</td></tr>`);
      } else {
        for (const ofr of offers){
          const gets = ofr.TakerGets?.value ? parseFloat(ofr.TakerGets.value)
                                            : parseFloat(ofr.TakerGets) / XRP_TO_DROPS;
          const pays = ofr.TakerPays?.value ? parseFloat(ofr.TakerPays.value)
                                            : parseFloat(ofr.TakerPays) / XRP_TO_DROPS;
          const price = (isFinite(gets) && gets > 0) ? (pays / gets) : NaN;
          rows.push(`<tr><td>${label}</td><td>${isFinite(price)?price.toFixed(6):"—"}</td><td>${isFinite(gets)?gets.toFixed(2):"—"}</td></tr>`);
        }
      }
    } catch (e){
      rows.push(`<tr><td>${label}</td><td>Error</td><td>${(e && e.message) || e}</td></tr>`);
    }
    return rows.join("");
  }
  const asks = await side(XRBC, { currency: "XRP" }, "Ask");
  const bids = await side({ currency: "XRP" }, XRBC, "Bid");
  return `
    <div style="overflow:auto">
      <table class="table">
        <thead><tr><th>Side</th><th>Price (XRP/XRBC)</th><th>Amount</th></tr></thead>
        <tbody>${asks}${bids}</tbody>
      </table>
    </div>
  `;
}

async function refreshLedger(){
  try {
    const sum = await getLedgerSummary();
    if (ledgerOut) ledgerOut.textContent = JSON.stringify(sum, null, 2);
  } catch (e) {
    if (ledgerOut) ledgerOut.textContent = "Error fetching ledger: " + (e?.message || e);
  }
}
async function refreshOrderBook(){
  try {
    const html = await getOrderBookHtml();
    if (bookOut) bookOut.innerHTML = html;
  } catch (e) {
    if (bookOut) bookOut.textContent = "Order book error: " + (e?.message || e);
  }
}

// In-flight guard
let _refreshing = false;
async function refreshAll(){
  if (_refreshing) return;
  _refreshing = true;
  try {
    await Promise.allSettled([ refreshOrderBook(), refreshLedger() ]);
  } finally {
    _refreshing = false;
  }
}

// First paint + gentle auto-refresh
refreshAll().catch(()=>{});
document.addEventListener("visibilitychange", () => { if (!document.hidden) refreshAll().catch(()=>{}); });
window.addEventListener("focus", () => refreshAll().catch(()=>{}));
setInterval(() => { refreshAll().catch(()=>{}); }, 15000);
})(); // <-- END OF PAGE SCRIPT IIFE

<!-- ===== Footer · XRBC Ecosystem ===== -->
<footer class="site-footer" role="contentinfo" aria-label="XRBC ecosystem footer">
  <div class="container" style="padding:20px 0">
    <nav class="eco-links" aria-label="Project links">
      <ul style="list-style:none;display:flex;flex-wrap:wrap;gap:10px;justify-content:center;padding:0;margin:0">
        <li>
          <a class="eco-link btn" href="https://xrbitcoincash.com/XRBitcoin/" target="_blank" rel="noopener noreferrer">
            XRBitcoin (XRB)
          </a>
        </li>
        <li>
          <a class="eco-link btn" href="https://jesuschristsavestoken.com/" target="_blank" rel="noopener noreferrer">
            Jesus Christ Saves (JCS)
          </a>
        </li>

        <!-- TODO: Insert XRBC's official X (Twitter) profile URL and uncomment.
        <li>
          <a class="eco-link btn" href="https://x.com/REPLACE_WITH_XRBC" target="_blank" rel="noopener noreferrer" aria-label="Follow XRBC on X (Twitter)">
            Follow XRBC on X
          </a>
        </li>
        -->

      </ul>
    </nav>

    <div class="muted" style="text-align:center;margin-top:10px;font-size:.95rem;opacity:.9">
      Non-custodial. No secrets entered here. Always verify the domain <strong>xrbitcoincash.com</strong>.
    </div>
  </div>
</footer>
<!-- ===== /Footer ===== -->

 
