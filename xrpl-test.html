<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Safely trade XRBC ¬∑ XRBitcoinCash</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Canonical -->
  <link rel="canonical" href="https://xrbitcoincash.com/trade.html" />
  <link rel="alternate" hreflang="en" href="https://xrbitcoincash.com/trade.html" />

  <!-- Primary SEO -->
  <meta name="description" content="Safely trade XRBC on the XRP Ledger. Connect your Xaman (Xumm) wallet to place XRBC/XRP limit or market orders, read the order book, and view AMM pool info." />
  <meta name="keywords" content="XRBitcoinCash, XRBC, XRP Ledger, XRPL, Xaman, Xumm, DEX, AMM, crypto trading, trustline" />
  <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
  <meta name="theme-color" content="#0b0f14" />

  <!-- Favicons -->
  <link rel="icon" href="/xrbc-nft.png" type="image/png">
  <link rel="shortcut icon" href="/xrbc-nft.png" type="image/png">
  <link rel="apple-touch-icon" href="/xrbc-nft.png">
  <meta name="msapplication-TileImage" content="/xrbc-nft.png">
  <link rel="icon" href="/favicon.ico?v=1" sizes="any">
  <link rel="icon" type="image/png" href="/favicons/favicon-32.png?v=1" sizes="32x32">
  <link rel="icon" type="image/png" href="/favicons/favicon-16.png?v=1" sizes="16x16">
  <link rel="apple-touch-icon" href="/favicons/apple-touch-icon.png?v=1" sizes="180x180">
  <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg?v=1" color="#0b0f14">
  <meta name="msapplication-TileColor" content="#0b0f14">
  <link rel="manifest" href="/site.webmanifest?v=1">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:site_name" content="XRBitcoinCash">
  <meta property="og:title" content="Safely trade XRBC ¬∑ XRBitcoinCash">
  <meta property="og:description" content="Decentralized XRBC/XRP trading on the XRP Ledger with live order book and AMM price helper.">
  <meta property="og:url" content="https://xrbitcoincash.com/trade.html">
  <meta property="og:image" content="https://xrbitcoincash.com/xrbc-nft.png">
  <meta property="og:image:secure_url" content="https://xrbitcoincash.com/xrbc-nft.png">
  <meta property="og:image:alt" content="XRBitcoinCash ‚Äî XRBC/XRP trading page">

  <!-- Twitter / X -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Safely trade XRBC ¬∑ XRBitcoinCash">
  <meta name="twitter:description" content="Trade XRBC on XRPL. Connect your wallet, place orders, and view AMM pool info.">
  <meta name="twitter:image" content="https://xrbitcoincash.com/xrbc-nft.png">
  <meta name="twitter:image:alt" content="XRBitcoinCash ‚Äî XRBC/XRP trading page">

  <!-- JSON-LD -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebPage",
    "name": "Safely trade XRBC ¬∑ XRBitcoinCash",
    "url": "https://xrbitcoincash.com/trade.html",
    "description": "Safely trade XRBC on the XRP Ledger. Connect your Xaman (Xumm) wallet to place XRBC/XRP limit or market orders, read the order book, and view AMM pool info.",
    "isPartOf": {
      "@type": "WebSite",
      "name": "XRBitcoinCash",
      "url": "https://xrbitcoincash.com/"
    },
    "primaryImageOfPage": {
      "@type": "ImageObject",
      "url": "https://xrbitcoincash.com/xrbc-nft.png"
    },
    "about": {
      "@type": "Cryptocurrency",
      "name": "XRBitcoinCash (XRBC)",
      "alternateName": "XRBC",
      "additionalProperty": [
        { "@type": "PropertyValue", "name": "issuer", "value": "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw" },
        { "@type": "PropertyValue", "name": "currency_hex", "value": "5852626974636F696E6361736800000000000000" },
        { "@type": "PropertyValue", "name": "network", "value": "XRP Ledger (XRPL)" }
      ]
    },
    "potentialAction": [{ "@type": "BuyAction", "target": "https://xrbitcoincash.com/trade.html" }]
  }
  </script>

  <meta name="ai-readable" content="This page exposes structured data (JSON-LD) describing the XRBC trading interface on XRPL, including issuer and currency hex.">

  <!-- =========================
       XRBC ‚Äî Uniform Site CSS (v2, exchange-style DEX)
       ========================= -->
  <style>
/* =========================================
   XRBC ‚Äî Uniform Site CSS (v2, exchange-style DEX)
   (repaired: cleaned, glows restored, outlines unified)
   ========================================= */

/* ---------- 1) Tokens ---------- */
<style>
/* ===== XRBC drop-in overrides ===== */

/* Wider page: 85% on desktop, still responsive */
:root{
  --wrap: min(85vw, 1280px) !important;
  --wrap-wide: min(92vw, 1440px) !important;
}
.container, .header-wrap{ max-width: var(--wrap) !important; }

/* Live Metrics: tidy spacing on the header row */
#xrbcDexHero .lm-header{
  display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap
}

/* Order Book: fit inside card, single inner scroll if needed */
#priceOutput{
  max-height: 360px;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
#priceOutput > div{
  /* neutralize any inner wrappers your JS may inject */
  max-height: none !important;
  overflow: visible !important;
}
#priceOutput .table{ width:100%; table-layout:fixed; }
#priceOutput .table th, 
#priceOutput .table td{
  word-break: break-word;
  white-space: nowrap;
}
@media (max-width: 720px){
  #priceOutput{ max-height: 300px; }
  #priceOutput .table th, #priceOutput .table td{ white-space: normal; }
}

/* Ledger block: wrap long lines nicely */
#ledgerOutput{
  white-space: pre-wrap !important;
  word-break: break-word !important;
}

/* QR popover: anchored to the LEFT of the Download button */
.wallet-actions{ position:relative; }
.qr-popover{
  position:absolute;
  right: 100%;           /* to the left of the button row */
  top: 50%;
  transform: translateY(-50%);
  margin-right:12px;
  min-width:220px; max-width:240px;
  padding:12px 12px 10px 12px;
  border-radius:12px;
  background:#ffffff; color:#0b0f14;
  border:1px solid #000;
  box-shadow:0 0 0 2px rgba(255,255,255,.9), 0 10px 30px rgba(0,0,0,.35);
  display:none; z-index:30;
}
.qr-popover.show{ display:block; }
.qr-popover .qr{ display:flex; align-items:center; justify-content:center; }
.qr-popover .label{ font-weight:800; font-size:12px; text-align:center; margin-top:8px; }

/* Close (X) on QR */
.qr-popover .qr-close{
  position:absolute;
  top:6px; right:6px;
  width:22px; height:22px;
  display:inline-flex; align-items:center; justify-content:center;
  border:1px solid #000; border-radius:6px;
  background:#fff; color:#000; font-weight:800; line-height:1;
  cursor:pointer;
}

/* On mobile: show QR below the button row for comfort */
@media (max-width: 720px){
  .qr-popover{
    position:absolute;
    left: 0; right: auto;
    top: calc(100% + 8px);
    transform: none;
    margin-right: 0;
  }
}
</style>

  </style>






</head>
<body>

  <!-- ===== Header ===== -->
  <header class="site-header">
    <div class="header-wrap">
      <div class="brand">
        <img src="/xrbc-nft.png" alt="XRBitcoinCash (XRBC) logo">
        <h1>XRBitcoinCash</h1>
      </div>

      <!-- Center pills (white glow for Ecosystem, black glow for White Paper) -->
      <nav class="header-center" role="navigation" aria-label="Primary">
        <div class="header-nav">
          <a class="nav-pill pill-ecosys" href="/xrbc-ecosystem.html" title="XRBC Ecosystem ¬∑ DEX/AMM">XRBC Ecosystem ¬∑ DEX/AMM</a>
          <a class="nav-pill pill-whitepaper" href="/whitepaper.html" title="XRBC White Paper">White Paper</a>
        </div>
      </nav>

      <!-- Theme toggle -->
      <div class="header-right">
        <button id="themeToggle" type="button" aria-pressed="false" aria-label="Toggle light/dark">Light/Dark</button>
      </div>
    </div>
  </header>

  <!-- ===== Main ===== -->
  <main class="container" style="max-width:800px;text-align:center;">

    <h1 style="margin:12px 0 8px; line-height:1.1; letter-spacing:.2px;">
      XRBC ¬∑ Decentralized Trading (XRPL via Xaman)
    </h1>

    <!-- DEX / xApp quick entries -->
    <div style="margin-top:12px">
      <div style="display:flex;align-items:center;gap:8px;
                  padding:8px 12px;border:1px solid #064e3b;border-left:4px solid #10b981;
                  border-radius:10px;background:linear-gradient(180deg,#052b1f,#073425);
                  color:#d1fae5;font-size:14px;font-weight:700;letter-spacing:.2px;margin-bottom:10px;justify-content:center">
        <span>Open in Xaman ‚Äî DEX & Swaps (mobile opens app ‚Ä¢ desktop shows QR)</span>
      </div>

      <a href="https://xumm.app/detect/xapp:xumm.dex" rel="noopener noreferrer"
         class="btn" style="width:100%;max-width:520px;margin:0 auto 10px;border-left:4px solid #10b981;">
        <img src="/xrbc-nft.png" alt="XRBC" width="20" height="20" style="display:inline-block;border-radius:4px" />
        <span>Open in Xaman ‚Äî Trade XRBC ‚Üî XRP (DEX)</span>
        <img src="https://xrbitcoincash.github.io/assetsxrp.svg.svg" alt="XRP" width="20" height="20" style="display:inline-block" />
      </a>

      <a href="https://xumm.app/detect/xapp:anodos.swap" rel="noopener noreferrer"
         class="btn" style="width:100%;max-width:520px;margin:0 auto 10px;border-left:4px solid #38bdf8;">
        <img src="/xrbc-nft.png" alt="XRBC" width="20" height="20" style="display:inline-block;border-radius:4px" />
        <span>Open in Xaman ‚Äî ANODOS Swap (XRBC ‚Üî XRP)</span>
        <img src="https://xrbitcoincash.github.io/assetsxrp.svg.svg" alt="XRP" width="20" height="20" style="display:inline-block" />
      </a>

      <a href="https://xumm.app/detect/xapp:magnetic.dex" rel="noopener noreferrer"
         class="btn" style="width:100%;max-width:520px;margin:0 auto 10px;border-left:4px solid #1e3a8a;">
        <img src="/xrbc-nft.png" alt="XRBC" width="20" height="20" style="display:inline-block;border-radius:4px" />
        <span>Open in Xaman ‚Äî Magnetic (XRBC ‚Üî XRP)</span>
        <img src="https://xrbitcoincash.github.io/assetsxrp.svg.svg" alt="XRP" width="20" height="20" style="display:inline-block" />
      </a>

      <div class="fine" style="margin-top:8px;color:#93a3af;font-size:12px;line-height:1.4;">
        Notes: Anodos and Magnetic open as xApps in Xaman. Pair deep-linking to XRBC/XRP isn‚Äôt publicly documented by providers; you may need to select the pair in-app.
        ‚ÄúXRP‚Äù and the XRP logo are trademarks of Ripple Labs, Inc. ‚ÄúXaman (Xumm)‚Äù is a product of XRPL Labs. No affiliation or endorsement implied.
      </div>
    </div>

<!-- Wallet card -->
<div class="card wallet-card" style="margin:16px 0 20px;">
  <h2 class="wallet-title">
    <img src="/xrbc-nft.png" alt="XRBC logo">
    <span>Connect wallet to the XRBC decentralized exchange</span>
  </h2>

  <div class="wallet-actions" style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin:10px 0 12px;">
    <button id="downloadXamanBtn" class="btn glow glow-white" style="border-left:4px solid #2563eb;">
      Download Xaman
    </button>

    <button id="setTrustlineBtn" class="btn glow glow-yellow">
      Set XRBC Trustline
    </button>

    <!-- changed to green glow -->
    <button id="connectWalletBtn" class="btn glow glow-green">
      Connect Wallet
    </button>

    <button id="disconnectWalletBtn" class="btn glow glow-red" disabled>
      Disconnect
    </button>
  </div>

  <p id="walletStatus" class="status-text">Status: Not connected</p>
  <div id="trustlineMsg" class="status-text" style="margin-top:8px;"></div>
</div>

<!-- ‚ñº Add this right after the Download button -->
<div id="dlPopover" class="qr-popover" role="dialog" aria-label="Download Xaman QR" aria-hidden="true">
  <div class="qr">
    <img id="dlQr" alt="Scan to download Xaman" width="180" height="180" decoding="async" loading="eager">
  </div>
  <div class="label">Scan to download Xaman</div>
</div>



    <!-- ===== Trading UI (exchange style) ===== -->
    <section class="trade-card" id="tradeCard" aria-label="XRBC Trading">

    <!-- Tiny pair badge (chips) -->
<div class="trade-logo" style="gap:10px;">
  <span class="asset-chip asset-xrbc">
    <img src="/xrbc-nft.png" alt="XRBC"> XRBC
  </span>
  <span class="nowrap">/</span>
  <span class="asset-chip asset-xrp">
    <img src="https://xrbitcoincash.github.io/assetsxrp.svg.svg" alt="XRP"> XRP
  </span>
</div>


<div class="otype-tabs" role="tablist" aria-label="Order type">
  <button class="otype otype-limit glow glow-yellow active" data-type="limit"  role="tab" aria-selected="true">Limit (Advanced)</button>
  <button class="otype otype-market glow glow-green"        data-type="market" role="tab" aria-selected="false">Market (Beginner)</button>
</div>

<!-- NEW: concise explanation that ‚Äúsurrounds‚Äù the mode with detail -->
<div class="otype-notes" id="otypeNotes" aria-live="polite">
  <div data-note="limit">
    <span class="note-tag tag-advanced">Advanced</span>
    <strong>Limit:</strong> Place an order at <em>your</em> price. It only executes if the market reaches that price. Nothing is sent until you tap <strong>Place Limit Order</strong> and sign in Xaman.
  </div>
  <div data-note="market" hidden>
    <span class="note-tag tag-beginner">Beginner</span>
    <strong>Market:</strong> Quick & easy. Executes now at the best available price (uses <span class="mono">IOC</span>). You‚Äôll still review and sign in Xaman.
  </div>
</div>



      
      
    

<!-- ===== BUY/SELL ===== -->
<div class="tabset" role="tablist" aria-label="Choose buy or sell">
  <button id="buyTab" class="tab buy active" type="button" role="tab" aria-selected="true">Buy XRBC</button>
  <button id="sellTab" class="tab sell" type="button" role="tab" aria-selected="false">Sell XRBC</button>
</div>

<!-- Explanation under the Buy/Sell buttons (chips, text-sized icons) -->
<div class="side-explain" id="sideExplain" aria-live="polite" style="margin-top:6px">
  <div class="note buy active" data-side="buy">
    <span class="copy">
      <strong>Buying XRBC:</strong>
      You‚Äôre trading
      <span class="asset-chip asset-xrp">
        <img src="https://xrbitcoincash.github.io/assetsxrp.svg.svg" alt="XRP" style="height:1.05em;width:auto;vertical-align:-.2em;background:#fff;border-radius:3px;padding:1px"> XRP
      </span>
      to receive
      <span class="asset-chip asset-xrbc">
        <img src="/xrbc-nft.png" alt="XRBC" style="height:1.05em;width:auto;vertical-align:-.2em;border-radius:3px"> XRBC
      </span>.
    </span>
  </div>

  <div class="note sell" data-side="sell" hidden>
    <span class="copy">
      <strong>Selling XRBC:</strong>
      You‚Äôre trading
      <span class="asset-chip asset-xrbc">
        <img src="/xrbc-nft.png" alt="XRBC" style="height:1.05em;width:auto;vertical-align:-.2em;border-radius:3px"> XRBC
      </span>
      to receive
      <span class="asset-chip asset-xrp">
        <img src="https://xrbitcoincash.github.io/assetsxrp.svg.svg" alt="XRP" style="height:1.05em;width:auto;vertical-align:-.2em;background:#fff;border-radius:3px;padding:1px"> XRP
      </span>.
    </span>
  </div>
</div>

<!-- ===== AMOUNT ===== -->
<div class="field" style="margin-top:8px">
  <label for="amount" id="amountLabel">Amount (XRBC)</label>
  <div class="amount-row">
    <img src="/xrbc-nft.png" alt="XRBC logo">
    <input id="amount" type="number" step="0.000001" inputmode="decimal" placeholder="0.000000">
  </div>

  <!-- % chips (now wallet-aware) -->
  <div class="quick-amounts" role="group" aria-label="Quick amount">
    <button class="qa" data-q="25">25%</button>
    <button class="qa" data-q="50">50%</button>
    <button class="qa" data-q="75">75%</button>
    <button class="qa" data-q="100">100%</button>
  </div>

  <!-- Dynamic explainer for the amount input -->
  <div class="inline-hint" id="amountHint" style="margin-top:6px">
    How many XRBC you want to <span id="actionWord">buy</span>.
    <span class="nowrap">You‚Äôre trading
      <span class="asset-chip asset-xrp">
        <img src="https://xrbitcoincash.github.io/assetsxrp.svg.svg" alt="XRP" style="height:1.05em;width:auto;vertical-align:-.2em;background:#fff;border-radius:3px;padding:1px"> XRP
      </span>
      to receive
      <span class="asset-chip asset-xrbc">
        <img src="/xrbc-nft.png" alt="XRBC" style="height:1.05em;width:auto;vertical-align:-.2em;border-radius:3px"> XRBC
      </span>.
    </span>
  </div>
</div>

<!-- ===== Best Price (moved BELOW Amount) ===== -->
<div class="best-price-strip" style="margin-top:10px">
  <button class="btn best-price-btn" id="suggestPriceBtn" type="button">Best Price (AMM)</button>
  <div class="hint">Auto-updates every 10s after you enter an <strong>Amount</strong>.</div>
</div>

<!-- ===== PRICE (hidden for Market) ===== -->
<div class="field" id="priceField">
  <label for="price">Price (XRP per XRBC)</label>
  <input id="price" type="number" step="0.000001" inputmode="decimal" placeholder="e.g., 0.500000">
  <div class="inline-hint">Limit price. (Use Market to execute immediately.)</div>
</div>



<!-- ===== TOTAL ===== -->
<div class="total-line" aria-live="polite">
  <span>Total</span>
  <strong id="totalXrp">0.000000 XRP</strong>
</div>

      <!-- Submit -->
      <div class="button-row">
        <button id="placeOfferBtn" class="btn btn-primary" type="button">Place Order</button>
        <div class="refresh-indicator" aria-hidden="true">
          <div class="clock"></div>
          <span class="refresh-text">Auto-refresh every 10s</span>
        </div>
      </div>

      <p id="tradeMsg" class="status-text">‚Äî</p>

      <select id="side" hidden>
        <option value="buy" selected>Buy</option>
        <option value="sell">Sell</option>
      </select>
      <input id="orderType" type="hidden" value="limit">
    </section>

<<!-- ===== XRBC DEX ‚Äî Live Metrics ===== -->
<section class="card" id="xrbcDexHero" aria-label="XRBC DEX ‚Äî Live Metrics" style="margin:20px 0 24px;">
  <div class="lm-header">
    <h2 style="margin:0;display:flex;align-items:center;gap:10px">
      <img src="/xrbc-nft.png" alt="XRBC" width="24" height="24" style="border-radius:6px;border:1px solid var(--line)">
      XRBC DEX ‚Äî Live Metrics
    </h2>
  </div>

  <!-- Panels -->
  <div style="display:grid;gap:16px;margin-top:6px">
    <div>
      <h3 style="margin:0 0 6px">XRBC/XRP Order Book (top 5)</h3>
      <div id="priceOutput">‚Äî</div>
    </div>
    <div>
      <h3 style="margin:6px 0">Ledger (validated)</h3>
      <pre id="ledgerOutput" style="text-align:left;margin:0">‚Äî</pre>
    </div>
  </div>
</section>




 

  <!-- Order book + Ledger (no inner scrolls; use page scroll only) -->
  <div style="display:grid;gap:16px;margin-top:6px">
    <div>
      <h3 style="margin:0 0 6px">XRBC/XRP Order Book (top 5)</h3>
      <div id="priceOutput">‚Äî</div>
    </div>
    <div>
      <h3 style="margin:6px 0">Ledger (validated)</h3>
      <pre id="ledgerOutput" style="text-align:left;margin:0">‚Äî</pre>
    </div>
  </div>
</section>


    
    <script>
(function () {
  // ---- CONFIG & CONSTANTS ---------------------------------------------------
  const cfgEl = document.getElementById("app-config");
  if (!cfgEl) { console.error("[XRBC Metrics] Missing #app-config"); return; }
  const cfg = JSON.parse(cfgEl.textContent || "{}");
  const PROXY_URL = cfg.proxyUrl;
  const XRP_TO_DROPS = 1_000_000;

  // XRBC issued token (hex currency code + issuer)
  const XRBC = {
    currency: "5852626974636F696E6361736800000000000000",
    issuer:   "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw"
  };

  // ---- DOM ------------------------------------------------------------------
  const $ = (id) => document.getElementById(id);
  const statusEl  = $("dexStatus");
  const priceEl   = $("kpiPrice");
  const spreadEl  = $("kpiSpread");
  const topBookEl = $("kpiTopOfBook");
  const reservesEl= $("kpiReserves");
  const feeEl     = $("kpiFee");
  const ledgerOut = $("ledgerOutput");
  const bookOut   = $("priceOutput");

  const btnRefresh   = $("dexRefreshBtn");
  const btnBook      = $("dexShowOrderBookBtn");
  const btnLedger    = $("dexShowLedgerBtn");

  // Make legacy panes use page scroll (single scrollbar)
  if (ledgerOut) { ledgerOut.style.maxHeight = ""; ledgerOut.style.overflow = ""; }
  if (bookOut)   { bookOut.style.maxHeight   = ""; bookOut.style.overflow   = ""; }

  // ---- HELPERS --------------------------------------------------------------
  function setStatus(kind, msg) {
    if (!statusEl) return;
    statusEl.textContent = msg;
    statusEl.classList.remove("ok","err","connecting");
    statusEl.classList.add(kind); // "ok" | "err" | "connecting"
  }

  async function xrpl(payload) {
    const res = await fetch(PROXY_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    if (!res.ok) throw new Error("Proxy HTTP " + res.status);
    const data = await res.json();
    if (data && data.error) throw new Error("XRPL: " + JSON.stringify(data.error));
    return data;
  }

  // Price from a single offer
  function priceFromOffer(of) {
    if (!of) return null;
    const gets = of.TakerGets?.value ? parseFloat(of.TakerGets.value)
                                     : parseFloat(of.TakerGets) / XRP_TO_DROPS;
    const pays = of.TakerPays?.value ? parseFloat(of.TakerPays.value)
                                     : parseFloat(of.TakerPays) / XRP_TO_DROPS;
    if (!isFinite(gets) || gets <= 0 || !isFinite(pays)) return null;
    return pays / gets; // XRP per XRBC
  }

  // ---- DATA FETCHERS --------------------------------------------------------
  async function getTopOfBook() {
    // best ask: offers selling XRBC for XRP ‚Üí taker_gets XRBC, taker_pays XRP
    const askReq = xrpl({
      method: "book_offers",
      params: [{ taker_gets: XRBC, taker_pays: { currency: "XRP" }, limit: 1 }]
    });
    // best bid: offers buying XRBC paying XRP ‚Üí taker_gets XRP, taker_pays XRBC
    const bidReq = xrpl({
      method: "book_offers",
      params: [{ taker_gets: { currency: "XRP" }, taker_pays: XRBC, limit: 1 }]
    });

    const [askRes, bidRes] = await Promise.all([askReq, bidReq]);
    const bestAsk = priceFromOffer(askRes?.result?.offers?.[0]);
    const bestBid = priceFromOffer(bidRes?.result?.offers?.[0]);

    return { bestAsk, bestBid };
  }

  async function getAmmMini() {
    const res = await xrpl({
      method: "amm_info",
      params: [{ asset: { currency: "XRP" }, asset2: { currency: XRBC.currency, issuer: XRBC.issuer } }]
    });
    const amm = res?.result?.amm || null;
    if (!amm) return { reserveXrp: null, reserveXrbc: null, feePct: null };

    const reserveXrp  = parseFloat(amm.amount) / XRP_TO_DROPS;
    const reserveXrbc = parseFloat(amm.amount2?.value || 0);
    const feePct      = (amm.trading_fee / 10000); // docs: millionths ‚Üí percentage
    return { reserveXrp, reserveXrbc, feePct };
  }

  async function getLedgerSummary() {
    const res = await xrpl({ method: "ledger", params: [{ ledger_index: "validated" }] });
    const r = res?.result || {};
    const idx   = r.ledger_index || r.validated_ledger_index || r.ledger?.ledger_index;
    const hash  = r.ledger_hash  || r.ledger?.ledger_hash;
    const close = r.ledger?.close_time_human || r.closed?.close_time_human;
    return {
      ledger_index: idx ?? "(unknown)",
      ledger_hash : hash ?? "(unknown)",
      close_time  : close || "(not expanded)",
      validated   : r.validated === undefined ? true : !!r.validated
    };
  }

  async function getOrderBookHtml() {
    async function side(taker_gets, taker_pays, sideName) {
      try {
        const res = await xrpl({
          method: "book_offers",
          params: [{ taker_gets, taker_pays, limit: 5 }]
        });
        const rows = (res?.result?.offers || []).map(of => {
          const gets = of.TakerGets?.value ? parseFloat(of.TakerGets.value)
                                           : parseFloat(of.TakerGets) / XRP_TO_DROPS;
          const pays = of.TakerPays?.value ? parseFloat(of.TakerPays.value)
                                           : parseFloat(of.TakerPays) / XRP_TO_DROPS;
          const price = (isFinite(gets) && gets > 0) ? (pays / gets) : NaN;
          return `<tr><td>${sideName}</td><td>${isFinite(price)?price.toFixed(6):"‚Äî"}</td><td>${isFinite(gets)?gets.toFixed(2):"‚Äî"}</td></tr>`;
        });
        return rows.length ? rows.join("") : `<tr><td>${sideName}</td><td>No offers</td><td>-</td></tr>`;
      } catch (e) {
        return `<tr><td>${sideName}</td><td>Error</td><td>${e?.message || e}</td></tr>`;
      }
    }
    const asks = await side(XRBC, { currency: "XRP" }, "Ask");
    const bids = await side({ currency: "XRP" }, XRBC, "Bid");
    return `
      <div style="overflow:auto">
        <table class="table">
          <thead><tr><th>Side</th><th>Price (XRP/XRBC)</th><th>Amount</th></tr></thead>
          <tbody>${asks}${bids}</tbody>
        </table>
      </div>
    `;
  }

  // ---- RENDERERS ------------------------------------------------------------
  function renderTopOfBook({ bestAsk, bestBid }) {
    if (bestAsk && bestBid) {
      const mid = (bestAsk + bestBid) / 2;
      if (priceEl)  priceEl.textContent  = mid.toFixed(6);
      if (spreadEl) spreadEl.textContent = (bestAsk - bestBid).toFixed(6);
      if (topBookEl) topBookEl.textContent = `Bid: ${bestBid.toFixed(6)} ¬∑ Ask: ${bestAsk.toFixed(6)}`;
    } else {
      if (priceEl)  priceEl.textContent  = "‚Äî";
      if (spreadEl) spreadEl.textContent = "‚Äî";
      if (topBookEl) topBookEl.textContent = "Bid: ‚Äî ¬∑ Ask: ‚Äî";
    }
  }

  function renderAmm({ reserveXrp, reserveXrbc, feePct }) {
    if (reservesEl) reservesEl.textContent =
      (reserveXrp != null && reserveXrbc != null) ? `${reserveXrp.toFixed(6)} XRP ¬∑ ${reserveXrbc.toFixed(6)} XRBC` : "‚Äî";
    if (feeEl) feeEl.textContent =
      (feePct != null) ? `Fee: ${feePct.toFixed(2)}%` : "Fee: ‚Äî";
  }

  // ---- REFRESH ORCHESTRATION ------------------------------------------------
  let refreshing = false;
  async function refreshAll(includeLedger = true) {
    if (refreshing) return;
    refreshing = true;
    setStatus("connecting", "Refreshing live metrics‚Ä¶");

    try {
      const jobs = [
        getTopOfBook().then(renderTopOfBook),
        getAmmMini().then(renderAmm),
      ];
      if (includeLedger) {
        jobs.push(getLedgerSummary().then(sum => {
          if (ledgerOut) ledgerOut.textContent = JSON.stringify(sum, null, 2);
        }));
      }
      await Promise.all(jobs);

      // Always update the order book snapshot if present
      if (bookOut) {
        try {
          const html = await getOrderBookHtml();
          bookOut.innerHTML = html;
        } catch (e) {
          bookOut.textContent = "Order book error: " + (e?.message || e);
        }
      }

      setStatus("ok", "Metrics updated.");
    } catch (e) {
      setStatus("err", "Refresh failed: " + (e?.message || e));
    } finally {
      refreshing = false;
    }
  }

  // ---- BUTTONS & AUTO -------------------------------------------------------
  if (btnRefresh) btnRefresh.addEventListener("click", () => refreshAll(true));
  if (btnBook)    btnBook.addEventListener("click",  async () => {
    setStatus("connecting", "Updating order book‚Ä¶");
    try {
      const html = await getOrderBookHtml();
      if (bookOut) bookOut.innerHTML = html;
      setStatus("ok", "Order book updated.");
    } catch (e) {
      setStatus("err", "Order book failed: " + (e?.message || e));
    }
  });
  if (btnLedger)  btnLedger.addEventListener("click", async () => {
    setStatus("connecting", "Fetching ledger‚Ä¶");
    try {
      const sum = await getLedgerSummary();
      if (ledgerOut) ledgerOut.textContent = JSON.stringify(sum, null, 2);
      setStatus("ok", "Ledger updated.");
    } catch (e) {
      setStatus("err", "Ledger failed: " + (e?.message || e));
    }
  });

  // Auto refresh gently every 15s (won't overlap; respects proxy)
  const INTERVAL_MS = 15000;
  setInterval(() => { refreshAll(false).catch(()=>{}); }, INTERVAL_MS);

  // First paint
  refreshAll(true).catch(()=>{});
})();
</script>

    
    
    <!-- Config -->
  <script type="application/json" id="app-config">
  {
    "xummApiKey": "2abde023-0df1-49a2-a4dc-86d776f6318d",
    "proxyUrl": "https://xrbitcoincash-github-io.onrender.com"
  }
  </script>

  <!-- Xaman SDK -->
  <script src="https://xaman.app/assets/cdn/xumm.min.js"></script>

  
  
<script>
(function(){
  /* ========= Helpers: modal + QR ========= */
  const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

  function openMobileModal({ title, html, url }){
    const modal = document.getElementById('mobileModal');
    const modalTitle = document.getElementById('modalTitle');
    const modalIntro = document.getElementById('modalIntro');
    const pageQr = document.getElementById('pageQr');
    const pageUrlCopy = document.getElementById('pageUrlCopy');
    if (!modal || !modalTitle || !modalIntro || !pageQr) return;

    modalTitle.textContent = title || 'Open on Mobile';
    modalIntro.innerHTML = html || '';

    // Render a tiny PNG QR for the given URL
    pageQr.innerHTML = '';
    if (url){
      const img = new Image();
      img.alt = 'Scan with your phone';
      img.style.maxWidth = '240px';
      img.style.height = 'auto';
      img.decoding = 'async';
      img.loading = 'eager';
      img.src = 'https://api.qrserver.com/v1/create-qr-code/?size=240x240&data=' + encodeURIComponent(url);
      img.onerror = () => { pageQr.textContent = 'QR failed to load'; };
      pageQr.appendChild(img);
      if (pageUrlCopy) pageUrlCopy.textContent = url;
    }

    modal.classList.add('open');
    modal.setAttribute('aria-hidden','false');
  }
  function closeMobileModal(){
    const modal = document.getElementById('mobileModal');
    if (!modal) return;
    modal.classList.remove('open');
    modal.setAttribute('aria-hidden','true');
  }
  document.addEventListener('DOMContentLoaded', () => {
    const closeModalBtn = document.getElementById('closeModalBtn');
    const modal = document.getElementById('mobileModal');
    if (closeModalBtn) closeModalBtn.addEventListener('click', closeMobileModal);
    if (modal && modal.querySelector('.backdrop')) modal.querySelector('.backdrop').addEventListener('click', closeMobileModal);
  });

  /* ========= App config / constants ========= */
  const cfgNode = document.getElementById("app-config");
  if (!cfgNode) { console.error("Missing #app-config"); return; }
  const cfg = JSON.parse(cfgNode.textContent);
  const PROXY_URL = cfg.proxyUrl;
  const XRP_TO_DROPS = 1_000_000;

  const XRBC = {
    currency: "5852626974636F696E6361736800000000000000",
    issuer: "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw"
  };

  async function xrplRequest(payload) {
    const res = await fetch(PROXY_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    if (!res.ok) throw new Error("Proxy error: " + res.status);
    const data = await res.json();
    if (data.error) throw new Error("XRPL error: " + JSON.stringify(data.error));
    return data;
  }
  const toDrops = (xrp) => Math.round(Number(xrp) * XRP_TO_DROPS).toString();

  /* ========= Theme toggle ========= */
  (function themeInit(){
    const btn = document.getElementById('themeToggle');
    const saved = localStorage.getItem('xrbc-theme');
    if (saved === 'light') document.body.classList.add('light-mode');
    if (btn) {
      const sync = () => btn.setAttribute('aria-pressed', document.body.classList.contains('light-mode') ? 'true' : 'false');
      sync();
      btn.addEventListener('click', () => {
        document.body.classList.toggle('light-mode');
        const mode = document.body.classList.contains('light-mode') ? 'light' : 'dark';
        localStorage.setItem('xrbc-theme', mode);
        sync();
      });
    }
  })();

  /* ========= Xaman SDK: connect / disconnect / trustline ========= */
  // Fix: don't exit the whole script if Xumm isn't ready yet.
  let xumm = null;
  if (typeof Xumm !== 'undefined') {
    xumm = new Xumm(cfg.xummApiKey);
    const connectBtn   = document.getElementById("connectWalletBtn");
    const disconnectBtn= document.getElementById("disconnectWalletBtn");
    const statusEl     = document.getElementById("walletStatus");
    const trustlineMsg = document.getElementById("trustlineMsg");

    function setConnectedUI(acct) {
      if (statusEl) statusEl.textContent = "Connected: " + acct;
      window.__xrbcWallet = acct;
      localStorage.setItem("xrbcWallet", acct);
      if (disconnectBtn) disconnectBtn.disabled = false;
      if (connectBtn) connectBtn.disabled = true;
    }
    function setDisconnectedUI() {
      if (statusEl) statusEl.textContent = "Status: Not connected";
      window.__xrbcWallet = null;
      localStorage.removeItem("xrbcWallet");
      if (disconnectBtn) disconnectBtn.disabled = true;
      if (connectBtn) connectBtn.disabled = false;
    }
    async function refreshWalletStatus() {
      try {
        const acct = await xumm.user.account;
        if (acct) setConnectedUI(acct);
      } catch {}
    }

    // Restore prior session
    const savedAcct = localStorage.getItem("xrbcWallet");
    if (savedAcct) setConnectedUI(savedAcct);

    xumm.on("ready", async () => {
      if (connectBtn) connectBtn.disabled = !!window.__xrbcWallet;
      await refreshWalletStatus();
      if (connectBtn && !window.__xrbcWallet) connectBtn.disabled = false;
    });

    window.addEventListener("visibilitychange", () => { if (!document.hidden) refreshWalletStatus(); });
    window.addEventListener("focus", refreshWalletStatus);

    // CONNECT
    if (connectBtn) connectBtn.addEventListener("click", async () => {
      try {
        if (statusEl) statusEl.textContent = "Waiting for Xaman‚Ä¶ (scan QR if shown)";
        await xumm.authorize(); // desktop ‚Üí QR, mobile ‚Üí app
        const acct = await xumm.user.account;
        if (acct) setConnectedUI(acct);
        else if (statusEl) statusEl.textContent = "Still waiting for Xaman‚Ä¶";
      } catch {
        if (statusEl) statusEl.textContent = "Failed to connect wallet";
      }
    });

    // DISCONNECT
    if (disconnectBtn) disconnectBtn.addEventListener("click", () => {
      setDisconnectedUI();
      xumm.logout();
    });

    // TRUSTLINE
    const setTrustBtn = document.getElementById("setTrustlineBtn");
    if (setTrustBtn) setTrustBtn.addEventListener("click", async () => {
      if (trustlineMsg) trustlineMsg.textContent = "Preparing trustline request‚Ä¶";
      try {
        const acct = window.__xrbcWallet;
        const txjson = {
          TransactionType: "TrustSet",
          LimitAmount: { currency: XRBC.currency, issuer: XRBC.issuer, value: "1000000" }
        };
        if (acct) txjson.Account = acct;

        const { created, resolved } = await xumm.payload.createAndSubscribe({ txjson }, (ev) => {
          if (ev?.opened && trustlineMsg) trustlineMsg.textContent = "Open Xaman (or scan QR) to review‚Ä¶";
          if (ev?.signed === false && trustlineMsg) trustlineMsg.textContent = "Trustline rejected.";
        });

        if (created?.refs?.qr_png && trustlineMsg) {
          const qr = document.createElement("img");
          qr.src = created.refs.qr_png;
          qr.alt = "Scan with Xaman to set XRBC trustline";
          qr.style.maxWidth = "240px";
          qr.style.marginTop = "12px";
          trustlineMsg.innerHTML = "Scan to sign trustline:<br/>";
          trustlineMsg.appendChild(qr);
        }

        const result = await resolved;
        if (!result.signed) { if (trustlineMsg) trustlineMsg.textContent = "Trustline not signed."; return; }
        if (trustlineMsg) trustlineMsg.textContent = "‚úÖ Trustline set successfully!";
      } catch (err) {
        if (trustlineMsg) trustlineMsg.textContent = "Error: " + err.message;
      }
    });
  } else {
    console.warn("Xumm SDK not loaded yet ‚Äî continuing without wallet UI.");
  }

  /* ========= Ledger, Order Book, Trading UI ========= */
  async function getLedgerInfo() {
    return await xrplRequest({ method: "ledger", params: [{ ledger_index: "validated" }] });
  }
  async function getXrbcOrderBook() {
    async function fetchSide(taker_gets, taker_pays, sideName) {
      const rows = [];
      try {
        const data = await xrplRequest({
          method: "book_offers",
          params: [{ taker_gets, taker_pays, limit: 5 }]
        });
        if (data.result?.offers?.length) {
          for (const offer of data.result.offers) {
            const gets = offer.TakerGets?.value
              ? parseFloat(offer.TakerGets.value)
              : parseFloat(offer.TakerGets) / XRP_TO_DROPS;
            const pays = offer.TakerPays?.value
              ? parseFloat(offer.TakerPays.value)
              : parseFloat(offer.TakerPays) / XRP_TO_DROPS;
            const price = pays / gets;
            rows.push(`<tr><td>${sideName}</td><td>${price.toFixed(6)}</td><td>${gets.toFixed(2)}</td></tr>`);
          }
        } else {
          rows.push(`<tr><td>${sideName}</td><td>No offers</td><td>-</td></tr>`);
        }
      } catch (err) {
        rows.push(`<tr><td>${sideName}</td><td>Error</td><td>${(err && err.message) || err}</td></tr>`);
      }
      return rows;
    }
    const asks = await fetchSide(XRBC, { currency: "XRP" }, "Ask");
    const bids = await fetchSide({ currency: "XRP" }, XRBC, "Bid");
    return `
      <div style="max-height:340px;overflow:auto;">
        <table class="table">
          <thead><tr><th>Side</th><th>Price (XRP/XRBC)</th><th>Amount</th></tr></thead>
          <tbody>${asks.join("")}${bids.join("")}</tbody>
        </table>
      </div>
    `;
  }

  // Trading UI wires (robust to duplicate markup)
  const placeOfferBtn = document.getElementById("placeOfferBtn");
  const sideEl   = document.getElementById("side");
  const amountEl = document.getElementById("amount");
  const priceEl  = document.getElementById("price");
  const tradeMsg = document.getElementById("tradeMsg");
  const totalXrpEl  = document.getElementById("totalXrp");
  const suggestBtn  = document.getElementById("suggestPriceBtn");
  const orderTypeEl = document.getElementById("orderType");
  const priceField  = document.getElementById("priceField");
  const tradeCard   = document.getElementById("tradeCard");

  const buyTabs  = Array.from(document.querySelectorAll('#buyTab'));
  const sellTabs = Array.from(document.querySelectorAll('#sellTab'));
  const sideExplainWraps = Array.from(document.querySelectorAll('[id="sideExplain"]'));
  const actionWordEls = Array.from(document.querySelectorAll('[id="actionWord"]'));

  function updateOneExplainer(wrap, side){
    if (!wrap) return;
    const buyNote  = wrap.querySelector('.note.buy');
    const sellNote = wrap.querySelector('.note.sell');
    const showBuy = (side === 'buy');
    if (buyNote){
      buyNote.hidden = !showBuy;
      buyNote.classList.toggle('active', showBuy);
      buyNote.setAttribute('aria-hidden', (!showBuy).toString());
    }
    if (sellNote){
      sellNote.hidden = showBuy;
      sellNote.classList.toggle('active', !showBuy);
      sellNote.setAttribute('aria-hidden', (showBuy).toString());
    }
    wrap.querySelectorAll('.asset-xrp img').forEach(img => {
      img.style.background = '#fff';
      img.style.borderRadius = '3px';
    });
  }

  function updateAmountHint(side){
    const hint = document.getElementById('amountHint');
    const label = document.getElementById('amountLabel');
    if (!hint) return;

    if (side === 'buy'){
      if (label) label.textContent = 'Amount (XRBC)';
      hint.innerHTML =
        `How many XRBC you want to <span id="actionWord">buy</span>. ` +
        `<span class="nowrap">You‚Äôre trading ` +
        `<span class="asset-chip asset-xrp"><img src="https://xrbitcoincash.github.io/assetsxrp.svg.svg" alt="XRP" style="height:1.05em;width:auto;vertical-align:-.2em;background:#fff;border-radius:3px;padding:1px"> XRP</span> ` +
        `to receive <span class="asset-chip asset-xrbc"><img src="/xrbc-nft.png" alt="XRBC" style="height:1.05em;width:auto;vertical-align:-.2em;border-radius:3px"> XRBC</span>.</span>`;
    } else {
      if (label) label.textContent = 'Amount (XRBC)';
      hint.innerHTML =
        `How many XRBC you want to <span id="actionWord">sell</span>. ` +
        `<span class="nowrap">You‚Äôre trading ` +
        `<span class="asset-chip asset-xrbc"><img src="/xrbc-nft.png" alt="XRBC" style="height:1.05em;width-auto;vertical-align:-.2em;border-radius:3px"> XRBC</span> ` +
        `to receive <span class="asset-chip asset-xrp"><img src="https://xrbitcoincash.github.io/assetsxrp.svg.svg" alt="XRP" style="height:1.05em;width:auto;vertical-align:-.2em;background:#fff;border-radius:3px;padding:1px"> XRP</span>.</span>`;
    }
  }

  function setSide(side) {
    if (sideEl) sideEl.value = side;

    buyTabs.forEach(btn => {
      btn.classList.toggle("active", side === 'buy');
      btn.setAttribute('aria-selected', side === 'buy' ? 'true' : 'false');
    });
    sellTabs.forEach(btn => {
      btn.classList.toggle("active", side === 'sell');
      btn.setAttribute('aria-selected', side === 'sell' ? 'true' : 'false');
    });

    sideExplainWraps.forEach(wrap => updateOneExplainer(wrap, side));
    actionWordEls.forEach(el => { el.textContent = (side === 'buy' ? 'buy' : 'sell'); });

    if (tradeCard){
      tradeCard.classList.toggle('buy',  side === 'buy');
      tradeCard.classList.toggle('sell', side === 'sell');
    }

    updateAmountHint(side);
    recalcTotals();
  }

  function recalcTotals() {
    if (!totalXrpEl) return;
    const amt = Number(amountEl?.value) || 0;
    const px  = Number(priceEl?.value)  || 0;
    const total = (px || 0) * amt;
    totalXrpEl.textContent = (isFinite(total) ? total : 0).toFixed(6) + " XRP";
  }
  if (amountEl) amountEl.addEventListener("input", recalcTotals);
  if (priceEl)  priceEl.addEventListener("input", recalcTotals);

  /* === Wallet-aware balances + dynamic hint for % chips === */
  const BAL = { xrp: 0, xrbc: 0 };
  const RESERVE_BUFFER_XRP = 1.0; // cushion

  const normalizeHexCurrency = (s) => (s || '').toUpperCase().replace(/0+$/,'');
  const XRBC_HEX_NORM = normalizeHexCurrency(XRBC.currency);

  async function fetchBalances(){
    const acct = window.__xrbcWallet;
    if (!acct) { BAL.xrp = 0; BAL.xrbc = 0; return BAL; }

    try {
      const info = await xrplRequest({
        method: "account_info",
        params: [{ account: acct, ledger_index: "validated" }]
      });
      BAL.xrp = Number(info?.result?.account_data?.Balance || 0) / XRP_TO_DROPS;
    } catch { BAL.xrp = 0; }

    try {
      const lines = await xrplRequest({
        method: "account_lines",
        params: [{ account: acct, peer: XRBC.issuer, ledger_index: "validated" }]
      });
      const tl = (lines?.result?.lines || []).find(l =>
        normalizeHexCurrency(l.currency) === XRBC_HEX_NORM
      );
      BAL.xrbc = tl ? Math.max(0, Number(tl.balance || 0)) : 0;
    } catch { BAL.xrbc = 0; }

    return BAL;
  }

  (async () => { if (window.__xrbcWallet) await fetchBalances(); })();
  window.addEventListener('focus', () => { if (window.__xrbcWallet) fetchBalances(); });

  // % chips: handle all of them
  (function initPercentChips(){
    const chips = document.querySelectorAll('.quick-amounts .qa');
    if (!chips.length) return;

    async function applyPercent(pct){
      const side = sideEl?.value || 'buy';
      const orderType = orderTypeEl?.value || 'limit';
      await fetchBalances();

      if (side === 'sell'){
        const amt = Math.max(0, BAL.xrbc * (pct/100));
        if (amountEl){
          amountEl.value = amt.toFixed(6);
          amountEl.dispatchEvent(new Event('input'));
        }
        return;
      }

      let price = Number(priceEl?.value) || 0;
      if (orderType === 'market' || !price){
        await fillBestPrice();
        price = Number(priceEl?.value) || 0;
      }
      if (!price || price <= 0) return;

      const spendable = Math.max(0, (BAL.xrp - RESERVE_BUFFER_XRP)) * (pct/100);
      const amt = spendable > 0 ? (spendable / price) : 0;

      if (amountEl){
        amountEl.value = amt.toFixed(6);
        amountEl.dispatchEvent(new Event('input'));
      }
    }

    chips.forEach(btn => btn.addEventListener('click', async () => {
      const pct = Number(btn.dataset.q || 0);
      if (!pct) return;
      btn.disabled = true;
      try { await applyPercent(pct); }
      finally { btn.disabled = false; }
    }));
  })();

  // Order type tabs + notes (stop-free) ‚Äî fixed stray "}))" paren
  (function initOrderTypeTabs(){
    const typeTabs  = document.querySelectorAll('.otype-tabs .otype');
    const notesWrap = document.getElementById('otypeNotes');

    const showNote = (t) => {
      if (!notesWrap) return;
      notesWrap.querySelectorAll('[data-note]').forEach(n => {
        n.hidden = n.getAttribute('data-note') !== t;
      });
    };

    typeTabs.forEach(btn => btn.addEventListener('click', () => {
      typeTabs.forEach(b => {
        b.classList.toggle('active', b === btn);
        b.setAttribute('aria-selected', b === btn ? 'true' : 'false');
      });

      const t = btn.dataset.type; // 'limit' or 'market'
      if (orderTypeEl) orderTypeEl.value = t;

      if (t === 'limit') {
        if (priceField) priceField.hidden = false;
        if (placeOfferBtn) { placeOfferBtn.disabled = false; placeOfferBtn.textContent = 'Place Limit Order'; }
      }

      if (t === 'market') {
        if (priceField) priceField.hidden = true;
        if (placeOfferBtn) { placeOfferBtn.disabled = false; placeOfferBtn.textContent = 'Place Market Order'; }
      }

      showNote(t);
      recalcTotals();
    }));

    showNote(orderTypeEl?.value || 'limit');
  })();

  // Side toggles (attach to ALL duplicate tabs)
  (function initSideToggles(){
    const apply = () => {
      if (!tradeCard) return;
      tradeCard.classList.toggle('buy',  sideEl?.value === 'buy');
      tradeCard.classList.toggle('sell', sideEl?.value === 'sell');
    };

    buyTabs.forEach(btn => btn.addEventListener('click', () => { setSide('buy');  apply(); }));
    sellTabs.forEach(btn => btn.addEventListener('click', () => { setSide('sell'); apply(); }));

    setSide(sideEl?.value || 'buy');
    apply();
  })();

  async function fillBestPrice() {
    if (!sideEl || !amountEl || !priceEl) return;
    const side = sideEl.value;
    const amount = Number(amountEl.value);
    if (!amount || amount <= 0) {
      if (tradeMsg){ tradeMsg.textContent = "Enter a valid XRBC amount."; tradeMsg.classList.remove("ok","err","connecting"); }
      return;
    }
    if (tradeMsg){ tradeMsg.textContent = "üîê Connecting to XRPL for secure best price‚Ä¶"; tradeMsg.classList.remove("ok","err"); tradeMsg.classList.add("connecting"); }

    try {
      const data = await xrplRequest({
        method: "amm_info",
        params: [{ asset: { currency: "XRP" }, asset2: { currency: XRBC.currency, issuer: XRBC.issuer } }]
      });
      const amm = data.result?.amm;
      if (!amm) throw new Error("No AMM found for XRBC/XRP");

      const reserveXrp  = parseFloat(amm.amount) / XRP_TO_DROPS;
      const reserveXrbc = parseFloat(amm.amount2.value);
      const feeRate     = amm.trading_fee / 1_000_000;
      const k           = reserveXrp * reserveXrbc;

      let effectivePrice;
      if (side === "buy") {
        const newY = reserveXrbc - amount;
        const newX = k / newY;
        let xrpIn = newX - reserveXrp;
        xrpIn += xrpIn * feeRate;
        effectivePrice = xrpIn / amount;
      } else {
        const newY = reserveXrbc + amount;
        const newX = k / newY;
        let xrpOut = reserveXrp - newX;
        xrpOut -= xrpOut * feeRate;
        effectivePrice = xrpOut / amount;
      }

      priceEl.value = Number(effectivePrice).toFixed(6);
      recalcTotals();
      if (tradeMsg){ tradeMsg.textContent = `Best price calculated from AMM pool (${side}).`; tradeMsg.classList.remove("connecting"); tradeMsg.classList.add("ok"); }
    } catch {
      if (tradeMsg){ tradeMsg.textContent = "üîê Still connecting securely to XRPL‚Ä¶"; tradeMsg.classList.add("connecting"); }
    }
  }
  if (suggestBtn) suggestBtn.addEventListener("click", fillBestPrice);

  // Auto-refresh AMM estimate if amount > 0
  setInterval(() => {
    const amt = Number(amountEl?.value);
    if (amt > 0) fillBestPrice().catch(()=>{});
  }, 10000);

  // Place Offer (stop-free)
  if (placeOfferBtn) placeOfferBtn.addEventListener("click", async () => {
    const orderType = orderTypeEl?.value;

    try {
      // Extra guard: require SDK + connection
      if (!xumm) throw new Error("Wallet SDK not available.");
      const account = window.__xrbcWallet;
      if (!account) throw new Error("Connect your wallet first.");

      const side   = sideEl?.value;
      const amt    = Number(amountEl?.value);
      let priceVal = Number(priceEl?.value);

      if (orderType === 'market') {
        if (!amt || amt <= 0) throw new Error("Enter valid Amount.");
        await fillBestPrice();
        priceVal = Number(priceEl?.value);
        if (!priceVal || priceVal <= 0) throw new Error("Unable to fetch market estimate.");
      } else {
        if (!amt || !priceVal || amt <= 0 || priceVal <= 0) throw new Error("Enter valid Amount & Price.");
      }

      const xrpTotal = priceVal * amt;
      const TF_SELL = 0x00080000;
      const TF_IOC  = 0x00020000;

      let txjson;
      if (side === "sell") {
        txjson = {
          TransactionType: "OfferCreate",
          Account: account,
          TakerGets: { currency: XRBC.currency, issuer: XRBC.issuer, value: String(amt) },
          TakerPays: toDrops(xrpTotal),
          Flags: (orderType === 'market') ? (TF_SELL | TF_IOC) : TF_SELL
        };
      } else {
        txjson = {
          TransactionType: "OfferCreate",
          Account: account,
          TakerGets: toDrops(xrpTotal),
          TakerPays: { currency: XRBC.currency, issuer: XRBC.issuer, value: String(amt) },
          Flags: (orderType === 'market') ? TF_IOC : 0
        };
      }

      if (tradeMsg) tradeMsg.textContent = "Open Xaman to review & sign‚Ä¶";
      const { resolved } = await xumm.payload.createAndSubscribe({ txjson }, (ev) => {
        if (ev?.opened && tradeMsg) tradeMsg.textContent = "Payload opened in Xaman‚Ä¶";
        if (ev?.signed === false && tradeMsg) tradeMsg.textContent = "Order rejected.";
      });

      const result = await resolved;
      if (!result.signed) { if (tradeMsg) tradeMsg.textContent = "Order not signed."; return; }

      if (tradeMsg) tradeMsg.textContent = "Order submitted. Refreshing order book‚Ä¶";
      const html = await getXrbcOrderBook();
      const priceOut = document.getElementById("priceOutput");
      if (priceOut) priceOut.innerHTML = html;

    } catch (err) {
      if (tradeMsg) tradeMsg.textContent = "Error: " + (err && err.message ? err.message : err);
    }
  });

  /* ========= AMM Pool updater ========= */
  async function updateAmmPool() {
    try {
      const data = await xrplRequest({
        method: "amm_info",
        params: [{ asset: { currency: "XRP" }, asset2: { currency: XRBC.currency, issuer: XRBC.issuer } }]
      });

      const out = document.getElementById("ammPoolOutput");
      if (!out) return;

      const amm = data.result?.amm;
      if (!amm) {
        out.textContent = "No AMM pool exists yet.";
        return;
      }

      const reserveXrp  = (parseFloat(amm.amount) / XRP_TO_DROPS).toFixed(6);
      const reserveXrbc = parseFloat(amm.amount2.value).toFixed(6);
      const feeRate     = (amm.trading_fee / 10000).toFixed(2);

      out.innerHTML = `
        <table class="table">
          <thead><tr><th>Reserve XRP</th><th>Reserve XRBC</th><th>Trading Fee</th></tr></thead>
          <tbody><tr><td>${reserveXrp}</td><td>${reserveXrbc}</td><td>${feeRate}%</td></tr></tbody>
        </table>`;
    } catch (err) {
      const out = document.getElementById("ammPoolOutput");
      if (out) out.textContent = "Error fetching AMM pool: " + ((err && err.message) || err);
    }
  }
  updateAmmPool();
  setInterval(updateAmmPool, 15000);

  /* ========= XRBC DEX ‚Äî Live Metrics (inside same IIFE) ========= */
  (function liveMetrics(){
    const $ = (id) => document.getElementById(id);
    const status = $("metricsStatus");
    const ledgerOut = $("ledgerOutput");
    const bookOut   = $("priceOutput");

    const liveMid     = $("liveMid");
    const liveSpread  = $("liveSpread");
    const liveBid     = $("liveBid");
    const liveAsk     = $("liveAsk");
    const ammReserves = $("ammReserves");
    const ammFee      = $("ammFee");
    const vol24h      = $("vol24h");
    const trades24h   = $("trades24h");

    function setText(el, v){ if (el) el.textContent = v; }
    function ok(msg){ if(status){ status.textContent = msg; status.classList.remove("err","connecting"); status.classList.add("ok"); } }
    function info(msg){ if(status){ status.textContent = msg; status.classList.remove("ok","err"); status.classList.add("connecting"); } }
    function fail(msg){ if(status){ status.textContent = msg; status.classList.remove("ok","connecting"); status.classList.add("err"); } }

    async function refreshLedger() {
      if (!ledgerOut) return;
      try {
        info("Fetching validated ledger‚Ä¶");
        const data = await getLedgerInfo();
        const r = (data && data.result) || {};
        const idx   = r.ledger_index || r.validated_ledger_index || r.ledger?.ledger_index;
        const hash  = r.ledger_hash  || r.ledger?.ledger_hash;
        const close = r.ledger?.close_time_human || r.closed?.close_time_human;
        const summary = {
          ledger_index: idx ?? "(unknown)",
          ledger_hash : hash ?? "(unknown)",
          close_time  : close || "(not expanded)",
          validated   : r.validated === undefined ? true : !!r.validated
        };
        ledgerOut.textContent = JSON.stringify(summary, null, 2);
        ok("Ledger updated");
      } catch (e) {
        fail("Error fetching ledger");
        if (ledgerOut) ledgerOut.textContent = "Error fetching ledger: " + (e?.message || e);
      }
    }

    function priceFromOffer(of) {
      if (!of) return null;
      const gets = of.TakerGets?.value
        ? parseFloat(of.TakerGets.value)
        : parseFloat(of.TakerGets) / XRP_TO_DROPS;
      const pays = of.TakerPays?.value
        ? parseFloat(of.TakerPays.value)
        : parseFloat(of.TakerPays) / XRP_TO_DROPS;
      if (!isFinite(gets) || !isFinite(pays) || gets <= 0) return null;
      return pays / gets; // XRP per XRBC
    }

    async function refreshTicker() {
      try {
        const [askRes, bidRes] = await Promise.all([
          xrplRequest({ method: "book_offers",
            params: [{ taker_gets: XRBC, taker_pays: { currency: "XRP" }, limit: 1 }] }),
          xrplRequest({ method: "book_offers",
            params: [{ taker_gets: { currency: "XRP" }, taker_pays: XRBC, limit: 1 }] })
        ]);

        const bestAsk = priceFromOffer(askRes?.result?.offers?.[0]);
        const bestBid = priceFromOffer(bidRes?.result?.offers?.[0]);

        if (bestAsk && bestBid) {
          const mid    = (bestAsk + bestBid) / 2;
          const spread = bestAsk - bestBid;
          setText(liveMid,    mid.toFixed(6));
          setText(liveSpread, spread.toFixed(6));
          setText(liveBid,    bestBid.toFixed(6));
          setText(liveAsk,    bestAsk.toFixed(6));
          ok("Live price updated");
        } else {
          setText(liveMid, "‚Äî"); setText(liveSpread, "‚Äî");
          setText(liveBid, "‚Äî"); setText(liveAsk, "‚Äî");
          info("No top-of-book quotes");
        }
      } catch (e) {
        setText(liveMid, "‚Äî"); setText(liveSpread, "‚Äî");
        setText(liveBid, "‚Äî"); setText(liveAsk, "‚Äî");
        fail("Ticker error");
      }
    }

    async function refreshOrderBook() {
      if (!bookOut) return;
      try {
        info("Loading order book‚Ä¶");
        const html = await getXrbcOrderBook();
        bookOut.innerHTML = html;
        ok("Order book updated");
      } catch (e) {
        bookOut.textContent = "Error loading order book: " + (e?.message || e);
        fail("Error loading order book");
      }
    }

    async function refreshAmmMini() {
      try {
        const data = await xrplRequest({
          method: "amm_info",
          params: [{ asset: { currency: "XRP" }, asset2: { currency: XRBC.currency, issuer: XRBC.issuer } }]
        });
        const amm = data?.result?.amm;
        if (amm) {
          const reserveXrp  = (parseFloat(amm.amount) / XRP_TO_DROPS).toFixed(6);
          const reserveXrbc = parseFloat(amm.amount2?.value || 0).toFixed(6);
          const feePct      = (amm.trading_fee / 10000).toFixed(2) + "%";
          setText(ammReserves, `${reserveXrp} XRP ¬∑ ${reserveXrbc} XRBC`);
          setText(ammFee, feePct);
        } else {
          setText(ammReserves, "‚Äî");
          setText(ammFee, "‚Äî");
        }
        try { updateAmmPool(); } catch(_) {}
      } catch (e) {
        setText(ammReserves, "‚Äî");
        setText(ammFee, "‚Äî");
      }
    }

    function refresh24hStub() {
      setText(vol24h,   "‚Äî");
      setText(trades24h,"Trades: ‚Äî");
    }

    async function refreshAll(){
      info("Refreshing metrics‚Ä¶");
      await Promise.allSettled([
        refreshTicker(),
        refreshAmmMini(),
        refreshOrderBook(),
        refreshLedger()
      ]);
      refresh24hStub();
    }

    // Button wiring (support old and new IDs if present)
    const allBtn    = document.getElementById("metricsRefreshBtn") || document.getElementById("refreshMetricsBtn");
    const bookBtn   = document.getElementById("metricsBookBtn")    || document.getElementById("fetchPriceBtn");
    const ledgerBtn = document.getElementById("metricsLedgerBtn")  || document.getElementById("fetchLedgerBtn");

    if (allBtn)    allBtn.addEventListener("click", () => refreshAll().catch(()=>{}));
    if (bookBtn)   bookBtn.addEventListener("click", () => refreshOrderBook().catch(()=>{}));
    if (ledgerBtn) ledgerBtn.addEventListener("click", () => refreshLedger().catch(()=>{}));

    document.addEventListener("visibilitychange", () => { if (!document.hidden) refreshAll().catch(()=>{}); });
    window.addEventListener("focus", () => refreshAll().catch(()=>{}));
    setInterval(() => refreshAll().catch(()=>{}), 15000);

    // kick off
    refreshAll().catch(()=>{});
  })();

  /* ========= Download Xaman button (popover) ========= */
  const downloadBtn = document.getElementById('downloadXamanBtn');
  if (downloadBtn){
    const DOWNLOAD_URL = 'https://xaman.app/download';
    const pop = document.getElementById('dlPopover');
    const qrImg = document.getElementById('dlQr');
    const actions = downloadBtn.closest('.wallet-actions');

    if (qrImg && !qrImg.src){
      qrImg.src = 'https://api.qrserver.com/v1/create-qr-code/?size=180x180&data=' + encodeURIComponent(DOWNLOAD_URL);
    }

    function hidePopover(){
      if (!pop) return;
      pop.classList.remove('show');
      document.body.classList.remove('dl-popover-open');
      pop.setAttribute('aria-hidden','true');
    }

    function showPopover(){
      if (!pop || !actions) return;
      pop.style.visibility = 'hidden';
      pop.classList.add('show');

      const br = downloadBtn.getBoundingClientRect();
      const ar = actions.getBoundingClientRect();
      const pw = pop.offsetWidth;
      const ph = pop.offsetHeight;

      const top = (br.top - ar.top) + (br.height/2) - (ph/2);
      const left = (br.left - ar.left) - pw - 12;

      pop.style.top = `${Math.max(0, top)}px`;
      pop.style.left = `${Math.max(0, left)}px`;

      pop.style.visibility = '';
      document.body.classList.add('dl-popover-open');
      pop.setAttribute('aria-hidden','false');
    }

    downloadBtn.addEventListener('click', (e) => {
      if (/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)) {
        window.location.href = DOWNLOAD_URL;
        return;
      }
      e.preventDefault();
      if (pop.classList.contains('show')) hidePopover();
      else showPopover();
    });

    document.addEventListener('click', (e) => {
      if (!pop.classList.contains('show')) return;
      if (e.target === downloadBtn || pop.contains(e.target)) return;
      hidePopover();
    });
    window.addEventListener('resize', hidePopover);
    window.addEventListener('scroll', hidePopover, { passive:true });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hidePopover(); });
  }
})(); // end IIFE
</script>




  
  
  <!-- ===== XRBC Footer ===== -->
  <footer class="site-footer" role="contentinfo" aria-label="XRBitcoinCash footer">
    <div class="wrap">
      <div class="cols" style="display:grid;gap:18px;grid-template-columns:1fr;max-width:var(--wrap-wide);margin:0 auto;">
        <section>
          <h3>About this page</h3>
          <p class="small">
            A minimal, security-first trading &amp; ledger portal for
            <strong>XRBitcoinCash (XRBC)</strong> on the <span class="nowrap">XRP Ledger</span>.
            Signing is handled in <strong>Xaman</strong> on mobile for safer review and execution.
          </p>
          <dl class="factlist" aria-label="XRBC details" style="display:grid;gap:6px;margin:0">
            <div class="fact" style="display:flex;gap:8px"><strong style="min-width:142px;color:#cfe6ff">Symbol</strong><span class="mono">XRBC</span></div>
            <div class="fact" style="display:flex;gap:8px"><strong style="min-width:142px;color:#cfe6ff">Issuer</strong><span class="mono">rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw</span></div>
            <div class="fact" style="display:flex;gap:8px"><strong style="min-width:142px;color:#cfe6ff">Currency Code</strong><span class="mono">5852626974636F696E6361736800000000000000</span></div>
            <div class="fact" style="display:flex;gap:8px"><strong style="min-width:142px;color:#cfe6ff">Total Supply</strong><span class="mono">21,000,000</span></div>
          </dl>
        </section>

        <section>
          <h3>Security measures</h3>
          <ul class="small" style="list-style:disc;margin-left:18px;display:grid;gap:6px">
            <li><strong>Mobile & desktop signing</strong> via Xaman; desktop shows a QR automatically in the Xaman flow.</li>
            <li>No keys ever requested or stored; only the public account address may be cached (localStorage).</li>
            <li>XRPL calls validated; errors handled; no <span class="mono">eval</span> or dynamic script injection.</li>
            <li>XRBC issuer &amp; currency code are constants; XRP‚Üîdrops conversion is precise.</li>
            <li>AMM helper estimates effective price incl. fee.</li>
          </ul>
        </section>

        <section style="display:grid;gap:10px;justify-items:center;">
          <h3>Whitepaper &amp; credits</h3>
          <a class="eco-link" href="/whitepaper.html" aria-label="Open the XRBitcoinCash Whitepaper" style="min-width:200px;">
            <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
              <path fill="currentColor" d="M6 2h7l5 5v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2z"></path>
              <path fill="#ffffff" d="M13 2v5h5"></path>
            </svg>
            Whitepaper
          </a>
          <a class="eco-link" href="https://chat.openai.com/" target="_blank" rel="noopener noreferrer" aria-label="Talk to ChatGPT" style="min-width:200px;">
            <img src="/assets/chatgpt-mark.svg" alt="" onerror="this.remove()">
            <span>Built with ChatGPT</span>
          </a>
          <p class="small" style="margin-top:4px;opacity:.9">
            Verify the URL starts with <span class="mono">https://xrbitcoincash.com</span>.
          </p>
        </section>
      </div>

      <div class="legal small" style="border-top:1px dashed #1f2a37;padding-top:10px;display:flex;flex-wrap:wrap;gap:6px;justify-content:space-between;align-items:center">
        <span>XRBC ¬∑ XRBC/XRP Trading &amp; Ledger Portal</span>
        <span class="mono">Issuer: rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw</span>
      </div>
    </div>
  </footer>
</body>
</html>
