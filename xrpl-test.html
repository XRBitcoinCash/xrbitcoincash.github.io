<!DOCTYPE html>
<html lang="en">
<head>

  
<!-- keep this in <head> -->
<link rel="license" href="#license-proprietary">
  
  <!-- ===== XRBitcoinCash · Instant Limit Order Extraction · Meta ===== -->
<meta charset="utf-8" />
<title>Instant Limit Order Extraction · XRPL · XRBC</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<!-- Canonical -->
<link rel="canonical" href="https://xrbitcoincash.com/extract-orders.html" />
<link rel="alternate" hreflang="en" href="https://xrbitcoincash.com/extract-orders.html" />

<!-- Primary SEO -->
<meta name="description" content="Cancel XRPL open orders and buy XRBC with one click. Xumm (Xaman) supported. Secure, non-custodial, on-ledger." />
<meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1" />
<meta name="theme-color" content="#0b0f14" />

<!-- Favicons / App Icons -->
<link rel="icon" href="/favicon.ico?v=1" sizes="any">
<link rel="icon" type="image/png" href="/xrbc-nft.png">
<link rel="apple-touch-icon" href="/xrbc-nft.png">
<link rel="mask-icon" href="/favicons/safari-pinned-tab.svg?v=1" color="#0b0f14">
<meta name="msapplication-TileColor" content="#0b0f14">

<!-- Open Graph -->
<meta property="og:type" content="website">
<meta property="og:site_name" content="XRBitcoinCash">
<meta property="og:title" content="Instant Limit Order Extraction · XRPL · XRBC">
<meta property="og:description" content="Cancel XRPL open orders and buy XRBC with one click. Xumm supported.">
<meta property="og:url" content="https://xrbitcoincash.com/extract-orders.html">
<meta property="og:image" content="https://xrbitcoincash.com/xrbc-nft.png">
<meta property="og:image:secure_url" content="https://xrbitcoincash.com/xrbc-nft.png">
<meta property="og:image:alt" content="XRBitcoinCash — XRBC logo">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">

<!-- Twitter / X Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Instant Limit Order Extraction · XRPL · XRBC">
<meta name="twitter:description" content="Cancel XRPL open orders and buy XRBC with one click. Xumm supported.">
<meta name="twitter:image" content="https://xrbitcoincash.com/xrbc-nft.png">
<meta name="twitter:image:alt" content="XRBitcoinCash — XRBC logo">

<!-- Performance hints -->
<link rel="preconnect" href="https://xaman.app" crossorigin>
<link rel="preconnect" href="https://xrbitcoincash-github-io.onrender.com" crossorigin>

<!-- JSON-LD -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "WebPage",
      "name": "Instant Limit Order Extraction · XRPL · XRBC",
      "url": "https://xrbitcoincash.com/extract-orders.html",
      "description": "Cancel XRPL open orders and buy XRBC with one click. Xumm (Xaman) supported.",
      "isPartOf": {
        "@type": "WebSite",
        "name": "XRBitcoinCash",
        "url": "https://xrbitcoincash.com/"
      },
      "primaryImageOfPage": {
        "@type": "ImageObject",
        "url": "https://xrbitcoincash.com/xrbc-nft.png",
        "width": 1200,
        "height": 630
      }
    },
    {
      "@type": "SoftwareApplication",
      "name": "Instant Limit Order Extraction",
      "applicationCategory": "FinanceApplication",
      "operatingSystem": "Web",
      "url": "https://xrbitcoincash.com/extract-orders.html",
      "image": "https://xrbitcoincash.com/xrbc-nft.png",
      "offers": { "@type": "Offer", "price": "0", "priceCurrency": "USD" },
      "publisher": { "@type": "Organization", "name": "XRBitcoinCash" }
    },
    {
      "@type": "Organization",
      "name": "XRBitcoinCash",
      "url": "https://xrbitcoincash.com/",
      "logo": {
        "@type": "ImageObject",
        "url": "https://xrbitcoincash.com/xrbc-nft.png",
        "width": 512,
        "height": 512
      }
    }
  ]
}
</script>

<style>
:root{
  --wrap:1100px;--bg:#0b0f14;--panel:#0e1520;--panel-2:#0c131c;--ink:#e7edf5;--muted:#9fb0c5;--line:#2b3a4b;
  --ok:#22c55e;--err:#ef4444;--blue:#2563eb;--yellow:#f59e0b
}
*{box-sizing:border-box}html,body{height:100%;max-width:100%;overflow-x:hidden}
body{background:var(--bg);color:var(--ink);font:16px/1.55 system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;margin:0}
.container{max-width:var(--wrap);margin:16px auto;padding:0 max(16px, env(safe-area-inset-left))}
.card{background:linear-gradient(180deg,var(--panel),var(--panel-2));border:1px solid var(--line);border-radius:14px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);margin-top:12px}
h1,h2,h3{margin:.2em 0}
.row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
.btn{appearance:none;border:1px solid var(--line);border-radius:12px;background:linear-gradient(180deg,#0e1520,#0c131c);color:var(--ink);padding:10px 14px;font-weight:800;cursor:pointer;min-height:44px;text-decoration:none;display:inline-flex;align-items:center}
.btn:disabled{opacity:.6;cursor:not-allowed}
.glow-green{box-shadow:0 0 0 2px rgba(34,197,94,.25), 0 0 20px rgba(34,197,94,.18)}
.glow-red{box-shadow:0 0 0 2px rgba(239,68,68,.25), 0 0 20px rgba(239,68,68,.18)}
.glow-yellow{box-shadow:0 0 0 2px rgba(245,158,11,.25), 0 0 20px rgba(245,158,11,.18)}
.glow-blue{box-shadow:0 0 0 2px rgba(37,99,235,.25), 0 0 20px rgba(37,99,235,.18)}
.status{font-size:13px;color:var(--muted)} .status.ok{color:var(--ok)} .status.err{color:var(--err)}
table{width:100%;border-collapse:collapse;margin-top:10px;font-size:14px}
th,td{padding:8px 10px;border-bottom:1px solid #1a2433;text-align:left;vertical-align:top}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
.hint{color:var(--muted);font-size:12px}
.warn{border-left:4px solid #d97706;background:linear-gradient(180deg,#231b0c,#1a140a);border:1px solid #3a2f18;border-radius:10px;padding:10px;color:#f3e8d0}
.footer{margin-top:20px;color:#9fb0c5;font-size:12px}
.badge{display:inline-block;padding:2px 8px;border:1px solid var(--line);border-radius:9999px;margin-left:8px}
.badge.testnet{background:#102018;color:#9fe29f;border-color:#2c4} .badge.mainnet{background:#181820;color:#cfd2ff;border-color:#44c}
.progress{height:6px;background:#112035;border-radius:9999px;overflow:hidden;margin-top:8px}
.progress>span{display:block;height:100%;background:var(--blue);width:0%}
.grid{display:grid;gap:12px}
.grid.cols-3{grid-template-columns:repeat(3,1fr)}
@media (max-width:960px){ .grid.cols-3{grid-template-columns:1fr} }
.panel-note{border:1px dashed var(--line);border-radius:10px;padding:8px 10px;margin-top:8px}
.log{max-height:200px;overflow:auto;border:1px solid #1a2433;border-radius:10px;padding:8px;background:#0b111a;font-size:12px;white-space:pre-wrap}
a.logo-link{display:flex;align-items:center;gap:10px;text-decoration:none;color:inherit}
.pill{display:inline-block;border:1px solid var(--line);border-radius:9999px;padding:2px 8px;font-weight:800}
.site-footer{margin:24px auto;padding:16px;border-top:1px solid var(--line);max-width:var(--wrap);color:var(--muted)}
.site-footer .license{font-size:12px;white-space:pre-wrap;line-height:1.45}

/* Embed mode clean-up */
body.embed .container{max-width:none}
body.embed header.card, body.embed footer.site-footer{display:none}
body.embed .card{border-radius:0;box-shadow:none;border:none;margin-top:0}
</style>

<!-- Xumm SDK -->
<script src="https://xaman.app/assets/cdn/xumm.min.js" crossorigin="anonymous"></script>
</head>
<body>
  <main class="container" aria-live="polite">
    <header class="card" style="display:flex;align-items:center;justify-content:space-between;gap:10px">
      <a class="logo-link" href="/index.html" title="XR Bitcoin Cash · Home">
        <img src="/xrbc-nft.png" alt="XRBC" width="32" height="32" style="border-radius:6px;border:1px solid var(--line)">
        <h1 style="margin:0">Instant Limit Order Extraction</h1>
        <span id="netBadge" class="badge mainnet">Mainnet</span>
      </a>
      <div class="row" style="gap:8px">
        <a class="btn glow-blue" href="/index.html" id="btnHome" title="Go to Home">Home</a>
        <label class="hint" for="network">Network
          <select id="network" aria-label="Network">
            <option value="mainnet" selected>Mainnet</option>
            <option value="testnet">Testnet</option>
          </select>
        </label>
      </div>
    </header>

    <section class="card" aria-labelledby="wlt">
      <h2 id="wlt">Wallet</h2>
      <div class="grid cols-3">
        <div>
          <h3 style="margin:0 0 6px">Xaman (Xumm)</h3>
          <p class="hint">Mobile-first. Desktop QR. Signing happens in-app.</p>
          <div class="row">
            <button id="btnXumm" class="btn glow-green" type="button">Connect Xumm</button>
          </div>
        </div>
      </div>

      <div class="row" style="gap:8px;margin:12px 0 0">
        <label class="hint" for="walletSelect">Wallet</label>
        <select id="walletSelect" aria-label="Wallet">
          <option value="xumm">Xumm (Xaman)</option>
        </select>
        <button id="btnConnect"  class="btn glow-green" type="button">Connect</button>
        <button id="btnDisconnect" class="btn glow-red" type="button" disabled>Disconnect</button>
      </div>

      <div class="panel-note">
        <p class="hint" style="margin:0">Raw secret signing is disabled. Use a wallet. No keys stored.</p>
      </div>

      <div class="row" style="margin:10px 0 4px">
        <button id="btnRefresh" class="btn glow-yellow" type="button">Refresh Orders</button>
        <button id="btnCancelAll" class="btn glow-blue" type="button" title="Cancel all visible open offers">Cancel All Visible Orders</button>
      </div>
      <p id="walletStatus" class="status">Status: Not connected</p>
    </section>

    <section class="card" aria-labelledby="orders">
      <h2 id="orders">Open Orders</h2>
      <div id="offersWrap" class="hint">No data yet.</div>
      <div class="progress" aria-hidden="true"><span id="progressBar"></span></div>
      <p id="offersStatus" class="status"></p>
    </section>

    <section class="card" aria-labelledby="res">
      <h2 id="res">Results</h2>
      <div id="resultBox" class="hint">Cancel receipts and freed reserve will appear here.</div>
      <div class="panel-note" style="margin-top:10px">
        <div class="hint">Activity log</div>
        <pre id="log" class="log" aria-live="polite"></pre>
      </div>
    </section>

    <section class="card" aria-labelledby="buyxrbc">
      <h2 id="buyxrbc">Quick Buy · XR Bitcoin Cash (XRBC)</h2>
      <p class="hint">Requires XRBC trust line. Buys use XRPL pathfinding and may route through AMM pools or order books.</p>
      <div class="row">
        <button id="btnTrustXRBC" class="btn" type="button" title="Add XRBC trust line">Add XRBC Trust Line</button>
        <span class="pill">Issuer: <span class="mono" id="xrbcIssuerPill">rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw</span></span>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="btn" id="buy1"   type="button">Buy 1 XRBC for XRP</button>
        <button class="btn" id="buy25"  type="button">Buy 25 XRBC for XRP</button>
        <button class="btn" id="buy50"  type="button">Buy 50 XRBC for XRP</button>
        <button class="btn" id="buy100" type="button">Buy 100 XRBC for XRP</button>
      </div>
      <p id="buyStatus" class="status"></p>
    </section>

    <!-- ===== Embed widget: copy-paste for other sites ===== -->
    <section class="card" aria-labelledby="embed">
      <h2 id="embed">Embed this tool on your site</h2>
      <p class="hint">Copy the snippet below. It renders an iframe that loads this page in “embed mode.” You can change <code>network=</code> and <code>minHeight</code>.</p>
      <div class="panel-note">
        <div class="row" style="gap:8px">
          <button id="btnCopyIframe" class="btn glow-blue" type="button">Copy embed code</button>
          <a id="btnOpenDemo" class="btn" href="https://xrbitcoincash.com/extract-orders.html?embed=1" target="_blank" rel="noopener">Open embed demo</a>
        </div>
        <pre id="embedCode" class="log" style="user-select:all;white-space:pre-wrap">&lt;div id="xrbc-widget" style="width:100%;max-width:1100px;margin:auto"&gt;&lt;/div&gt;
&lt;script&gt;(function(w,d,c,u,h){var el=d.getElementById(c)||d.body.appendChild(Object.assign(d.createElement('div'),{id:c}));
var f=d.createElement('iframe');f.src=u;f.style.width='100%';f.style.minHeight=h;f.style.border='0';f.loading='lazy';el.appendChild(f);
})(window,document,'xrbc-widget','https://xrbitcoincash.com/extract-orders.html?embed=1&amp;network=mainnet','860px');&lt;/script&gt;</pre>
        <p class="hint" style="margin:8px 0 0">
          Prefer a script loader API? Serve a small JS that calls <code>XRBCWidget.mount({...})</code> and points to the same URL.
        </p>
      </div>
    </section>

    <section class="card" aria-labelledby="important">
      <h2 id="important">Important</h2>
      <div class="warn">
        Verify every transaction in your wallet before approving. Transactions are final. Fees apply. Ensure the same network in wallet and page.
      </div>
      <p class="footer">
        Disclaimer: Not a broker or custodian. You sign in your wallet. Canceling releases reserves and returns any remaining locked assets to your balance. Use at your own risk. Verify on an explorer if in doubt.
      </p>
    </section>
  </main>

  <footer class="site-footer" role="contentinfo">
  <div id="license-proprietary" class="license">
<strong>Proprietary License — Instant Limit Order Extraction (XRPL)</strong>
Copyright (c) 2025 XRBitcoinCash. All rights reserved.

This software and its contents are proprietary to XRBitcoinCash (the “Licensor”).
Except as expressly permitted by the Licensor in a separate written agreement, you may not copy,
modify, merge, publish, distribute, sublicense, sell, lease, or otherwise use any portion of this
software or its associated assets.

You are granted permission only to access and view the publicly hosted website for personal use
through a standard web browser. No other rights are granted, whether by implication, estoppel,
or otherwise.

<strong>Widget and Embed Access.</strong> Any embed, widget, API key, or hosted script provided by the
Licensor is licensed for revocable, non-transferable use. The Licensor may, at its sole discretion,
suspend, limit, or disable access to any embed, widget, API key, or hosted script at any time and
without notice, including removal from third-party sites, unless a separate written agreement
signed by an authorized officer of the Licensor expressly provides otherwise. You must not
circumvent or attempt to circumvent any access controls or technical measures.

ANY USE OF THIS SOFTWARE NOT EXPRESSLY PERMITTED ABOVE IS STRICTLY PROHIBITED.

DISCLAIMER OF WARRANTY. THE SOFTWARE IS PROVIDED “AS IS” AND WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND NON-INFRINGEMENT.

LIMITATION OF LIABILITY. IN NO EVENT SHALL THE LICENSOR BE LIABLE FOR ANY CLAIM, DAMAGES,
OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM,
OUT OF, OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Contact: legal@xrbitcoincash.com
  </div>
</footer>



  <!-- App configuration -->
  <script type="application/json" id="app-config">
  {
    "proxyUrl": "https://xrbitcoincash-github-io.onrender.com",
    "xummApiKey": "2abde023-0df1-49a2-a4dc-86d776f6318d",
    "networks": { "mainnet": { "label": "Mainnet" }, "testnet": { "label": "Testnet" } },
    "xrbc": {
      "issuer": "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw",
      "currencyHex": "5852626974636F696E6361736800000000000000"
    }
  }
  </script>

  <script>
  (function(){
    'use strict';

    // ===== Embed mode toggle =====
    (function initEmbedMode(){
      try {
        const q = new URLSearchParams(location.search);
        if (q.get('embed') === '1') document.body.classList.add('embed');
      } catch {}
    })();

    // ===== Copy embed code =====
    (function initCopy(){
      const btn = document.getElementById('btnCopyIframe');
      const pre = document.getElementById('embedCode');
      if (!btn || !pre) return;
      btn.addEventListener('click', async () => {
        try{
          const txt = pre.textContent;
          await navigator.clipboard.writeText(txt);
          btn.textContent = 'Copied';
          setTimeout(()=>btn.textContent='Copy embed code', 1200);
        }catch{
          // fallback
          const r = document.createRange(); r.selectNode(pre);
          const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(r);
          document.execCommand('copy'); sel.removeAllRanges();
          btn.textContent = 'Copied';
          setTimeout(()=>btn.textContent='Copy embed code', 1200);
        }
      });
    })();

    // ===== CONFIG =====
    const cfg = JSON.parse(document.getElementById('app-config').textContent || '{}');
    const PROXY_BASE   = cfg.proxyUrl || '';
    const XUMM_API_KEY = cfg.xummApiKey || '';
    const XRBC         = cfg.xrbc || {};
    const XRP_TO_DROPS = 1_000_000;

    // ===== STATE =====
    const state = {
      network: 'mainnet',
      account: null,
      adapter: null,
      offers: [],
      lastAccountInfo: null
    };

    // ===== DOM =====
    const $ = id => document.getElementById(id);
    const $walletStatus = $('walletStatus');
    const $offersStatus = $('offersStatus');
    const $offersWrap   = $('offersWrap');
    const $resultBox    = $('resultBox');
    const $log          = $('log');

    const $btnXumm      = $('btnXumm');
    const $walletSelect = $('walletSelect');
    const $btnConnect   = $('btnConnect');
    const $btnDisconnect= $('btnDisconnect');

    const $btnRefresh   = $('btnRefresh');
    const $btnCancelAll = $('btnCancelAll');
    const $networkSel   = $('network');
    const $netBadge     = $('netBadge');
    const $progress     = $('progressBar');

    const $btnTrust     = $('btnTrustXRBC');
    const $buyStatus    = $('buyStatus');

    // ===== UTILS =====
    function log(s){ if ($log) { $log.textContent += (s + '\n'); $log.scrollTop = $log.scrollHeight; } }
    function setStatus(node, text, cls){
      if (!node) return;
      node.textContent = text;
      node.classList.remove('ok','err');
      if (cls) node.classList.add(cls);
      if (node === $offersStatus) log('[offers] ' + text);
      else if (node === $walletStatus) log('[wallet] ' + text);
      else if (node === $buyStatus) log('[buy] ' + text);
    }
    const N = v => Number.isFinite(Number(v)) ? Number(v) : 0;
    const isXRP = a => typeof a === 'string' || (a && a.currency === 'XRP');
    const fmtDrops = d => (N(d)/XRP_TO_DROPS).toFixed(6) + ' XRP';
    const amtStr = a => isXRP(a) ? fmtDrops(a) : (Number(a.value).toFixed(6) + ' ' + (a.currency || 'IOU'));
    const price = (gets, pays) => {
      const g = isXRP(gets) ? N(gets)/XRP_TO_DROPS : N(gets.value);
      const p = isXRP(pays) ? N(pays)/XRP_TO_DROPS : N(pays.value);
      return g > 0 ? (p/g).toFixed(6) : '—';
    };
    function setProgress(pct){ if ($progress) $progress.style.width = Math.max(0, Math.min(100, pct)) + '%'; }
    function updateNetBadge(){
      const s = state.network==='testnet'?'testnet':'mainnet';
      if ($netBadge){ $netBadge.textContent = s==='testnet'?'Testnet':'Mainnet'; $netBadge.className = 'badge ' + s; }
    }
    function proxyUrl(){
      return PROXY_BASE + (state.network === 'testnet' ? '?network=testnet' : '');
    }

    // ===== XRPL PROXY CALLS =====
    async function xrplRequest(payload, {timeoutMs=12000}={}){
      if (!PROXY_BASE) throw new Error('Proxy URL missing');
      const ctrl = new AbortController();
      const t = setTimeout(()=>ctrl.abort(), timeoutMs);
      try{
        const res = await fetch(proxyUrl(), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          signal: ctrl.signal,
          redirect: 'error',
          cache: 'no-store',
          credentials: 'omit'
        });
        if (!res.ok) throw new Error('Proxy HTTP '+res.status);
        const data = await res.json();
        if (data && data.error) throw new Error('XRPL '+(data.error?.message||'error'));
        return data;
      } finally { clearTimeout(t); }
    }
    async function call(method, params){
      const r = await xrplRequest({ method, params:[{...params, ledger_index:'validated'}] });
      return r?.result;
    }

    // ===== DATA LOAD =====
    async function getAccountInfo(acct){
      const r = await call('account_info', { account: acct });
      return r?.account_data || {};
    }
    async function fetchOffers(acct){
      setStatus($offersStatus, 'Loading open orders…');
      try{
        const r = await call('account_offers', { account: acct, limit: 500 });
        state.offers = r?.offers || [];
        renderOffers();
        setStatus($offersStatus, `Found ${state.offers.length} open offer(s).`, 'ok');
      }catch(e){
        state.offers = [];
        renderOffers();
        setStatus($offersStatus, 'Error loading offers: '+(e.message||e), 'err');
      }
    }
    function renderOffers(){
      $offersWrap.innerHTML = '';
      if (!state.offers.length){
        const d = document.createElement('div');
        d.className = 'hint';
        d.textContent = 'No open offers found.';
        $offersWrap.appendChild(d);
        return;
      }
      const wrap = document.createElement('div'); wrap.style.overflow='auto';
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      ['Offer Seq','Owner gets','Owner pays','Price','Action'].forEach(h=>{
        const th = document.createElement('th'); th.textContent = h; trh.appendChild(th);
      });
      thead.appendChild(trh); table.appendChild(thead);
      const tbody = document.createElement('tbody');
      state.offers.forEach(o=>{
        const tr = document.createElement('tr');
        const tdSeq = document.createElement('td'); tdSeq.className='mono'; tdSeq.textContent = o.seq; tr.appendChild(tdSeq);
        const tdGets = document.createElement('td'); tdGets.textContent = amtStr(o.taker_gets); tr.appendChild(tdGets);
        const tdPays = document.createElement('td'); tdPays.textContent = amtStr(o.taker_pays); tr.appendChild(tdPays);
        const tdPx = document.createElement('td'); tdPx.textContent = price(o.taker_gets,o.taker_pays); tr.appendChild(tdPx);
        const tdAct = document.createElement('td');
        const b = document.createElement('button'); b.className='btn'; b.type='button'; b.textContent='Cancel';
        b.addEventListener('click', ()=>cancelOne(o.seq));
        tdAct.appendChild(b); tr.appendChild(tdAct);
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      wrap.appendChild(table);
      $offersWrap.appendChild(wrap);
    }
    async function beforeAfterReserveReport(acct, prevInfo){
      try{
        const now = await getAccountInfo(acct);
        const prevBal = N(prevInfo?.Balance)/XRP_TO_DROPS;
        const nowBal  = N(now?.Balance)/XRP_TO_DROPS;
        const prevOwn = N(prevInfo?.OwnerCount);
        const nowOwn  = N(now?.OwnerCount);
        const RESERVE_INC_XRP = 2;
        const freed = Math.max(0, prevOwn - nowOwn) * RESERVE_INC_XRP;
        const delta = (nowBal - prevBal).toFixed(6);
        document.getElementById('resultBox').innerHTML =
          `<div>Freed reserve: <strong>${freed.toFixed(6)} XRP</strong>. Balance change: <strong>${delta} XRP</strong>.</div>`;
      }catch{}
    }

    // ===== ADAPTERS =====
    class WalletAdapter { name='Base'; async connect(){throw new Error('not implemented');} async signAndSubmit(_tx){throw new Error('not implemented');} async disconnect(){} }

    class XummAdapter extends WalletAdapter {
      constructor(){ super(); this.name='Xumm'; this.xumm=null; }
      async connect(){
        if (typeof Xumm === 'undefined') throw new Error('Xumm SDK not loaded');
        if (!XUMM_API_KEY) throw new Error('Xumm API key missing');
        this.xumm = new Xumm(XUMM_API_KEY);
        await this.xumm.authorize();
        const acct = await this.xumm.user.account;
        if (!acct) throw new Error('No account returned');
        return { address: acct };
      }
      async signAndSubmit(txjson){
        const { resolved, websocket, unsubscribe } = await this.xumm.payload.createAndSubscribe(
          { txjson, options:{ submit:true, expire:300 } },
          ev => {
            if (ev?.opened) setStatus($walletStatus,'Open Xumm to review & sign…');
            if (ev?.signed === false) setStatus($walletStatus,'Canceled in wallet.','err');
          }
        );
        const res = await resolved;
        try{ websocket?.close(); }catch{}
        try{ typeof unsubscribe === 'function' && unsubscribe(); }catch{}
        if (!res?.signed) throw new Error('User rejected');
        return { hash: res?.txid || res?.id || '(pending)', result: 'submitted' };
      }
      async disconnect(){ try{ await this.xumm?.logout(); }catch{} }
    }

    // ===== CONNECT HELPERS =====
    function setAdapter(ad){ state.adapter = ad; }
    async function connectWith(AdapterClass){
      try{
        setStatus($walletStatus, 'Connecting…');
        const ad = new AdapterClass();
        const { address } = await ad.connect();
        state.account = address;
        setAdapter(ad);
        setStatus($walletStatus, ad.name+': '+address, 'ok');
        if ($btnDisconnect) $btnDisconnect.disabled = false;
        state.lastAccountInfo = await getAccountInfo(address);
        await fetchOffers(address);
      }catch(e){
        setStatus($walletStatus, (e && e.message) || 'Connect failed', 'err');
      }
    }
    async function disconnect(){
      try{ await state.adapter?.disconnect?.(); }catch{}
      state.account = null; state.adapter = null; state.offers = []; setProgress(0);
      $offersWrap.innerHTML = '<div class="hint">No data yet.</div>';
      setStatus($walletStatus, 'Status: Not connected');
      setStatus($offersStatus, '');
      setStatus($buyStatus, '');
      if ($btnDisconnect) $btnDisconnect.disabled = true;
    }

    // ===== CANCEL =====
    async function cancelOne(seq){
      if (!state.account || !state.adapter){ setStatus($offersStatus,'Connect wallet first.','err'); return; }
      setStatus($offersStatus, 'Preparing cancel '+seq+'…');
      try{
        const tx = { TransactionType:'OfferCancel', Account: state.account, OfferSequence: Number(seq) };
        const res = await state.adapter.signAndSubmit(tx);
        setStatus($offersStatus, `Submitted cancel ${seq}.`, 'ok');
        await fetchOffers(state.account);
        log(`tx hash: ${res.hash || '(unknown)'}`);
        return res;
      }catch(e){
        setStatus($offersStatus, 'Error: '+(e.message||e), 'err');
        throw e;
      }
    }
    async function cancelAll(){
      if (!state.account || !state.adapter){ setStatus($offersStatus,'Connect wallet first.','err'); return; }
      if (!state.offers.length){ setStatus($offersStatus,'No visible offers to cancel.'); return; }
      if (!confirm(`Cancel ${state.offers.length} offer(s)? You will approve each in your wallet.`)) return;
      const beforeInfo = state.lastAccountInfo || await getAccountInfo(state.account);
      let i = 0; const total = state.offers.length;
      for (const o of state.offers){
        i++; setProgress(Math.floor((i-1)/total*100));
        try{ await cancelOne(o.seq); }catch{}
      }
      setProgress(100);
      await beforeAfterReserveReport(state.account, beforeInfo);
      setStatus($offersStatus, 'Done.', 'ok');
    }

    // ===== XRBC TRUST + BUY =====
    const XRBC_HEX  = (XRBC.currencyHex || '').toUpperCase();
    function hexToAscii(hex){ try{ let out=''; for (let i=0;i<hex.length;i+=2){ const b=parseInt(hex.slice(i,i+2),16); if(!b) break; out+=String.fromCharCode(b); } return out || 'XRBC'; }catch{ return 'XRBC'; } }
    const XRBC_CODE = hexToAscii(XRBC_HEX);

    async function hasXRBCTrustLine(acct){
      const r = await call('account_lines', { account: acct, peer: XRBC.issuer, limit: 400 });
      const lines = r?.lines || [];
      return lines.some(l => ((l.currency||'').toUpperCase() === XRBC_CODE.toUpperCase()) || ((l.currency||'').toUpperCase() === XRBC_HEX));
    }
    async function addXRBCTrustLine(){
      if (!state.account || !state.adapter){ setStatus($buyStatus,'Connect wallet first.','err'); return; }
      setStatus($buyStatus, 'Checking trust line…');
      try{
        const exists = await hasXRBCTrustLine(state.account);
        if (exists){ setStatus($buyStatus,'XRBC trust line already exists.','ok'); return; }
        const tx = {
          TransactionType: 'TrustSet',
          Account: state.account,
          LimitAmount: { currency: XRBC_HEX, issuer: XRBC.issuer, value: "1000000000" }
        };
        await state.adapter.signAndSubmit(tx);
        setStatus($buyStatus,'TrustSet submitted. Wait for validation then retry buy.','ok');
      }catch(e){
        setStatus($buyStatus,'TrustSet error: '+(e.message||e),'err');
      }
    }
    async function pathFindBuy(acct, valueStr){
      const AMOUNT = { currency: XRBC_HEX, issuer: XRBC.issuer, value: valueStr };
      const pfWrap = await xrplRequest({
        method: 'ripple_path_find',
        params: [{
          source_account: acct,
          destination_account: acct,
          destination_amount: AMOUNT,
          source_currencies: [ { currency: "XRP" } ]
        }]
      }, {timeoutMs: 15000});
      const pf = pfWrap?.result || {};
      const alts = pf?.alternatives || [];
      if (!alts.length) throw new Error('No path found for requested amount');
      let best = null;
      for (const a of alts){
        const sa = a.source_amount;
        const drops = typeof sa === 'string'
          ? N(sa)
          : (sa && sa.currency === 'XRP' ? Math.round(N(sa.value)*XRP_TO_DROPS) : Infinity);
        if (!isFinite(drops)) continue;
        if (!best || drops < best.drops) best = { alt:a, drops };
      }
      if (!best) throw new Error('No XRP route available');
      const headroom = Math.ceil(best.drops * 1.005);
      return {
        TransactionType: "Payment",
        Account: acct,
        Destination: acct,
        Amount: AMOUNT,
        SendMax: String(headroom),
        Paths: best.alt.paths_computed || []
      };
    }
    async function buyXRBC(units){
      if (!state.account || !state.adapter){ setStatus($buyStatus,'Connect wallet first.','err'); return; }
      try{
        setStatus($buyStatus, `Preparing to buy ${units} ${XRBC_CODE}…`);
        const exists = await hasXRBCTrustLine(state.account);
        if (!exists){ setStatus($buyStatus,'No XRBC trust line. Click "Add XRBC Trust Line" first.','err'); return; }
        const tx = await pathFindBuy(state.account, String(units));
        const res = await state.adapter.signAndSubmit(tx);
        setStatus($buyStatus, `Buy submitted. Hash: ${(res && res.hash) ? res.hash : '(pending)'}`, 'ok');
      }catch(e){
        setStatus($buyStatus, (e && e.message) || 'Buy failed', 'err');
      }
    }

    // ===== WIRE UI =====
    $btnXumm?.addEventListener('click', ()=>connectWith(XummAdapter));
    $btnConnect?.addEventListener('click', async ()=>{
      try{
        $btnConnect.disabled = true;
        await connectWith(XummAdapter);
      } finally { $btnConnect.disabled = false; }
    });
    $btnDisconnect?.addEventListener('click', ()=>disconnect());

    $btnRefresh?.addEventListener('click', ()=> state.account ? fetchOffers(state.account) : setStatus($walletStatus,'Connect first.','err'));
    $btnCancelAll?.addEventListener('click', ()=>cancelAll());

    $networkSel?.addEventListener('change', ()=>{ state.network = $networkSel.value; updateNetBadge(); if (state.account) fetchOffers(state.account); });

    $btnTrust?.addEventListener('click', ()=>addXRBCTrustLine());
    $('buy1')?.addEventListener('click',   ()=>buyXRBC(1));
    $('buy25')?.addEventListener('click',  ()=>buyXRBC(25));
    $('buy50')?.addEventListener('click',  ()=>buyXRBC(50));
    $('buy100')?.addEventListener('click', ()=>buyXRBC(100));

    // Boot
    updateNetBadge();
  })();
  </script>
</body>
</html>
