<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>XRBitcoinCash ‚Äî Local Auditor (No LLM)</title>

  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/xrbc-nft.png" />
  <link rel="stylesheet" href="xrbc.css">

  <!-- AI / security metadata (unchanged) -->
  <link rel="ai-manifest" href="/universal-ai.json">
  <link rel="ai-manifest" href="/XRBitcoin/universal-ai.json">
  <link rel="security" href="/.well-known/security.txt">
  <link rel="schema.dcterms" href="/ai/schemas/universal-ai.v1.json">
  <link rel="alternate" type="application/json" href="/.well-known/ai.json">
  <link rel="source" href="/ai/provenance.json">
  <meta name="generator" content="Local Auditor (rule-based, no LLM)">
</head>

<body>
  <header>
    <div class="brand">
      <img src="/xrbc-nft.png" alt="XRBC logo" />
      <h1>XRBitcoinCash</h1>
    </div>
  </header>

  <main>
    <section class="hero">
      <div>
        <h2>üõ°Ô∏è Security Center ¬∑ Local Auditor (No LLM)</h2>
        <p class="muted">
          This widget runs entirely in your browser using deterministic rules. It fetches site manifests & XRPL data,
          then produces the same JSON rubric + short explanation ‚Äî without calling OpenAI (so no 429s).
        </p>
        <div class="button-group">
          <button id="auditToggle" class="btn primary">üîç Open Auditor</button>
        </div>
      </div>
    </section>

    <section class="card" id="auditWidget" style="display:none; margin-top:16px; padding:14px; border:2px solid rgba(0,229,255,0.2); border-radius:12px; background:#0F1724;">
      <div id="auditOutput" style="max-height:320px; overflow:auto; margin-bottom:12px; font-size:0.95rem;">
        <p class="muted">ü§ñ Ready. Ask about XRBC wallet safety, site security, XRPL standards, or liquidity.</p>
        <p class="muted small">Mode: <strong>Local / Rule-Based</strong> ‚Äî no OpenAI calls are made.</p>
      </div>

      <div style="margin-bottom:12px; display:flex; flex-wrap:wrap; gap:8px;">
        <button class="btn ghost auditQuick"
          data-q="How was this site built, and is it safe to connect my wallet here?">
          Wallet Safety
        </button>
        <button class="btn ghost auditQuick"
          data-q="Was this project built correctly on the XRP Ledger?">
          XRPL Standards
        </button>
        <button class="btn ghost auditQuick"
          data-q="How is liquidity for XRBitcoinCash provided on XRPL?">
          Liquidity
        </button>
        <button class="btn ghost auditQuick"
          data-q="Why should users trust this site?">
          Transparency
        </button>
      </div>

      <!-- Human gate + cool-down (kept) -->
      <div id="humanGate" style="margin:10px 0 12px 0; padding:12px; border:1px dashed rgba(0,229,255,0.35); border-radius:10px;">
        <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
          <button id="holdVerify" class="btn ghost" style="min-width:220px;">
            ‚è∏Ô∏è Press & Hold 2.5s to Verify Human
          </button>
          <div id="gateStatus" class="muted small" style="line-height:1.5;">
            This prevents spam bursts and keeps XRPL calls reasonable.
          </div>
        </div>
        <div id="cooldownStatus" class="muted small" style="margin-top:8px; display:none;"></div>
      </div>

      <div class="audit-input-wrap">
        <textarea id="auditInput" rows="3"
          placeholder="Ask anything ‚Äî the Local Auditor will run the checks and return a rubric..."></textarea>
        <div class="audit-buttons">
          <button id="auditSend" class="btn primary">Run Audit</button>
          <button id="auditVoice" class="btn ghost">üéôÔ∏è Voice</button>
          <a href="https://chat.openai.com/" target="_blank" rel="noopener" class="btn-glow-link">
            ‚ú® Continue in ChatGPT (optional)
          </a>
        </div>
        <p class="helper small">üíæ Local storage keeps the last few messages on this device only.</p>
      </div>
    </section>
  </main>

  <script>
  (() => {
    "use strict";

    // ===== Config (no GPT, XRPL only) =====
    const XRBC_ISSUER = "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw";
    const XRB_ISSUER  = "rGQaHbQHCsTLQtboQPwUBasXjLvk8uDbpT";
    const HEX_XRBC    = "5852626974636F696E6361736800000000000000";
    const HEX_XRB     = "5852626974636F696E0000000000000000000000";

    // Prefer public CORS-friendly XRPL cluster; fallback to your proxy root (passthrough) if needed
    const XRPL_ENDPOINTS = [
      "https://xrplcluster.com",                 // public
      "https://xrbc-frontend.onrender.com"       // your proxy (root POST) ‚Äî still not OpenAI
    ];

    // ===== Elements =====
    const auditToggle = document.getElementById("auditToggle");
    const widget      = document.getElementById("auditWidget");
    const output      = document.getElementById("auditOutput");
    const inputEl     = document.getElementById("auditInput");
    const send        = document.getElementById("auditSend");
    const voiceBtn    = document.getElementById("auditVoice");
    const quickBtns   = document.querySelectorAll(".auditQuick");

    const holdBtn       = document.getElementById("holdVerify");
    const gateStatus    = document.getElementById("gateStatus");
    const cooldownStatus= document.getElementById("cooldownStatus");

    // ===== Utils =====
    const sleep = ms => new Promise(r => setTimeout(r, ms));
    const append = html => {
      const w = document.createElement("div");
      w.className = "chat-block";
      w.innerHTML = html;
      output.appendChild(w);
      w.scrollIntoView({ behavior: "smooth", block: "nearest" });
    };
    const esc = s => String(s)
      .replace(/&/g,"&amp;").replace(/</g,"&lt;")
      .replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;");

    // ===== Local chat memory (kept) =====
    let chatHistory = [];
    try { chatHistory = JSON.parse(sessionStorage.getItem("xrbc_chat_history")||"[]") || []; }
    catch { chatHistory = []; }
    const saveChatHistory = () =>
      sessionStorage.setItem("xrbc_chat_history", JSON.stringify(chatHistory.slice(-10)));
    const renderMessage = m => {
      if (typeof m === "string") { append(m); return; }
      if (m.role === "user") {
        append(`<p><strong style="color:#9EB2D0">You:</strong> ${esc(m.content)}</p>`);
      } else if (m.role === "assistant") {
        append(`<p style="white-space:pre-line"><strong style="color:#00E5FF">Local Auditor:</strong> ${esc(m.content)}</p>`);
      }
    };
    chatHistory.slice(-10).forEach(renderMessage);

    // ===== Simple toggle =====
    auditToggle?.addEventListener("click", () => {
      const wasHidden = widget.style.display === "none" || widget.style.display === "";
      widget.style.display = wasHidden ? "block" : "none";
    });

    // ===== Lightweight fetchers =====
    async function get(url){
      try {
        const r = await fetch(url, { cache: "no-store" });
        return { ok:r.ok, status:r.status, text: await r.text() };
      } catch (e) {
        return { ok:false, status:0, text:String(e) };
      }
    }

    async function rpc(method, params = {}) {
      for (const ep of XRPL_ENDPOINTS) {
        try {
          const r = await fetch(ep, {
            method: "POST",
            headers: { "Content-Type":"application/json" },
            body: JSON.stringify({ method, params: [params] })
          });
          if (!r.ok) continue;
          const j = await r.json();
          if (j && (j.result || j.error)) return j;
        } catch (_) {}
      }
      return { error: "All XRPL endpoints failed" };
    }

    // ===== Evidence collection =====
    async function collectEvidence() {
      // Site docs: just statuses
      const [xrbcDoc, xrbDoc, aiIdx, secTxt, provDoc] = await Promise.all([
        get("/universal-ai.json"),
        get("/XRBitcoin/universal-ai.json"),
        get("/.well-known/ai.json"),
        get("/.well-known/security.txt"),
        get("/ai/provenance.json")
      ]);

      // XRPL account facts
      const xrbcInfo = await rpc("account_info", { account: XRBC_ISSUER, ledger_index:"validated" });
      const xrbInfo  = await rpc("account_info", { account: XRB_ISSUER,  ledger_index:"validated" });

      // Orderbooks (counts only)
      const bookXRB  = await rpc("book_offers", {
        taker_gets: { currency:"XRP" },
        taker_pays: { currency: HEX_XRB, issuer: XRB_ISSUER },
        ledger_index:"validated", limit:10
      });
      const bookXRBC = await rpc("book_offers", {
        taker_gets: { currency:"XRP" },
        taker_pays: { currency: HEX_XRBC, issuer: XRBC_ISSUER },
        ledger_index:"validated", limit:10
      });

      // Parse compact facts
      const lsfDisableMaster = 0x00100000;
      function parseIssuer(ai) {
        const d = ai?.result?.account_data;
        if (!d) return { ok:false };
        const flags = Number(d.Flags || 0);
        const masterDisabled = (flags & lsfDisableMaster) === lsfDisableMaster;
        const hasRegularKey  = typeof d.RegularKey === "string" && d.RegularKey.length > 0;
        return { ok:true, masterDisabled, hasRegularKey, blackholed: masterDisabled && !hasRegularKey };
      }
      const offersLen = r => Array.isArray(r?.result?.offers) ? r.result.offers.length : 0;

      // Wallet connect detection on-page
      const hasWalletUI = !!document.querySelector(
        '[href*="xumm.app"],[href*="xaman.app"],[data-wallet],.wallet-connect'
      );

      return {
        manifests: {
          xrbc_universal_ai_200: xrbcDoc.ok,
          xrb_universal_ai_200:  xrbDoc.ok,
          ai_index_200:          aiIdx.ok,
          security_txt_200:      secTxt.ok,
          provenance_200:        provDoc.ok
        },
        issuers: {
          xrbc: parseIssuer(xrbcInfo),
          xrb:  parseIssuer(xrbInfo)
        },
        orderbooks: {
          xrbc_offers: offersLen(bookXRBC),
          xrb_offers:  offersLen(bookXRB)
        },
        page: {
          wallet_connect_detection: hasWalletUI ? "present" : "absent",
          url: location.href
        }
      };
    }

    // ===== Deterministic scoring (no LLM) =====
    function score(facts) {
      const reasons = [];
      const evidence = [];

      // issuer_blackholed
      const i1 = facts.issuers.xrbc, i2 = facts.issuers.xrb;
      let ibStatus = "fail", ibDetails = "";
      const ok1 = i1?.ok && i1.masterDisabled && !i1.hasRegularKey;
      const ok2 = i2?.ok && i2.masterDisabled && !i2.hasRegularKey;
      if (ok1 && ok2) { ibStatus = "pass"; ibDetails = "Both issuers: master disabled, no RegularKey."; }
      else if ((i1?.ok && (i1.masterDisabled || !i1.hasRegularKey)) ||
               (i2?.ok && (i2.masterDisabled || !i2.hasRegularKey))) {
        ibStatus = "warn"; ibDetails = "Only one issuer fully blackholed or partial flags present.";
      } else {
        ibDetails = "Neither issuer fully blackholed.";
      }
      evidence.push({ item:"issuer_blackholed", status:ibStatus, details:ibDetails });
      if (ibStatus !== "pass") reasons.push("Issuer blackhole status not fully satisfied.");

      // manifests_accessible
      const m = facts.manifests;
      const all = [m.xrbc_universal_ai_200, m.xrb_universal_ai_200, m.security_txt_200];
      let manStatus = "fail", manDetails = "All key manifests missing.";
      if (all.filter(Boolean).length === 3) { manStatus="pass"; manDetails="XRBC & XRBitcoin manifests and security.txt are reachable."; }
      else if (all.filter(Boolean).length >= 1) { manStatus="warn"; manDetails="Some, not all, key manifests reachable."; }
      evidence.push({ item:"manifests_accessible", status:manStatus, details:manDetails });
      if (manStatus === "warn") reasons.push("Not all manifests are reachable.");
      if (manStatus === "fail") reasons.push("No manifests reachable.");

      // read_only_endpoints (in local mode, page has no write ops)
      const roStatus = "pass";
      evidence.push({ item:"read_only_endpoints", status:roStatus, details:"Local Auditor performs read-only XRPL RPC and static fetches." });

      // wallet_connect_flow
      const wcAbsent = facts.page.wallet_connect_detection === "absent";
      evidence.push({
        item:"wallet_connect_flow",
        status: wcAbsent ? "pass" : "warn",
        details: wcAbsent ? "No on-site wallet connect UI detected." : "Wallet UI present; ensure it delegates signing to a known wallet."
      });
      if (!wcAbsent) reasons.push("Wallet UI present ‚Äî verify signing flows carefully.");

      // dex_liquidity_presence
      const offers = Math.max(Number(facts.orderbooks.xrbc_offers||0), Number(facts.orderbooks.xrb_offers||0));
      let dexStatus = "fail", dexDetails = "No offers detected.";
      if (offers >= 3) { dexStatus="pass"; dexDetails=`Order book has ${offers}+ offers.`; }
      else if (offers >= 1) { dexStatus="warn"; dexDetails=`Order book has ${offers} offer(s).`; }
      evidence.push({ item:"dex_liquidity_presence", status:dexStatus, details:dexDetails });
      if (dexStatus === "warn") reasons.push("Low order-book depth.");
      if (dexStatus === "fail") reasons.push("No order-book depth detected.");

      // verdict
      const worst = [ibStatus, manStatus, roStatus, wcAbsent ? "pass":"warn", dexStatus];
      const order = { pass:0, warn:1, fail:2 };
      const maxScore = Math.max(...worst.map(s => order[s]));
      const verdict = (maxScore === 0) ? "safe" : (maxScore === 1 ? "caution" : "unsafe");

      const recommended_actions = [
        "Verify wallet signing payloads in your wallet before confirming.",
        "Bookmark the issuer accounts and re-check flags periodically.",
        "Avoid interacting with sites that request seeds or private keys."
      ];

      if (manStatus !== "pass") recommended_actions.push("Host all manifests and /.well-known/security.txt; keep them reachable.");
      if (dexStatus !== "pass") recommended_actions.push("Improve liquidity depth to strengthen DEX presence.");

      if (reasons.length === 0) reasons.push("All core checks satisfied.");

      return { verdict, reasons, evidence, recommended_actions };
    }

    function explain(rubric) {
      const v = rubric.verdict === "safe" ? "The project looks safe based on on-ledger flags, reachable manifests, and read-only behavior."
        : rubric.verdict === "caution" ? "Most checks look OK, but one or more items need attention. Review the evidence before connecting a wallet."
        : "Key checks failed (see evidence). Resolve these before connecting a wallet.";
      return v + " Always verify the signing payloads in your wallet.";
    }

    // ===== Human gate + cooldown =====
    let humanVerified = false, holdTimer = null;
    let cooldownUntil = 0;
    const MIN_COOLDOWN_MS = 60000, MAX_COOLDOWN_MS = 60000;

    function msLeft() { return Math.max(0, cooldownUntil - Date.now()); }
    function showCooldown(reason = "Pausing briefly to prevent spam and protect XRPL endpoints.") {
      const left = msLeft();
      if (left <= 0) { cooldownStatus.style.display = "none"; return; }
      cooldownStatus.style.display = "block";
      cooldownStatus.textContent = `‚è≥ ${reason} You can ask again in ${Math.ceil(left / 1000)}s.`;
    }
    function tickCooldown() {
      if (msLeft() <= 0) {
        cooldownStatus.style.display = "none";
        send.disabled = false;
        quickBtns.forEach(b => b.disabled = false);
        return;
      }
      send.disabled = true;
      quickBtns.forEach(b => (b.disabled = true));
      showCooldown();
      requestAnimationFrame(tickCooldown);
    }
    function startCooldown(ms, reason) {
      const now = Date.now();
      cooldownUntil = Math.max(cooldownUntil, now + Math.min(Math.max(ms, 1000), MAX_COOLDOWN_MS));
      tickCooldown();
      showCooldown(reason);
    }
    function requireHumanAndCooldown() {
      if (!humanVerified) {
        append(`<p class="muted small" style="color:#f88">‚ö†Ô∏è Please press and hold the ‚ÄúVerify Human‚Äù button for 2.5 seconds before asking.</p>`);
        return false;
      }
      if (msLeft() > 0) { showCooldown(); return false; }
      return true;
    }

    if (holdBtn) {
      const startHold = () => {
        if (humanVerified) return;
        holdBtn.textContent = "‚è±Ô∏è Keep holding‚Ä¶";
        gateStatus.textContent = "Verifying‚Ä¶ don‚Äôt release yet.";
        holdTimer = setTimeout(() => {
          humanVerified = true;
          holdBtn.textContent = "‚úÖ Verified Human";
          holdBtn.classList.add("glow-green");
          holdBtn.disabled = true;
          gateStatus.textContent = "Thanks! You‚Äôre verified. You can ask now.";
        }, 2500);
      };
      const cancelHold = () => {
        if (humanVerified) return;
        if (holdTimer) clearTimeout(holdTimer);
        holdTimer = null;
        holdBtn.textContent = "‚è∏Ô∏è Press & Hold 2.5s to Verify Human";
        gateStatus.textContent = "Release detected ‚Äî hold continuously until it completes.";
      };
      holdBtn.addEventListener("mousedown", startHold);
      holdBtn.addEventListener("touchstart", (e) => { e.preventDefault(); startHold(); }, { passive: false });
      ["mouseup","mouseleave","touchend","touchcancel"].forEach(evt => holdBtn.addEventListener(evt, cancelHold));
    }

    // ===== Run local audit =====
    let isBusy = false;
    async function runLocalAudit(questionText) {
      if (isBusy) return;
      isBusy = true;
      try {
        renderMessage({ role: "user", content: questionText || (inputEl.value || "").trim() || "Run audit" });
        startCooldown(MIN_COOLDOWN_MS, "Preventing rapid-fire requests.");

        const facts = await collectEvidence();
        const rubric = score(facts);
        const firstLine = JSON.stringify(rubric);
        const explanation = explain(rubric);

        const pretty =
          `üßæ <strong>Audit verdict:</strong> <code>${esc(rubric.verdict)}</code>\n\n` +
          `‚Ä¢ ${rubric.reasons.map(esc).join("\n‚Ä¢ ")}\n\n` +
          `<span class="muted">Evidence:</span> ${esc(firstLine)}\n\n` +
          explanation;

        renderMessage({ role: "assistant", content: pretty });
        chatHistory.push({ role: "assistant", content: firstLine + "\n" + explanation });
        saveChatHistory();
      } catch (err) {
        append(`<p style="color:#f88"><strong>Error:</strong> ${esc(String(err))}</p>`);
      } finally {
        isBusy = false;
      }
    }

    // ===== Controls =====
    send.addEventListener("click", () => {
      if (!requireHumanAndCooldown()) return;
      runLocalAudit();
      inputEl.value = "";
    });

    inputEl.addEventListener("keydown", e => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        send.click();
      }
    });

    quickBtns.forEach(btn =>
      btn.addEventListener("click", () => {
        if (!requireHumanAndCooldown()) return;
        runLocalAudit(btn.dataset.q);
      })
    );

    // ===== Voice (optional) =====
    if ("webkitSpeechRecognition" in window) {
      const recog = new webkitSpeechRecognition();
      recog.continuous = false;
      recog.interimResults = false;
      recog.lang = "en-US";
      voiceBtn?.addEventListener("click", () => {
        recog.start();
        voiceBtn.textContent = "üé§ Listening...";
      });
      recog.onresult = e => {
        inputEl.value = e.results[0][0].transcript;
        send.click();
      };
      recog.onend = () => { voiceBtn.textContent = "üé§ Voice"; };
    } else {
      voiceBtn && (voiceBtn.style.display = "none");
    }
  })();
  </script>
</body>
</html>
