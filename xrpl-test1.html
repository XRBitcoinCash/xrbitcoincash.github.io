<!DOCTYPE html>
<html lang="en">
<head>
  <!-- favicon -->
  <link rel="icon" href="/favicon.png" type="image/png">
  <link rel="shortcut icon" href="/favicon.png" type="image/png">
 <link rel="ai-manifest" href="/universal-ai.json">
<link rel="ai-manifest" href="/XRBitcoin/universal-ai.json">
<link rel="security" href="/.well-known/security.txt">
<link rel="schema.dcterms" href="/ai/schemas/universal-ai.v1.json">
<link rel="alternate" type="application/json" href="/.well-known/ai.json">
<link rel="source" href="/ai/provenance.json">

  <meta name="msapplication-TileImage" content="/favicon.png">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>XRBitcoinCash</title>

  <!-- Icons -->
  <link rel="icon" href="/xrbc-nft.png" />
  <link rel="apple-touch-icon" href="/xrbc-nft.png" />

  <!-- Primary SEO -->
  <meta name="description" content="XRBitcoinCash (XRBC) — fast, low-fee XRPL token with integrated ChatGPT-powered Security Center. Trade XRBC, explore NFTs, and verify wallet safety directly on-page." />
  <meta name="keywords" content="XRBC, XRPL, XRBitcoinCash, cryptocurrency, token, liquidity pool, XUMM, XPMarket, ChatGPT, AI Security Center, wallet safety, crypto transparency" />
  <link rel="canonical" href="https://xrbitcoincash.com/" />

  <!-- Acknowledgement -->
  <meta name="generator" content="Built with assistance from ChatGPT AI" />
  <meta name="credit" content="Security Center powered by ChatGPT AI — thank you to OpenAI for enabling transparent wallet safety audits." />

  <!-- Open Graph -->
  <meta property="og:type" content="website" />
  <meta property="og:title" content="XRBitcoinCash — XRBC on XRPL" />
  <meta property="og:description" content="Trade XRBC fast on XRPL. Low fees, 3s finality, and now an AI-powered Security Center by ChatGPT for wallet safety & transparency." />
  <meta property="og:image" content="https://xrbitcoincash.com/xrbc-nft.png" />
  <meta property="og:url" content="https://xrbitcoincash.com/" />

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="XRBitcoinCash — XRBC on XRPL" />
  <meta name="twitter:description" content="XRBitcoinCash now features a ChatGPT-powered Security Center — ask about wallet safety, XRPL standards, and liquidity directly on-site." />
  <meta name="twitter:image" content="https://xrbitcoincash.com/xrbc-nft.png" />

  <!-- External CSS -->
  <link rel="stylesheet" href="xrbc.css">
</head>

<body>
  <!-- 🌙 Light/Dark Mode Toggle -->
  <button class="toggle-theme" id="themeToggle">☀️</button>
  <script>
    const toggle = document.getElementById('themeToggle');
    toggle.addEventListener('click', () => {
      document.body.classList.toggle('light-mode');
      toggle.textContent = document.body.classList.contains('light-mode') ? '🌙' : '☀️';
    });
  </script>

  <header>
    <div class="brand">
      <img src="/xrbc-nft.png" alt="XRBC logo" />
     <h1>XRBitcoinCash</h1>

    </div>
  </header>


<main>
  <section class="hero">
    <div class="particles">
      <div class="particle" style="top:20%;left:10%;animation-delay:0s"></div>
      <div class="particle" style="top:50%;left:30%;animation-delay:1s"></div>
      <div class="particle" style="top:80%;left:50%;animation-delay:2s"></div>
      <div class="particle" style="top:40%;left:70%;animation-delay:3s"></div>
      <div class="particle" style="top:60%;left:90%;animation-delay:4s"></div>
    </div>
   
    <div>
      <h2>Trade XRBC fast on XRPL</h2>
      <p>Low fees. ~3s finality. Transparent, non-custodial flows — designed for fast on-ledger trading.</p>
      <div class="button-group">
        <a href="https://xrbitcoincash.com/nfts.html" class="btn primary">🎨 NFT Gallery</a>
        <a href="https://xrbitcoincash.github.io/trade.html" class="btn primary glow-green">🚀 Trade XRBC Now</a>
        <a href="https://xrbitcoincash.com/bs/" class="btn primary">Blockchain Specs</a>
        <a href="https://sologenic.org/amm/XRP_XRbitcoincash_rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw" 
           class="btn primary" target="_blank" rel="noopener noreferrer">
           💧 Sologenic Liquidity Pool
        </a>

        <a href="/whitepaper.html" class="btn ghost glow-white">Whitepaper</a>
        <a href="https://xrbitcoincash.com/about.html" class="btn ghost">About XRBC</a>
      </div>
    </div>

    <aside class="card nft glow-green">
      <img src="/xrbc-nft.png" alt="XRBitcoinCash NFT" />
      <p class="muted small" style="margin-top:10px">
        <a href="https://sologenic.org/profile/xrbitcoincash.com" target="_blank" style="color:var(--muted)">Official XRBitcoinCash artwork</a>
      </p>
    </aside>
  </section>

  <section class="grid">
    <div class="feature card">
      <h3>About XRBC</h3>
      <p class="muted">
        XRBitcoinCash (XRBC) is a fast, low-fee asset on the XRP Ledger, backed by transparent tokenomics and open governance.
        Issuer: <strong>rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw</strong>, Code: <strong>XRbitcoincash</strong>.
        With a trustline cap of <strong>20,999,999.999999996</strong>, XRBC is designed for sustainable liquidity and long-term growth.
      </p>
    </div>
    <div class="feature card">
      <h3>Trading</h3>
      <p class="muted">
        Trading on XRPL means you can exchange assets directly on-ledger without intermediaries. Using the built-in decentralized exchange (DEX),
        you can place limit orders, swap instantly through liquidity pools, or trade via automated market makers like Sologenic AMM.
      </p>
    </div>
    <div class="feature card">
      <h3>NFTs</h3>
      <p class="muted">Collections, drops, and artwork tied to XRBC.</p>
    </div>
  </section>

  <!-- Security Center -->
  <section class="card glow-red" style="margin-top:28px;">
    <h2 style="display:flex; align-items:center; gap:12px; font-size:1.4rem; color:var(--accent);">
      🛡️ Security Center · Site & Wallet Safety
    </h2>
    <p class="muted" style="margin-top:8px; font-size:1rem;">
      Powered by <strong style="color:var(--accent);">ChatGPT AI</strong>.<br>
      Ask about the safety of connecting your wallet, how this site was built, XRBC’s compliance with XRPL standards, and liquidity transparency.
    </p>
    <button id="auditToggle" class="btn cta" style="margin-top:14px;">🔍 Ask ChatGPT Now</button>
<p class="muted" style="margin-top:12px; font-size:0.95rem; line-height:1.6; border-left:3px solid var(--accent); padding-left:12px; background:rgba(0,229,255,0.04); border-radius:6px;">
  💾 <strong>Local Storage Active:</strong> This page securely uses local storage to enhance your on-page Q&amp;A experience.  
  It keeps short-term chat memory available while you explore project details — ensuring smoother, more relevant responses.  
  All information remains private on your device and is never shared externally.
</p>

  <!-- ChatGPT Auditor widget (must exist for the button to work) -->
<div id="auditWidget" style="display:none; margin-top:16px; padding:14px; border:2px solid rgba(0,229,255,0.2); border-radius:12px; background:#0F1724;">
  <div id="auditOutput" style="max-height:260px; overflow:auto; margin-bottom:12px; font-size:0.95rem;">
    <p class="muted">🤖 Ready. Ask about XRBC wallet safety, site security, XRPL standards, or liquidity.</p>
  </div>

  <!-- Quick questions (optional) -->
  <div style="margin-bottom:12px; display:flex; flex-wrap:wrap; gap:8px;">
    <button class="btn ghost auditQuick" 
      data-q="How was this site built, and is it safe to connect my wallet here? Please explain whether the page contains any hidden or malicious code, how wallet connections are handled, and why users can trust this site.">
      Wallet Safety
    </button>

    <button class="btn ghost auditQuick" 
      data-q="Was this project built correctly on the XRP Ledger? Does it meet XRPL standards for issued tokens, trustlines, and decentralized trading?">
      XRPL Standards
    </button>

    <button class="btn ghost auditQuick" 
      data-q="How is liquidity for XRBitcoinCash provided on XRPL, and what makes it reliable for trading?">
      Liquidity
    </button>

    <button class="btn ghost auditQuick" 
      data-q="What makes this project safer than others? Please explain transparency, control of supply, and how users can verify everything on-ledger.">
      Transparency
    </button>
  </div>
<!-- ✅ HUMAN CHECK + STATUS (anti-spam, free, no keys) -->
<div id="humanGate" style="margin:10px 0 12px 0; padding:12px; border:1px dashed rgba(0,229,255,0.35); border-radius:10px;">
  <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
    <button id="holdVerify" class="btn ghost" style="min-width:220px;">
      ⏸️ Press & Hold 2.5s to Verify Human
    </button>
    <div id="gateStatus" class="muted small" style="line-height:1.5;">
      This prevents spam bursts that could hit rate limits. Releasing early cancels.
    </div>
  </div>
  <div id="cooldownStatus" class="muted small" style="margin-top:8px; display:none;"></div>
</div>

<div class="audit-input-wrap">
  <textarea id="auditInput"
            placeholder="Ask about XRBC, XRBitcoin, or wallet safety..."
            rows="3"></textarea>

  <!-- row of main buttons -->


  <div class="audit-buttons">
    <button id="auditSend" class="btn primary">Send</button>
    <button id="auditVoice" class="btn ghost">🎙️ Voice</button>
    <a href="https://chat.openai.com/"
       target="_blank"
       rel="noopener"
       class="btn-glow-link">✨ Continue in ChatGPT</a>
  </div>

  <p class="helper small">
    💬 For deeper or extended chats, tap “Continue in ChatGPT”.
  </p>
</div>


  <p class="muted small" style="margin-top:8px; font-size:0.8rem;">🎙️ Use your mic to ask verbally (Chrome recommended).</p>
</div>

  
  </section>
</main>

<footer class="ecosystem-footer">
  <div class="footer-container">
    <h3>XRBitcoin Ecosystem</h3>
    <p class="ecosystem-desc">
      Interlinked XRPL-based assets — XRBitcoinCash (XRBC), XRBitcoin, and Jesus Christ Saves Token (JCS).
    </p>

    <div class="ecosystem-links">
      <a href="https://xrbitcoincash.com" class="eco-link" target="_blank" rel="noopener">
        <img src="/xrbc-nft.png" alt="XRBitcoinCash logo">
        <span>XRBitcoinCash</span>
      </a>

      <a href="/XRBitcoin/" class="eco-link" target="_blank" rel="noopener">
        <img src="/XRBitcoin/xrbitcoin-logo.png" alt="XRBitcoin logo">
        <span>XRBitcoin</span>
      </a>

      <a href="https://jesuschristsavestoken.com/" class="eco-link" target="_blank" rel="noopener">
        <img src="/JCS-token-on-the-XRPL/jcs-logo.png" alt="Jesus Christ Saves Token logo">
        <span>Jesus Christ Saves</span>
      </a>

      <a href="https://x.com/XRbitcoincash" target="_blank" class="eco-link" rel="noopener">
        <img src="https://upload.wikimedia.org/wikipedia/commons/6/6f/Logo_of_Twitter.svg" alt="Twitter" style="width:22px; height:22px;">
        <span>Twitter</span>
      </a>

      <!-- 🔐 Security Roles link -->
      <a href="/security-jobs.html" class="eco-link" target="_blank" rel="noopener">
        <img src="/xrbc-nft.png" alt="Security logo" style="width:28px; height:28px;">
        <span>Security Roles</span>
      </a>
    </div>

    <p class="ecosystem-tagline"><strong>Built on the XRP Ledger.</strong></p>
  </div>
</footer>
<!-- 🔐 Security Recertification Countdown -->
<p style="text-align:center; color:var(--muted); font-size:0.9rem; margin-top:8px;">
  🔐 Security Recertification: <span id="updateCountdown">Loading...</span>
</p>
<!-- AI / Security badges (optional, human-facing) -->
<nav class="ai-badges" style="margin-top:12px;font-size:0.95rem;opacity:0.9">
  <a href="/universal-ai.json" rel="nofollow">XRBC AI Manifest</a> ·
  <a href="/XRBitcoin/universal-ai.json" rel="nofollow">XRBitcoin AI Manifest</a> ·
  <a href="/.well-known/ai.json" rel="nofollow">AI Index</a> ·
  <a href="/ai/provenance.json" rel="nofollow">Provenance</a> ·
  <a href="/.well-known/security.txt" rel="nofollow">Security.txt</a>
</nav>

<script>
(() => {
  "use strict";

  /* ========= 1) SCROLL FADE-IN ========= */
  const features = document.querySelectorAll(".feature");
  const fadeObserver = new IntersectionObserver(
    entries => entries.forEach(e => {
      if (e.isIntersecting) {
        e.target.classList.add("visible");
        fadeObserver.unobserve(e.target);
      }
    }),
    { threshold: 0.2 }
  );
  features.forEach(f => fadeObserver.observe(f));

  /* ========= 2) CONFIG ========= */
  const PROXY = "https://xrbc-frontend.onrender.com";
  const CHAT_PATH = "/chat";     // proxy expects Chat-style payloads
  const RPC_PATH  = "/";         // XRPL passthrough on proxy (root POST)

  // Prefer o3-mini; proxy can map headers to Responses upstream.
  const MODEL_PREFERRED = "o3-mini-2025-01-31";
  const MODEL_FALLBACK  = "gpt-5-mini"; // chat-friendly, higher limits than base

  const FALLBACK_URL = "https://chat.openai.com/?model=o3-mini-2025-01-31";
  const FALLBACK_WEB3_URL = "https://chatgpt.eth.link/";
  const MAX_WAIT_MS = 52000;

  // XRPL issuers & currency hex
  const XRBC_ISSUER = "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw";
  const XRB_ISSUER  = "rGQaHbQHCsTLQtboQPwUBasXjLvk8uDbpT";
  const HEX_XRBC    = "5852626974636F696E6361736800000000000000";
  const HEX_XRB     = "5852626974636F696E0000000000000000000000";

  /* ========= 3) ELEMENTS ========= */
  const auditToggle = document.getElementById("auditToggle");
  const widget   = document.getElementById("auditWidget");
  const output   = document.getElementById("auditOutput");
  const inputEl  = document.getElementById("auditInput");
  const send     = document.getElementById("auditSend");
  const voiceBtn = document.getElementById("auditVoice");
  const quickBtns= document.querySelectorAll(".auditQuick");

  // Human gate
  const holdBtn = document.getElementById("holdVerify");
  const gateStatus = document.getElementById("gateStatus");
  const cooldownStatus = document.getElementById("cooldownStatus");

  let keepAliveInterval = null;
  let proxyTimedOut = false;

  /* ========= 4) UTILS ========= */
  const sleep = ms => new Promise(r => setTimeout(r, ms));
  const append = html => {
    const w = document.createElement("div");
    w.className = "chat-block";
    w.innerHTML = html;
    output.appendChild(w);
    w.scrollIntoView({ behavior: "smooth", block: "nearest" });
  };
  const esc = s => String(s)
    .replace(/&/g,"&amp;").replace(/</g,"&lt;")
    .replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;");

  /* ========= 5) LOCAL CHAT MEMORY ========= */
  let chatHistory = [];
  try {
    const raw = JSON.parse(sessionStorage.getItem("xrbc_chat_history") || "[]");
    chatHistory = Array.isArray(raw) ? raw : [];
  } catch { chatHistory = []; }
  const saveChatHistory = () =>
    sessionStorage.setItem("xrbc_chat_history", JSON.stringify(chatHistory.slice(-10)));
  const renderMessage = m => {
    if (typeof m === "string") { append(m); return; }
    if (m.role === "user") {
      append(`<p><strong style="color:#9EB2D0">You:</strong> ${esc(m.content)}</p>`);
    } else if (m.role === "assistant") {
      append(`<p style="white-space:pre-line"><strong style="color:#00E5FF">AI Auditor:</strong> ${esc(m.content)}</p>`);
    }
  };
  chatHistory.slice(-10).forEach(renderMessage);

  /* ========= 6) WAKE PROXY ========= */
  async function wakeProxy(maxMs = MAX_WAIT_MS) {
    const start = Date.now();
    let attempt = 0;
    append(`<p id="wakeStatus" style="color:#888;">🕓 Waking secure AI proxy...</p>`);
    while (Date.now() - start < maxMs) {
      attempt++;
      try {
        const status = document.getElementById("wakeStatus");
        if (status) status.innerHTML = `🟡 Attempt ${attempt}: contacting secure XRBC proxy...`;
        const ctrl = new AbortController();
        const t = setTimeout(() => ctrl.abort(), 12000);
        const r = await fetch(`${PROXY}/healthz?ts=${Date.now()}`, { cache: "no-store", signal: ctrl.signal });
        clearTimeout(t);
        if (r.ok) {
          if (status) status.innerHTML = `✅ Proxy online after ${attempt} attempt${attempt>1?"s":""}.`;
          await sleep(800);
          status?.remove();
          return true;
        }
      } catch {}
      const delay = Math.min(10000, Math.round(600 * Math.pow(1.7, attempt)));
      await sleep(delay);
    }
    const status = document.getElementById("wakeStatus");
    if (status) status.innerHTML = `❌ Proxy not responding (after ${attempt} attempts).`;
    return false;
  }

  async function resolveChatGPTLink() {
    try {
      await fetch(FALLBACK_URL, { method: "HEAD", mode: "no-cors" });
      return FALLBACK_URL;
    } catch { return FALLBACK_WEB3_URL; }
  }

  async function showFallback() {
    proxyTimedOut = true;
    widget.style.display = "block";
    const fallbackLink = await resolveChatGPTLink();
    append(`
      <div style="border:1px solid rgba(0,229,255,0.25); border-radius:12px; padding:16px; background:#101820; margin-top:10px;">
        <p style="color:#9EB2D0;">⚠️ The secure XRBC proxy is currently unavailable or still waking up.<br><br>
        You can continue your conversation directly with ChatGPT below:</p>
        <div style="text-align:center;margin-top:14px;">
          <a href="${fallbackLink}" target="_blank" class="btn primary glow-blue">💬 Open ChatGPT Fallback</a>
        </div>
        <p style="margin-top:10px; color:#777; font-size:0.85rem;">
          Tip: Render free plans can take 30–45 seconds to start after inactivity. If you retry in a moment, the integrated Security Center should come online automatically.
        </p>
      </div>
    `);
  }

  /* ========= 7) TOGGLE WIDGET ========= */
  auditToggle.addEventListener("click", async () => {
    const wasHidden = widget.style.display === "none" || widget.style.display === "";
    widget.style.display = wasHidden ? "block" : "none";
    if (!wasHidden) { clearInterval(keepAliveInterval); keepAliveInterval = null; return; }

    const proxyReady = await Promise.race([ wakeProxy(MAX_WAIT_MS), sleep(MAX_WAIT_MS + 2000).then(() => false) ]);
    if (!proxyReady) { showFallback(); return; }

    keepAliveInterval = setInterval(() => {
      fetch(`${PROXY}/healthz?ts=${Date.now()}`).catch(() => {});
    }, 60000);
  });

  /* ========= 8) EVIDENCE-GATHERING ========= */
  async function get(url){
    try {
      const r = await fetch(url, { cache: "no-store" });
      return { ok:r.ok, status:r.status, text: await r.text() };
    } catch (e) {
      return { ok:false, status:0, text:String(e) };
    }
  }
  async function rpc(method, params = {}) {
    try {
      const r = await fetch(`${PROXY}${RPC_PATH}`, {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify({ method, params: [params] })
      });
      if (!r.ok) return { error: await r.text(), status: r.status };
      return await r.json();
    } catch (e) {
      return { error: String(e) };
    }
  }

  const SYSTEM = {
    role: "system",
    content:
`You are an impartial XRPL site auditor.
Use only the provided evidence (site manifests, security.txt, provenance, and on-ledger XRPL data).
If a fact cannot be verified, state what is missing and how to verify it.
Never ask for seeds or secret keys. Remind users to verify wallet signing payloads in their wallet.
Be concise and specific.`
  };

  const INSTRUCTIONS = {
    role: "user",
    content:
`Return two parts:

1) JSON-RUBRIC ONLY on the first line:
{
  "verdict": "safe|caution|unsafe",
  "reasons": ["..."],
  "evidence": [
    {"item":"issuer_blackholed","status":"pass|warn|fail","details":"..."},
    {"item":"manifests_accessible","status":"pass|warn|fail","details":"..."},
    {"item":"read_only_endpoints","status":"pass|warn|fail","details":"..."},
    {"item":"wallet_connect_flow","status":"pass|warn|fail","details":"..."},
    {"item":"dex_liquidity_presence","status":"pass|warn|fail","details":"..."}
  ],
  "recommended_actions": ["..."]
}

Scoring details:
- issuer_blackholed = pass if AccountRoot shows master disabled AND no RegularKey; warn if only one holds; fail otherwise.
- manifests_accessible = pass if universal-ai.json (XRBC + XRBitcoin) and /.well-known/security.txt return 200; warn if any missing; fail if all missing.
- read_only_endpoints = pass if endpoints list only read-only XRPL methods; warn if unclear; fail if mutating methods present.
- wallet_connect_flow = "pass" if wallet_connect_detection == "absent" OR if a connect UI exists but delegates signing entirely to a known wallet app and never asks for seeds/secret keys; "warn" only if a connect UI exists but behavior is unclear; "fail" only if any component requests seeds/secret keys or auto-initiates signing.
- dex_liquidity_presence = pass if an AMM pool exists OR book_offers >= 3; warn if 1–2; fail if none/errored.

2) Then a short human explanation (3–6 sentences).`
  };

  async function collectEvidence() {
    const [xrbc, xrb, idx, sec, prov] = await Promise.all([
      get("/universal-ai.json"),
      get("/XRBitcoin/universal-ai.json"),
      get("/.well-known/ai.json"),
      get("/.well-known/security.txt"),
      get("/ai/provenance.json")
    ]);

    async function issuerFacts(account){
      const info = await rpc("account_info", { account, ledger_index:"validated" });
      const objs = await rpc("account_objects", { account, type:"signer_list", ledger_index:"validated" });
      return { info, objs };
    }
    const [xrbcLedger, xrbLedger] = await Promise.all([
      issuerFacts(XRBC_ISSUER),
      issuerFacts(XRB_ISSUER)
    ]);

    const bookXRB  = await rpc("book_offers", {
      taker_gets: { currency:"XRP" },
      taker_pays: { currency: HEX_XRB, issuer: XRB_ISSUER },
      ledger_index:"validated", limit:10
    });
    const bookXRBC = await rpc("book_offers", {
      taker_gets: { currency:"XRP" },
      taker_pays: { currency: HEX_XRBC, issuer: XRBC_ISSUER },
      ledger_index:"validated", limit:10
    });

    const hasWalletUI = !!document.querySelector(
      '[href*="xumm.app"],[href*="xaman.app"],[data-wallet],.wallet-connect'
    );
    const walletConnectDetection = hasWalletUI ? "present" : "absent";

    const pageFp = {
      url: location.href,
      wallet_connect_detection: walletConnectDetection,
      outboundExchanges: Array.from(document.querySelectorAll('a[href*="sologenic.org"],a[href*="xpmarket.com"]')).map(a=>a.href),
      canonical: (document.querySelector('link[rel="canonical"]')||{}).href || null
    };

    return {
      role: "user",
      content:
`EVIDENCE:
- xrbc_manifest (status ${xrbc.status}):\n${xrbc.text}
- xrbitcoin_manifest (status ${xrb.status}):\n${xrb.text}
- ai_index (status ${idx.status}):\n${idx.text}
- security_txt (status ${sec.status}):\n${sec.text}
- provenance (status ${prov.status}):\n${prov.text}

- on_ledger:
  xrbc_account_info:\n${JSON.stringify(xrbcLedger.info, null, 2)}
  xrbc_account_objects:\n${JSON.stringify(xrbcLedger.objs, null, 2)}
  xrbitcoin_account_info:\n${JSON.stringify(xrbLedger.info, null, 2)}
  xrbitcoin_account_objects:\n${JSON.stringify(xrbLedger.objs, null, 2)}
  book_offers_xrbitcoin:\n${JSON.stringify(bookXRB, null, 2)}
  book_offers_xrbc:\n${JSON.stringify(bookXRBC, null, 2)}

- page_fingerprint:\n${JSON.stringify(pageFp, null, 2)}`
    };
  }

  /* ========= 9) HUMAN GATE + COOLDOWN ========= */
  let humanVerified = false;
  let holdTimer = null;

  let cooldownUntil = 0;
  const MIN_COOLDOWN_MS = 8000;
  const MAX_COOLDOWN_MS = 60000;

  function msLeft() { return Math.max(0, cooldownUntil - Date.now()); }
  function showCooldown(reason = "Pausing briefly to prevent spam and protect the model’s rate limits.") {
    const left = msLeft();
    if (!cooldownStatus) return;
    if (left <= 0) { cooldownStatus.style.display = "none"; return; }
    cooldownStatus.style.display = "block";
    cooldownStatus.textContent = `⏳ ${reason} You can ask again in ${Math.ceil(left / 1000)}s.`;
  }
  function tickCooldown() {
    if (msLeft() <= 0) {
      if (cooldownStatus) cooldownStatus.style.display = "none";
      if (send) send.disabled = false;
      quickBtns.forEach(b => b.disabled = false);
      return;
    }
    if (send) send.disabled = true;
    quickBtns.forEach(b => (b.disabled = true));
    showCooldown();
    requestAnimationFrame(tickCooldown);
  }
  function startCooldown(ms, reason) {
    const now = Date.now();
    cooldownUntil = Math.max(cooldownUntil, now + Math.min(Math.max(ms, 1000), MAX_COOLDOWN_MS));
    tickCooldown();
    showCooldown(reason);
  }
  function requireHumanAndCooldown() {
    if (!humanVerified) {
      append(`<p class="muted small" style="color:#f88">⚠️ Please press and hold the “Verify Human” button for 2.5 seconds before asking. This blocks spam and protects the model limits.</p>`);
      return false;
    }
    if (msLeft() > 0) { showCooldown(); return false; }
    return true;
  }

  if (holdBtn) {
    const startHold = () => {
      if (humanVerified) return;
      holdBtn.textContent = "⏱️ Keep holding…";
      if (gateStatus) gateStatus.textContent = "Verifying… don’t release yet.";
      holdTimer = setTimeout(() => {
        humanVerified = true;
        holdBtn.textContent = "✅ Verified Human";
        holdBtn.classList.add("glow-green");
        holdBtn.disabled = true;
        if (gateStatus) gateStatus.textContent = "Thanks! You’re verified. You can ask now.";
      }, 2500);
    };
    const cancelHold = () => {
      if (humanVerified) return;
      if (holdTimer) clearTimeout(holdTimer);
      holdTimer = null;
      holdBtn.textContent = "⏸️ Press & Hold 2.5s to Verify Human";
      if (gateStatus) gateStatus.textContent = "Release detected — hold continuously until it completes.";
    };
    holdBtn.addEventListener("mousedown", startHold);
    holdBtn.addEventListener("touchstart", (e) => { e.preventDefault(); startHold(); }, { passive: false });
    ["mouseup","mouseleave","touchend","touchcancel"].forEach(evt => holdBtn.addEventListener(evt, cancelHold));
  }

  /* ========= 10) GPT CALL — Chat only (fixes 400 “messages” error) ========= */
  async function callChat(model, messages) {
    const ctrl = new AbortController();
    const timer = setTimeout(() => ctrl.abort(), 60000);

    const res = await fetch(`${PROXY}${CHAT_PATH}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        // Hints to your proxy so it can map to Responses upstream if desired:
        "X-Model-Hint": model,
        "X-Wire-Hint": "chat"
      },
      body: JSON.stringify({
        model,                   // your proxy can remap this to Responses internally
        temperature: 0.2,
        messages                 // ALWAYS include messages[] to satisfy proxy schema
      }),
      signal: ctrl.signal
    }).catch(e => ({ ok: false, status: 0, _err: String(e) }));

    clearTimeout(timer);
    return res;
  }

  async function parseChatResponse(res) {
    const raw = await res.text();
    try {
      const data = JSON.parse(raw);
      return (
        data.choices?.[0]?.message?.content ??
        data.output_text ?? // if proxy remapped to Responses and normalized
        raw
      );
    } catch { return raw || "No answer (proxy connected but returned empty)."; }
  }

  async function postChat(q) {
    if (proxyTimedOut) {
      append(`<p style="color:#f88"><strong>Note:</strong> Proxy fallback mode active — please use the backup chat above.</p>`);
      return;
    }

    renderMessage({ role: "user", content: q });
    chatHistory.push({ role: "user", content: q });
    saveChatHistory();

    const spinnerId = "spinner-" + Date.now();
    append(`<p id="${spinnerId}" style="color:#9EB2D0">⏳ Connecting to XRBC Auditor…</p>`);

    const awake = await wakeProxy();
    if (!awake) { document.getElementById(spinnerId)?.remove(); showFallback(); return; }
    document.getElementById(spinnerId)?.remove();

    try {
      startCooldown(8000, "Preventing rapid-fire requests.");

      const evidenceMsg = await collectEvidence();
      const messages = [
        { role: "system", content: SYSTEM.content },
        evidenceMsg,
        INSTRUCTIONS,
        ...chatHistory.slice(-6),
        { role: "user", content: q }
      ];

      // 1) Try preferred model (chat)
      let res = await callChat(MODEL_PREFERRED, messages);

      // If the proxy complains about messages array, try a minimal echo to prove shape
      if (!res.ok) {
        const body = await res.text().catch(()=> "");
        const low = (body || "").toLowerCase();
        if (low.includes("missing") && low.includes("messages")) {
          // minimal schema probe
          const probe = await callChat(MODEL_PREFERRED, [
            { role: "system", content: "You are a concise assistant." },
            { role: "user", content: "Say: OK" }
          ]);
          if (!probe.ok) {
            // 2) Fallback model (chat)
            res = await callChat(MODEL_FALLBACK, messages);
          } else {
            // probe passed; re-try full payload once (maybe transient)
            res = await callChat(MODEL_PREFERRED, messages);
          }
        } else if (res.status === 404 || low.includes("model not found")) {
          // 2) Fallback model (chat)
          res = await callChat(MODEL_FALLBACK, messages);
        } else {
          // keep original res for handling below
          res = { ok: false, status: res.status, _body: body };
        }
      }

      if (!res.ok) {
        const body = res._body || (await res.text().catch(()=> "")) || res._err || "";
        const low = (body || "").toLowerCase();
        const retryAfterSec = Number(res.headers?.get?.("retry-after") || 0);
        let ms = retryAfterSec ? retryAfterSec * 1000 : 15000;
        ms = Math.max(5000, Math.min(ms, 120000)); // clamp 5s..120s

        if (res.status === 429 || low.includes("rate limit")) {
          startCooldown(ms, "Server is pausing to protect model limits.");
          append(`<p style="color:#f88"><strong>Temporarily Paused:</strong> Throttling for ${Math.ceil(ms/1000)}s.</p>`);
        } else {
          append(`<p style="color:#f88"><strong>Upstream error:</strong> ${res.status || ""} ${esc(body || "Unknown error")}</p>`);
          startCooldown(10000, "Cooling down briefly after an error.");
        }
        return;
      }

      let ans = await parseChatResponse(res);

      // Wallet-connect absent => force PASS on that evidence item if JSON rubric present
      try {
        const walletAbsent = /"wallet_connect_detection"\s*:\s*"absent"/.test(messages[1]?.content || "");
        const [first, ...rest] = ans.split("\n");
        const rubric = JSON.parse(first.trim());
        if (walletAbsent) {
          const wItem = Array.isArray(rubric.evidence) ? rubric.evidence.find(e => e.item === "wallet_connect_flow") : null;
          if (wItem && wItem.status !== "pass") {
            wItem.status = "pass";
            wItem.details = "No on-site wallet connect UI detected; lowest exposure.";
            rubric.reasons = Array.from(new Set((rubric.reasons || []).concat("No on-site wallet connect UI; lowest exposure.")));
            ans = JSON.stringify(rubric) + "\n" + rest.join("\n");
          }
        }
      } catch { /* ignore parse issues */ }

      // Pretty print if the first line is JSON
      let pretty = ans;
      try {
        const [fl, ...rest] = ans.split("\n");
        const rubric = JSON.parse(fl.trim());
        pretty = `🧾 <strong>Audit verdict:</strong> <code>${esc(rubric.verdict)}</code>\n\n` +
                 `• ${rubric.reasons.map(esc).join("\n• ")}\n\n` +
                 rest.join("\n");
      } catch {}

      renderMessage({ role: "assistant", content: pretty });
      startCooldown(8000, "Preventing rapid-fire requests.");
      chatHistory.push({ role: "assistant", content: ans });
      saveChatHistory();

    } catch (err) {
      startCooldown(12000, "Cooling down after a network error.");
      showFallback();
    }
  }

  /* ========= 11) INPUT/CONTROLS ========= */
  send.addEventListener("click", () => {
    if (!requireHumanAndCooldown()) return;
    const q = (inputEl.value || "").trim();
    if (!q) return;
    inputEl.value = "";
    postChat(q);
  });

  inputEl.addEventListener("keydown", e => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      send.click();
    }
  });

  quickBtns.forEach(btn =>
    btn.addEventListener("click", () => {
      if (!requireHumanAndCooldown()) return;
      postChat(btn.dataset.q);
    })
  );

  /* ========= 12) VOICE ========= */
  if ("webkitSpeechRecognition" in window) {
    const recog = new webkitSpeechRecognition();
    recog.continuous = false;
    recog.interimResults = false;
    recog.lang = "en-US";
    voiceBtn.addEventListener("click", () => {
      recog.start();
      voiceBtn.textContent = "🎤 Listening...";
    });
    recog.onresult = e => {
      inputEl.value = e.results[0][0].transcript;
      send.click();
    };
    recog.onend = () => { voiceBtn.textContent = "🎤 Voice"; };
  } else {
    voiceBtn.style.display = "none";
  }

  /* ========= 13) CLEANUP ========= */
  window.addEventListener("beforeunload", () => clearInterval(keepAliveInterval));
})();
</script>





</body>
</html>
