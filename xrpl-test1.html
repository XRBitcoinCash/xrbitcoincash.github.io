<script>
(() => {
  "use strict";

  // ===== 1) SCROLL FADE-IN (unchanged) =====
  const features = document.querySelectorAll(".feature");
  const fadeObserver = new IntersectionObserver(
    entries => entries.forEach(e => {
      if (e.isIntersecting) {
        e.target.classList.add("visible");
        fadeObserver.unobserve(e.target);
      }
    }),
    { threshold: 0.2 }
  );
  features.forEach(f => fadeObserver.observe(f));

  // ===== 2) CONFIG (mostly unchanged) =====
  const PROXY = "https://xrbc-frontend.onrender.com"; // your secure proxy
  const CHAT_PATH = "/chat";                           // chat endpoint on your proxy
  const RPC_PATH  = "/";                               // XRPL passthrough on your proxy (root POST)
  const FALLBACK_URL = "https://chat.openai.com/?model=gpt-5";
  const FALLBACK_WEB3_URL = "https://chatgpt.eth.link/";
  const MAX_WAIT_MS = 52000;

  // XRPL issuers & currency hex (from your manifests)
  const XRBC_ISSUER = "rEjwniYhYR5QDZzK1a1x2359j8j8N43Ypw";
  const XRB_ISSUER  = "rGQaHbQHCsTLQtboQPwUBasXjLvk8uDbpT";
  const HEX_XRBC    = "5852626974636F696E6361736800000000000000";
  const HEX_XRB     = "5852626974636F696E0000000000000000000000";

  // ===== 3) ELEMENTS (renamed auditToggle to avoid collision) =====
  const auditToggle = document.getElementById("auditToggle");
  const widget   = document.getElementById("auditWidget");
  const output   = document.getElementById("auditOutput");
  const inputEl  = document.getElementById("auditInput");
  const send     = document.getElementById("auditSend");
  const voiceBtn = document.getElementById("auditVoice");
  const quickBtns= document.querySelectorAll(".auditQuick");

  // Human gate elements (already in your HTML)
  const holdBtn = document.getElementById("holdVerify");
  const gateStatus = document.getElementById("gateStatus");
  const cooldownStatus = document.getElementById("cooldownStatus");

  let keepAliveInterval = null;
  let proxyTimedOut = false;

  // ===== 4) UTILS (unchanged) =====
  const sleep = ms => new Promise(r => setTimeout(r, ms));
  const append = html => {
    const w = document.createElement("div");
    w.className = "chat-block";
    w.innerHTML = html;
    output.appendChild(w);
    w.scrollIntoView({ behavior: "smooth", block: "nearest" });
  };
  const esc = s => String(s)
    .replace(/&/g,"&amp;").replace(/</g,"&lt;")
    .replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;");

  // ===== 5) LOCAL CHAT MEMORY (unchanged) =====
  let chatHistory = [];
  try {
    const raw = JSON.parse(sessionStorage.getItem("xrbc_chat_history") || "[]");
    chatHistory = Array.isArray(raw) ? raw : [];
  } catch { chatHistory = []; }
  const saveChatHistory = () =>
    sessionStorage.setItem("xrbc_chat_history", JSON.stringify(chatHistory.slice(-10)));
  const renderMessage = m => {
    if (typeof m === "string") { append(m); return; }
    if (m.role === "user") {
      append(`<p><strong style="color:#9EB2D0">You:</strong> ${esc(m.content)}</p>`);
    } else if (m.role === "assistant") {
      append(`<p style="white-space:pre-line"><strong style="color:#00E5FF">AI Auditor:</strong> ${esc(m.content)}</p>`);
    }
  };
  chatHistory.slice(-10).forEach(renderMessage);

  // ===== 6) WAKE PROXY (unchanged) =====
  async function wakeProxy(maxMs = MAX_WAIT_MS) {
    const start = Date.now();
    let attempt = 0;
    append(`<p id="wakeStatus" style="color:#888;">üïì Waking secure AI proxy...</p>`);
    while (Date.now() - start < maxMs) {
      attempt++;
      try {
        const status = document.getElementById("wakeStatus");
        if (status) status.innerHTML = `üü° Attempt ${attempt}: contacting secure XRBC proxy...`;
        const ctrl = new AbortController();
        const t = setTimeout(() => ctrl.abort(), 12000);
        const r = await fetch(`${PROXY}/healthz?ts=${Date.now()}`, { cache: "no-store", signal: ctrl.signal });
        clearTimeout(t);
        if (r.ok) {
          if (status) status.innerHTML = `‚úÖ Proxy online after ${attempt} attempt${attempt>1?"s":""}.`;
          await sleep(800);
          status?.remove();
          return true;
        }
      } catch {}
      const delay = Math.min(10000, Math.round(600 * Math.pow(1.7, attempt)));
      await sleep(delay);
    }
    const status = document.getElementById("wakeStatus");
    if (status) status.innerHTML = `‚ùå Proxy not responding (after ${attempt} attempts).`;
    return false;
  }

  async function resolveChatGPTLink() {
    try {
      await fetch(FALLBACK_URL, { method: "HEAD", mode: "no-cors" });
      return FALLBACK_URL;
    } catch { return FALLBACK_WEB3_URL; }
  }

  async function showFallback() {
    proxyTimedOut = true;
    widget.style.display = "block";
    const fallbackLink = await resolveChatGPTLink();
    append(`
      <div style="border:1px solid rgba(0,229,255,0.25); border-radius:12px; padding:16px; background:#101820; margin-top:10px;">
        <p style="color:#9EB2D0;">‚ö†Ô∏è The secure XRBC proxy is currently unavailable or still waking up.<br><br>
        You can continue your conversation directly with ChatGPT below:</p>
        <div style="text-align:center;margin-top:14px;">
          <a href="${fallbackLink}" target="_blank" class="btn primary glow-blue">üí¨ Open ChatGPT Fallback</a>
        </div>
        <p style="margin-top:10px; color:#777; font-size:0.85rem;">
          Tip: Render free plans can take 30‚Äì45 seconds to start after inactivity. If you retry in a moment, the integrated Security Center should come online automatically.
        </p>
      </div>
    `);
  }

  // ===== 7) TOGGLE WIDGET (renamed variable) =====
  auditToggle.addEventListener("click", async () => {
    const wasHidden = widget.style.display === "none" || widget.style.display === "";
    widget.style.display = wasHidden ? "block" : "none";
    if (!wasHidden) { clearInterval(keepAliveInterval); keepAliveInterval = null; return; }

    const proxyReady = await Promise.race([ wakeProxy(MAX_WAIT_MS), sleep(MAX_WAIT_MS + 2000).then(() => false) ]);
    if (!proxyReady) { showFallback(); return; }

    keepAliveInterval = setInterval(() => {
      fetch(`${PROXY}/healthz?ts=${Date.now()}`).catch(() => {});
    }, 60000);
  });

  // ===== 8) EVIDENCE-GATHERING (with explicit wallet flag) =====
  async function get(url){
    try {
      const r = await fetch(url, { cache: "no-store" });
      return { ok:r.ok, status:r.status, text: await r.text() };
    } catch (e) {
      return { ok:false, status:0, text:String(e) };
    }
  }
  async function rpc(method, params = {}) {
    try {
      const r = await fetch(`${PROXY}${RPC_PATH}`, {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify({ method, params: [params] })
      });
      if (!r.ok) return { error: await r.text(), status: r.status };
      return await r.json();
    } catch (e) {
      return { error: String(e) };
    }
  }

  const SYSTEM = {
    role: "system",
    content:
`You are an impartial XRPL site auditor.
Use only the provided evidence (site manifests, security.txt, provenance, and on-ledger XRPL data).
If a fact cannot be verified, state what is missing and how to verify it.
Never ask for seeds or secret keys. Remind users to verify wallet signing payloads in their wallet.
Be concise and specific.`
  };

  // UPDATED: explicit wallet scoring rule (no connect = pass)
  const INSTRUCTIONS = {
    role: "user",
    content:
`Return two parts:

1) JSON-RUBRIC ONLY on the first line:
{
  "verdict": "safe|caution|unsafe",
  "reasons": ["..."],
  "evidence": [
    {"item":"issuer_blackholed","status":"pass|warn|fail","details":"..."},
    {"item":"manifests_accessible","status":"pass|warn|fail","details":"..."},
    {"item":"read_only_endpoints","status":"pass|warn|fail","details":"..."},
    {"item":"wallet_connect_flow","status":"pass|warn|fail","details":"..."},
    {"item":"dex_liquidity_presence","status":"pass|warn|fail","details":"..."}
  ],
  "recommended_actions": ["..."]
}

Scoring details:
- issuer_blackholed = pass if AccountRoot shows master disabled AND no RegularKey; warn if only one holds; fail otherwise.
- manifests_accessible = pass if universal-ai.json (XRBC + XRBitcoin) and /.well-known/security.txt return 200; warn if any missing; fail if all missing.
- read_only_endpoints = pass if endpoints list only read-only XRPL methods; warn if unclear; fail if mutating methods present.
- wallet_connect_flow = "pass" if wallet_connect_detection == "absent" OR if a connect UI exists but delegates signing entirely to a known wallet app and never asks for seeds/secret keys; "warn" only if a connect UI exists but behavior is unclear; "fail" only if any component requests seeds/secret keys or auto-initiates signing.
- dex_liquidity_presence = pass if an AMM pool exists OR book_offers >= 3; warn if 1‚Äì2; fail if none/errored.

2) Then a short human explanation (3‚Äì6 sentences).`
  };

  async function collectEvidence() {
    // Site documents
    const [xrbc, xrb, idx, sec, prov] = await Promise.all([
      get("/universal-ai.json"),
      get("/XRBitcoin/universal-ai.json"),
      get("/.well-known/ai.json"),
      get("/.well-known/security.txt"),
      get("/ai/provenance.json")
    ]);

    // On-ledger checks
    async function issuerFacts(account){
      const info = await rpc("account_info", { account, ledger_index:"validated" });
      const objs = await rpc("account_objects", { account, type:"signer_list", ledger_index:"validated" });
      return { info, objs };
    }
    const [xrbcLedger, xrbLedger] = await Promise.all([
      issuerFacts(XRBC_ISSUER),
      issuerFacts(XRB_ISSUER)
    ]);

    // Orderbooks
    const bookXRB  = await rpc("book_offers", {
      taker_gets: { currency:"XRP" },
      taker_pays: { currency: HEX_XRB, issuer: XRB_ISSUER },
      ledger_index:"validated", limit:10
    });
    const bookXRBC = await rpc("book_offers", {
      taker_gets: { currency:"XRP" },
      taker_pays: { currency: HEX_XRBC, issuer: XRBC_ISSUER },
      ledger_index:"validated", limit:10
    });

    // Explicit wallet-connect detection (hard flag)
    const hasWalletUI = !!document.querySelector(
      '[href*="xumm.app"],[href*="xaman.app"],[data-wallet],.wallet-connect'
    );
    const walletConnectDetection = hasWalletUI ? "present" : "absent";

    const pageFp = {
      url: location.href,
      wallet_connect_detection: walletConnectDetection,
      outboundExchanges: Array.from(document.querySelectorAll('a[href*="sologenic.org"],a[href*="xpmarket.com"]')).map(a=>a.href),
      canonical: (document.querySelector('link[rel="canonical"]')||{}).href || null
    };

    return {
      role: "user",
      content:
`EVIDENCE:
- xrbc_manifest (status ${xrbc.status}):\n${xrbc.text}
- xrbitcoin_manifest (status ${xrb.status}):\n${xrb.text}
- ai_index (status ${idx.status}):\n${idx.text}
- security_txt (status ${sec.status}):\n${sec.text}
- provenance (status ${prov.status}):\n${prov.text}

- on_ledger:
  xrbc_account_info:\n${JSON.stringify(xrbcLedger.info, null, 2)}
  xrbc_account_objects:\n${JSON.stringify(xrbcLedger.objs, null, 2)}
  xrbitcoin_account_info:\n${JSON.stringify(xrbLedger.info, null, 2)}
  xrbitcoin_account_objects:\n${JSON.stringify(xrbLedger.objs, null, 2)}
  book_offers_xrbitcoin:\n${JSON.stringify(bookXRB, null, 2)}
  book_offers_xrbc:\n${JSON.stringify(bookXRBC, null, 2)}

- page_fingerprint:\n${JSON.stringify(pageFp, null, 2)}`
    };
  }

  // ===== 9) HUMAN GATE + COOLDOWN (new) =====
  let humanVerified = false;
  let holdTimer = null;

  let cooldownUntil = 0;
  const MIN_COOLDOWN_MS = 8000;  // base pause after each call
  const MAX_COOLDOWN_MS = 60000; // safety ceiling

  function msLeft() {
    return Math.max(0, cooldownUntil - Date.now());
  }
  function showCooldown(reason = "Pausing briefly to prevent spam and protect the model‚Äôs rate limits.") {
    const left = msLeft();
    if (left <= 0) {
      cooldownStatus.style.display = "none";
      return;
    }
    cooldownStatus.style.display = "block";
    cooldownStatus.textContent = `‚è≥ ${reason} You can ask again in ${Math.ceil(left / 1000)}s.`;
  }
  function tickCooldown() {
    if (msLeft() <= 0) {
      cooldownStatus.style.display = "none";
      send.disabled = false;
      quickBtns.forEach(b => b.disabled = false);
      return;
    }
    send.disabled = true;
    quickBtns.forEach(b => (b.disabled = true));
    showCooldown();
    requestAnimationFrame(tickCooldown);
  }
  function startCooldown(ms, reason) {
    const now = Date.now();
    cooldownUntil = Math.max(cooldownUntil, now + Math.min(Math.max(ms, 1000), MAX_COOLDOWN_MS));
    tickCooldown();
    showCooldown(reason);
  }
  function requireHumanAndCooldown() {
    if (!humanVerified) {
      append(`<p class="muted small" style="color:#f88">‚ö†Ô∏è Please press and hold the ‚ÄúVerify Human‚Äù button for 2.5 seconds before asking. This blocks spam and protects the model limits.</p>`);
      return false;
    }
    if (msLeft() > 0) {
      showCooldown();
      return false;
    }
    return true;
  }

  // Press & hold human verification
  if (holdBtn) {
    const startHold = () => {
      if (humanVerified) return;
      holdBtn.textContent = "‚è±Ô∏è Keep holding‚Ä¶";
      gateStatus.textContent = "Verifying‚Ä¶ don‚Äôt release yet.";
      holdTimer = setTimeout(() => {
        humanVerified = true;
        holdBtn.textContent = "‚úÖ Verified Human";
        holdBtn.classList.add("glow-green");
        holdBtn.disabled = true;
        gateStatus.textContent = "Thanks! You‚Äôre verified. You can ask now.";
      }, 2500);
    };
    const cancelHold = () => {
      if (humanVerified) return;
      if (holdTimer) clearTimeout(holdTimer);
      holdTimer = null;
      holdBtn.textContent = "‚è∏Ô∏è Press & Hold 2.5s to Verify Human";
      gateStatus.textContent = "Release detected ‚Äî hold continuously until it completes.";
    };
    holdBtn.addEventListener("mousedown", startHold);
    holdBtn.addEventListener("touchstart", (e) => { e.preventDefault(); startHold(); }, { passive: false });
    ["mouseup","mouseleave","touchend","touchcancel"].forEach(evt => holdBtn.addEventListener(evt, cancelHold));
  }

  // ===== 10) CHAT FUNCTION (kept, with corrected error handling & cooldown hooks) =====
  async function postChat(q) {
    if (proxyTimedOut) {
      append(`<p style="color:#f88"><strong>Note:</strong> Proxy fallback mode active ‚Äî please use the backup chat above.</p>`);
      return;
    }

    renderMessage({ role: "user", content: q });
    chatHistory.push({ role: "user", content: q });
    saveChatHistory();

    const spinnerId = "spinner-" + Date.now();
    append(`<p id="${spinnerId}" style="color:#9EB2D0">‚è≥ Connecting to XRBC Auditor‚Ä¶</p>`);

    const awake = await wakeProxy();
    if (!awake) { document.getElementById(spinnerId)?.remove(); showFallback(); return; }

    try {
      // Start a short cooldown immediately to avoid bursts
      startCooldown(MIN_COOLDOWN_MS, "Preventing rapid-fire requests.");

      const ctrl = new AbortController();
      const timer = setTimeout(() => ctrl.abort(), 60000);

      const evidenceMsg = await collectEvidence();

      const payload = {
        model: "gpt-5-thinking",    // if your proxy forwards this
        temperature: 0.2,           // lock low randomness (server should also enforce)
        messages: [SYSTEM, evidenceMsg, INSTRUCTIONS]
                  .concat(chatHistory.slice(-6))
                  .concat([{ role: "user", content: q }])
      };

      const resp = await fetch(`${PROXY}${CHAT_PATH}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
        signal: ctrl.signal
      });

      clearTimeout(timer);
      document.getElementById(spinnerId)?.remove();

      // Single, authoritative error guard
      if (!resp.ok) {
        const errText = await resp.text();
        const retryAfter = Number(resp.headers.get("retry-after") || 0);
        if (resp.status === 429) {
          const ms = retryAfter ? retryAfter * 1000 : 15000;
          startCooldown(ms, "Server is pausing to prevent spam and protect model limits.");
          append(`<p style="color:#f88"><strong>Temporarily Paused:</strong> We‚Äôre throttling requests for ${Math.ceil(ms/1000)}s to avoid hitting model limits. Please wait‚Ä¶</p>`);
        } else {
          append(`<p style="color:#f88"><strong>Upstream error:</strong> ${resp.status} ${esc(errText)}</p>`);
          startCooldown(10000, "Cooling down briefly after an error.");
        }
        return;
      }

      let ans = (await resp.json())?.choices?.[0]?.message?.content || "No answer (proxy connected but returned empty).";

      // ===== HARD-FIX: if wallet_connect_detection == "absent", correct mis-scores =====
      try {
        const walletFlag =
          (evidenceMsg.content.includes('"wallet_connect_detection": "absent"') ? "absent" :
           evidenceMsg.content.includes('"wallet_connect_detection": "present"') ? "present" : "unknown");
        const [firstLine, ...rest] = ans.split("\n");
        const rubric = JSON.parse(firstLine.trim());
        if (walletFlag === "absent") {
          const wItem = Array.isArray(rubric.evidence) ? rubric.evidence.find(e => e.item === "wallet_connect_flow") : null;
          if (wItem && wItem.status !== "pass") {
            wItem.status = "pass";
            wItem.details = "No on-site wallet connect UI detected; lowest exposure.";
            rubric.reasons = Array.from(new Set(
              (rubric.reasons || []).concat("No on-site wallet connect UI; lowest exposure.")
            ));
            ans = JSON.stringify(rubric) + "\n" + rest.join("\n");
          }
        }
      } catch { /* if parsing fails, just show the model output */ }

      // Pretty print
      const [firstLine2, ...rest2] = ans.split("\n");
      let pretty = ans;
      try {
        const rubric2 = JSON.parse(firstLine2.trim());
        pretty = `üßæ <strong>Audit verdict:</strong> <code>${esc(rubric2.verdict)}</code>\n\n` +
                 `‚Ä¢ ${rubric2.reasons.map(esc).join("\n‚Ä¢ ")}\n\n` +
                 rest2.join("\n");
      } catch { /* keep full text if JSON parsing fails */ }

      renderMessage({ role: "assistant", content: pretty });

      // Successful call ‚Äî keep a gentle cool-down to prevent bursts
      startCooldown(MIN_COOLDOWN_MS, "Preventing rapid-fire requests.");

      chatHistory.push({ role: "assistant", content: ans });
      saveChatHistory();

    } catch (err) {
      document.getElementById(spinnerId)?.remove();
      // showFallback also prevents immediate retries
      startCooldown(12000, "Cooling down after a network error.");
      showFallback();
    }
  }

  // ===== 11) INPUT/CONTROLS (wire guards) =====
  send.addEventListener("click", () => {
    if (!requireHumanAndCooldown()) return;
    const q = (inputEl.value || "").trim();
    if (!q) return;
    inputEl.value = "";
    postChat(q);
  });

  inputEl.addEventListener("keydown", e => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      send.click();
    }
  });

  quickBtns.forEach(btn =>
    btn.addEventListener("click", () => {
      if (!requireHumanAndCooldown()) return;
      postChat(btn.dataset.q);
    })
  );

  // ===== 12) VOICE (unchanged) =====
  if ("webkitSpeechRecognition" in window) {
    const recog = new webkitSpeechRecognition();
    recog.continuous = false;
    recog.interimResults = false;
    recog.lang = "en-US";
    voiceBtn.addEventListener("click", () => {
      recog.start();
      voiceBtn.textContent = "üé§ Listening...";
    });
    recog.onresult = e => {
      inputEl.value = e.results[0][0].transcript;
      send.click();
    };
    recog.onend = () => { voiceBtn.textContent = "üé§ Voice"; };
  } else {
    voiceBtn.style.display = "none";
  }

  // ===== 13) CLEANUP (unchanged) =====
  window.addEventListener("beforeunload", () => clearInterval(keepAliveInterval));
})();
</script>
