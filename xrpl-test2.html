<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>XRBitcoinCash · Proxy Wallet Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>
<body>
  <h1>XRBitcoinCash Wallet Connect (via Proxy)</h1>

  <!-- Wallet connect -->
  <button id="connectWalletBtn">Connect Wallet</button>
  <p id="walletStatus">Status: Not connected</p>

  <!-- Ledger info -->
  <button id="fetchLedgerBtn">Fetch Ledger Info</button>
  <pre id="ledgerOutput">—</pre>

  <!-- XRP Price -->
  <button id="fetchPriceBtn">Get XRP/USD Price</button>
  <p id="priceOutput">—</p>

  <!-- Config -->
  <script type="application/json" id="app-config">
  {
    "xummApiKey": "2abde023-0df1-49a2-a4dc-86d776f6318d",
    "proxyUrl": "https://xrbitcoincash-github-io.onrender.com"
  }
  </script>

  <!-- Libraries -->
  <script src="https://xaman.app/assets/cdn/xumm.min.js"></script>

  <script>
  // === Load config ===
  const cfg = JSON.parse(document.getElementById("app-config").textContent);
  const PROXY_URL = cfg.proxyUrl;

  // === Proxy bridge: generic request ===
  async function xrplRequest(payload) {
    const res = await fetch(PROXY_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    if (!res.ok) throw new Error("Proxy error: " + res.status);
    const data = await res.json();
    if (data.error) throw new Error("XRPL error: " + JSON.stringify(data.error));
    return data;
  }

  // === Helpers ===
  async function getLedgerInfo() {
    return await xrplRequest({ method: "ledger", params: [{ ledger_index: "validated" }] });
  }

  async function getAccountInfo(address) {
    return await xrplRequest({ method: "account_info", params: [{ account: address, ledger_index: "validated" }] });
  }

  async function getServerInfo() {
    return await xrplRequest({ method: "server_info" });
  }

  async function getXrpUsdPrice() {
    const payload = {
      method: "book_offers",
      params: [
        {
          taker_gets: { currency: "XRP" },
          taker_pays: {
            currency: "USD",
            issuer: "rvYAfWj5gh67oV6fW32ZzP3Aw4Eubs59B" // Bitstamp USD issuer
          },
          limit: 1
        }
      ]
    };
    const data = await xrplRequest(payload);

    if (data.result && data.result.offers && data.result.offers.length > 0) {
      const offer = data.result.offers[0];
      return parseFloat(offer.quality);
    } else {
      throw new Error("No offers found in XRP/USD book");
    }
  }

  // === Main logic ===
  (async function(){
    // Wallet connect
    const xumm = new Xumm(cfg.xummApiKey);
    const btn = document.getElementById("connectWalletBtn");
    const statusEl = document.getElementById("walletStatus");

    xumm.on("ready", () => {
      console.log("Xumm SDK ready");
      btn.disabled = false;
    });

    btn.addEventListener("click", async () => {
      try {
        await xumm.authorize();
        const acct = await xumm.user.account;
        statusEl.textContent = "Connected: " + acct;
        window.__xrbcWallet = acct;
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Failed to connect wallet";
      }
    });

    // Ledger fetch
    const ledgerBtn = document.getElementById("fetchLedgerBtn");
    const ledgerOut = document.getElementById("ledgerOutput");

    ledgerBtn.addEventListener("click", async () => {
      ledgerOut.textContent = "Loading ledger…";
      try {
        const info = await getLedgerInfo();
        ledgerOut.textContent = JSON.stringify(info, null, 2);
      } catch (err) {
        ledgerOut.textContent = "Error: " + err.message;
      }
    });

    // Price fetch
    const priceBtn = document.getElementById("fetchPriceBtn");
    const priceOut = document.getElementById("priceOutput");

    priceBtn.addEventListener("click", async () => {
      priceOut.textContent = "Loading price…";
      try {
        const price = await getXrpUsdPrice();
        priceOut.textContent = `XRP/USD ≈ $${price}`;
      } catch (err) {
        priceOut.textContent = "Error: " + err.message;
      }
    });
  })();
  </script>
</body>
</html>

